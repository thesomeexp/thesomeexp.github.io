<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring 的学习 | SomeExp</title>
  <meta name="author" content="SomeExp">
  <meta name="description" content="记录 Spring 的学习笔记">
  <meta name="og:description" content="记录 Spring 的学习笔记">  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:image" content="/unicorn.jpg"/>
  <meta property="og:title" content="Spring 的学习"/>
  
  <meta property="og:site_name" content="SomeExp"/>
  <link rel="icon" href="/unicorn.jpg">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">SomeExp</a></h1>
</div>
<nav id="main-nav" class="alignright">
  <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/archives">Archives</a></li>
      <li><a href="/about">About</a></li>
      <li><a href="/links">Links</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
    <div class="post-content">
        <header>
            
  
    <h1 class="title">Spring 的学习</h1>
  

            
                <time itemprop="datePublished"
                      datetime="2020-10-26T16:00:00.000Z">2020-10-27</time>
                <span style="color: rgb(153, 153, 153);">-</span>
                <time itemprop="dateModified"
                      updated="2022-05-29T16:00:00.000Z">2022-05-30</time>
            
        </header>
        <div class="entry">
            
                <p>记录 Spring 的学习笔记</p>
<span id="more"></span>

<h1 id="1-Spring整体设计理念和整体架构"><a href="#1-Spring整体设计理念和整体架构" class="headerlink" title="1. Spring整体设计理念和整体架构"></a>1. Spring整体设计理念和整体架构</h1><h1 id="2-Spring-Ioc"><a href="#2-Spring-Ioc" class="headerlink" title="2. Spring Ioc"></a>2. Spring Ioc</h1><h2 id="2-1-IOC是啥"><a href="#2-1-IOC是啥" class="headerlink" title="2.1 IOC是啥"></a>2.1 IOC是啥</h2><p>IOC是(Inversion Of Control)的简写, 翻译过来叫控制反转, 是一种思想. 简单来说本来一些东西是你自己控制的, 而IOC控制反转的意思是控制权交给别人了, 不需要自己控制. </p>
<h1 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3. Spring AOP"></a>3. Spring AOP</h1><h2 id="3-1-为什么会有AOP"><a href="#3-1-为什么会有AOP" class="headerlink" title="3.1 为什么会有AOP?"></a>3.1 为什么会有AOP?</h2><p>如果你写过基于Spring或者Spring Boot相关的项目, 那你可能会遇到以下的问题.<br>比如说: </p>
<ul>
<li>对于某些方法需要记录日志</li>
<li>对某些方法的执行前需要对用户进行权限判定</li>
</ul>
<p>以上的这些功能, 如果直接写在业务代码中, 那么每个方法都会调用一次这些公用的方法. </p>
<p><img src="/picture/2020-10-29-11-39-46.png" alt="各method都会调用log()方法"></p>
<p>很明显这样显示调用的代码难以管理, 一旦我的log方法一变动, 或者说我有些方法不需要调用这个log()了, 删减method中的代码是一件麻烦事.<br>这时候就可以考虑使用AOP了, AOP和OOP一样是一种观念, 全称为Aspect-oriented programming, 翻译过来叫面向切面编程. 它可以实现对这些重复代码单独抽取出来进行管理维护, 在需要时统一调用, 以及对于如何灵活使用这些公共代码提供了支持. 为了更好的使用AOP技术, 技术专家们是专门成立了一个AOP联盟来探讨AOP标准化, 因此你可以在AOP联盟文档中找到相关介绍. </p>
<h2 id="3-2-Spring-AOP中的一些概念"><a href="#3-2-Spring-AOP中的一些概念" class="headerlink" title="3.2 Spring AOP中的一些概念"></a>3.2 Spring AOP中的一些概念</h2><p>这里直接拿<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop">Spring文档中对AOP的介绍</a>来讲一下. </p>
<ul>
<li><p>Aspect 切面: Aspect是一种模块化的观念, 这种观念将横切经过多个类, 所以翻译过来就是切面. 在企业Java应用中, 事务管理是横切观念很好的例子. 在Spring AOP中, 切面可以通过基于配置文件(配置xml的方式), 或者基于@Aspect注解的类. (这里讲的非常抽象, 把它想成管理切面相关的的配置就好了)</p>
</li>
<li><p>Join Point 连接点: 在程序执行过程中的一个点, 例如方法的执行或者异常的处理. 在Spring AOP中这个连接点总是代表方法执行. (可以理解成就是类中的方法就是连接点)</p>
</li>
<li><p>Advice 通知: 特定切面在特定的连接点执行的操作. 通知有不同的类型, 包括”前置通知”, “后置通知”, “环绕通知”等. (其实就是在什么时候执行, 前置就是在目标方法执行前执行, 后置就是目标方法后执行…) 许多AOP框架, 包括Spring, 将通知建模成为一个拦截器, 并且在连接点周围维护一条由拦截器组成的拦截链. (这就是Spring对Advice的实现方式了. ) </p>
</li>
<li><p>Pointcut 切入点: 切入点是表达连接点的谓词. (就是连接点的集合) 通知是和这个切入点表达式相关联的, 它会在任何匹配切入点的连接点上执行. (例如, 在特定方法上执行通知). 这种根据切点表达式匹配连接点的观念是AOP的核心, 而Spring默认使用AspectJ切入点表达式)</p>
</li>
<li><p>Introduction 引入: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) (TODO: 我不懂求大佬带带)</p>
</li>
<li><p>Target Object 目标对象: 一个即将被一个或者多个切面增强的对象. (增强也就是被通知影响) 也成为”通知对象”. 由于Spring AOP是根据运行时代理实现的, 所以这个对象总是一个代理对象. </p>
</li>
<li><p>AOP proxy AOP代理: 一个为了实现切面契约的AOP框架创建的对象. 在Spring框架中, 它可能是JDK动态代理或者是CGLIB代理. </p>
</li>
<li><p>Weaving 编织: 将切面和其他应用程序类型或者对象连接, 来创建一个增强了的对象. 这可能在编译时完成, (例如使用AspectJ编译器) 加载时, 或者运行时. 而Spring AOP和其他纯Java AOP框架一样, 是在运行时完成织入的.</p>
</li>
</ul>
<h2 id="3-3-Java中AOP的实现"><a href="#3-3-Java中AOP的实现" class="headerlink" title="3.3 Java中AOP的实现"></a>3.3 Java中AOP的实现</h2><h3 id="3-3-1-静态AOP"><a href="#3-3-1-静态AOP" class="headerlink" title="3.3.1 静态AOP"></a>3.3.1 静态AOP</h3><ul>
<li>在编译器, 切面直接以字节码形式编译到目标字节码文件中.</li>
</ul>
<h3 id="3-3-2-动态AOP"><a href="#3-3-2-动态AOP" class="headerlink" title="3.3.2 动态AOP"></a>3.3.2 动态AOP</h3><ul>
<li>在运行时, 目标类加载后, 动态生成代理类, 将切面植入到代理类中.</li>
</ul>
<h4 id="3-3-2-1-基于JDK动态代理"><a href="#3-3-2-1-基于JDK动态代理" class="headerlink" title="3.3.2.1 基于JDK动态代理"></a>3.3.2.1 基于JDK动态代理</h4><p>基于<strong>Java反射</strong>机制实现, 必须要<strong>实现了接口</strong>的业务类才能用这种办法生成代理对象. </p>
<h4 id="3-3-2-2-基于CGLIB代理"><a href="#3-3-2-2-基于CGLIB代理" class="headerlink" title="3.3.2.2 基于CGLIB代理"></a>3.3.2.2 基于CGLIB代理</h4><p>基于<strong>ASM</strong>机制实现，通过<strong>生成业务类的子类</strong>作为代理类。</p>
<h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p><img src="/picture/2020-10-29-16-00-37.png"></p>
<p>不同的AOP实现只是在不同的时刻用不同的工具来实现的, 下面就只讲Spring的AOP. </p>
<h2 id="3-4-Spring-AOP的实现"><a href="#3-4-Spring-AOP的实现" class="headerlink" title="3.4 Spring AOP的实现"></a>3.4 Spring AOP的实现</h2><p>下面就拿Spring 5.2.9的源代码来看咯. </p>
<h3 id="3-4-1-Advice-通知"><a href="#3-4-1-Advice-通知" class="headerlink" title="3.4.1 Advice 通知"></a>3.4.1 Advice 通知</h3><p>Advice是AOP联盟定义的一个接口, 可以在org.aopalliance.aop.Advice中找到它.<br>而Spring提供了更具体的通知类型, BeforeAdvice, AfterAdvice, ThrowsAdvice等. </p>
<ul>
<li>BeforeAdvice接口: 前置通知的标记接口. </li>
<li>AfterAdvice接口: 后置通知的标记接口. </li>
<li>ThrowsAdvice接口: 一般抛出异常就由这个接口处理.</li>
</ul>
<p>Spring中比BeforeAdvice接口更具体一点的实现是MethodBeforeAdvice接口: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">BeforeAdvice</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它提供了一个before方法, 它会在方法被调用前被调用. 这个通知不能阻止方法调用的过程, 除非它抛出Throwable. 如果方法签名允许, 它抛出的任何异常都会返回给调用方. 否则异常会被包装为运行时异常. 而它的method参数是目标方法的反射对象; args对象数组中包含目标方法的输入参数; target为目标对象. </p>
<p>下面是AfterAdvice更具体的AfterReturningAdvice接口: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它提供了afterReturning方法, 顾名思义就是在目标对象方法成功返回值了之后执行. (前提当然目标方法也没抛异常) 它可以获得返回值但是无法改变返回值. 参数returnValue为返回值; </p>
<p>然后是ThrowsAdvice, 它是继承AfterAdvice: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个接口并没有规定的方法, 如果需要你需要实现这种形式的方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">([Method, args, target], ThrowableSubclass)</span>;</span><br></pre></td></tr></table></figure>

<p>其中方括号内的参数是可选的. 如果该异常通知抛出新的异常, 将会覆盖原来的异常. </p>
<h3 id="3-4-2-Pointcut-切点"><a href="#3-4-2-Pointcut-切点" class="headerlink" title="3.4.2 Pointcut 切点"></a>3.4.2 Pointcut 切点</h3><p>Spring AOP提供了具体的切点, 比如JdkRegexpMethodPointcut的matches方法是通过JDK来实现正则表达式的匹配的. NameMatchMethodPointcut的matches方法就是使用方法名相同或者方法名相匹配. </p>
<h3 id="3-4-3-Advisor-通知器"><a href="#3-4-3-Advisor-通知器" class="headerlink" title="3.4.3 Advisor 通知器"></a>3.4.3 Advisor 通知器</h3><p>通过Advisor可以将Advice和Pointcut结合起来. </p>
<h3 id="后面太难了-夭折了…"><a href="#后面太难了-夭折了…" class="headerlink" title="后面太难了, 夭折了…"></a>后面太难了, 夭折了…</h3><p>Spring通过jdk和cglib两个精彩的实现了AOP, 虽然我们用起来很简单, 但是Spring实现AOP的过程是非常艰苦的, (是我太菜了看不懂了. ) </p>
<h1 id="4-Spring-MVC"><a href="#4-Spring-MVC" class="headerlink" title="4. Spring MVC"></a>4. Spring MVC</h1><h2 id="4-1-网络基础知识"><a href="#4-1-网络基础知识" class="headerlink" title="4.1 网络基础知识"></a>4.1 网络基础知识</h2><p>在此之前先学习一下<a href="/2020/basic-computer-network">计算机网络基础知识</a>. </p>
<p>在BS结构中使用到了DNS协议, 而且在HTTP上层还有相关规范, 如Java Web开发中使用的是Servlet标准. 标准就是规范, 都是不能干活的, 能干活的就是实现了Servlet标准的Tomcat这种Servlet容器. </p>
<h3 id="4-1-1-Java中的Socket"><a href="#4-1-1-Java中的Socket" class="headerlink" title="4.1.1 Java中的Socket"></a>4.1.1 Java中的Socket</h3><p>Java中的Socket可以分为<strong>普通Socket</strong>和<strong>NioSocket</strong>两种. </p>
<h4 id="普通Socket"><a href="#普通Socket" class="headerlink" title="普通Socket"></a>普通Socket</h4><p>Java中的网络通信是通过Socket实现的, java.net包里的Socket主要分为<strong>Socket</strong>和<strong>ServerSocket</strong>两类. </p>
<ul>
<li>java.net.ServerSocket: 用于服务端, 可以通过accept方法监听请求, 监听到Socket请求后用该Socket完成数据传输. </li>
<li>java.net.Socket: 用于客户端发起请求并传输数据.</li>
</ul>
<h4 id="new-IO模式Socket"><a href="#new-IO模式Socket" class="headerlink" title="new IO模式Socket"></a>new IO模式Socket</h4><p>&#x2F;&#x2F; TODO 以后再说</p>
<p>这两个例子书中的代码我都放在<a target="_blank" rel="noopener" href="https://github.com/thesomeexp/JavaExample/tree/master/KanTouSpringMVC">这里</a>啦. </p>
<h3 id="4-1-2-Servlet详解"><a href="#4-1-2-Servlet详解" class="headerlink" title="4.1.2 Servlet详解"></a>4.1.2 Servlet详解</h3><p>Servlet是Server+Applet的缩写, 表示一个服务器应用. 它是一套规范, 按照这套规范写的代码就可以直接在Java的服务器上运行. </p>
<p><img src="/picture/2020-11-05-11-18-18.png"></p>
<p>Servlet一些方法: </p>
<ul>
<li>init(): 在容器启动时被容器调用. (当load-on-startup设置为负数或者不设置时会在Servlet第一次用到时才被调用)</li>
<li>getServletConfig(): 用于获取ServletConfig. </li>
<li>getServletInfo(): 获取Servlet相关信息, 如作者, 版权等, 默认空. </li>
<li>service(): 具体处理请求的方法</li>
<li>destroy(): Servlet销毁(关闭服务器)时释放一些资源, 调用一次.</li>
</ul>
<p>ServletConfig一些方法: </p>
<ul>
<li>getServletName(): 获取Servlet名字, web.xml中定义的servlet-name. </li>
<li>getInitParameter(): 获取init-param配置参数. </li>
<li>getInitParameterNames(): 获取配置所有init-param的名字的集合. </li>
<li>getServletContext(): 这个非常重要, 它的返回值ServletContext就是这个应用本身. 所以这里面的参数就可以被当前应用的所有Servlet共享. 比如我们项目中参数可以保存在Session中, 也可以在Application中, 而这个Application多数就是保存在ServletContext.</li>
</ul>
<p>简单来说ServletConfig能获取一些web.xml配置好的servlet信息, 然后还能获得整个Servlet上下文. Servlet容器通过把这个ServletConfig作为参数传入Servlet的init()方法中, 便于Servlet的配置. </p>
<p>GenericServlet作为一个协议无关的Servlet的默认实现, 主要做了三件事: </p>
<ul>
<li><ol>
<li>实现ServletConfig接口, 使得可以直接调用里面的方法.</li>
</ol>
</li>
<li><ol start="2">
<li>提供无参的init()模板方法. (带参的init方法做了config的配置, 所以子类只需要覆盖无参init()专注于完成逻辑就好了)</li>
</ol>
</li>
<li><ol start="3">
<li>提供log()方法. 一般我们都有自己的日志处理, 这个用得不多.</li>
</ol>
</li>
</ul>
<p>HttpServlet做的比较重要的事情: </p>
<ul>
<li><ol>
<li>覆盖service()方法, 主要将ServletRequest和ServletResponse转换为HttpServletRequest和HttpServletResponse. 然后调用自己的service()方法.</li>
</ol>
</li>
<li><ol start="2">
<li>自身的service()方法, 根据HttpServletRequest的请求方法, 用不同的doXXX结构的处理方法处理.</li>
</ol>
</li>
</ul>
<p>注意到doGet方法处理前它判断了if-modified-since, 如果缓存没过期就返回304使用缓存.<br>而doHead调用了doGet请求, 然后返回空body的Response.<br>而doOptions和doTrace正常不需要使用, 主要用来做调试, 它会对header原封不动的返回, 这种做法很容易被黑客利用, 存在安全漏洞, 如果不是必须使用最好禁用. </p>
<p>简单来说HttpServlet把不同请求方式路由到了不同的处理方法. </p>
<h2 id="4-2-Tomcat"><a href="#4-2-Tomcat" class="headerlink" title="4.2 Tomcat"></a>4.2 Tomcat</h2><h3 id="4-2-1-Tomcat的顶层结构"><a href="#4-2-1-Tomcat的顶层结构" class="headerlink" title="4.2.1 Tomcat的顶层结构"></a>4.2.1 Tomcat的顶层结构</h3><p>Tomcat中最顶层的容器叫Server. </p>
<ul>
<li>Server: 这是Tomcat中最顶层的容器, 它代表整个服务器. 它包含至少一个Service, 用于提供服务. </li>
<li>Service: 它包含一个Container和一个或多个Connector(一个服务可以有多个连接, 如同时提供http与https, 也可以提供同协议不同端口的连接). </li>
<li>Connector: 它用于处理连接相关的事情, 并提供Socket与request, response的转换. </li>
<li>Container: 用于封装和管理Servlet, 具体处理request请求.</li>
</ul>
<p><img src="/picture/2020-11-05-14-54-04.png"></p>
<p>而Tomcat的Server是由org.apache.catalina.startup.Catalina来管理的, Catalina是整个Tomcat的管理类. 它的方法: </p>
<ul>
<li><ol>
<li>load(): 用于根据conf&#x2F;server.xml文件创建Server并调用Server的init()方法进行初始化.</li>
</ol>
</li>
<li><ol start="2">
<li>start(): 用于启动服务器. 在内部调用Server的start()方法.</li>
</ol>
</li>
<li><ol start="3">
<li>stop(): 用于停止服务器. 在内部调用Server的stop()方法.</li>
</ol>
</li>
<li>await(): 该方法调用Server的await()方法, 作用是进入一个循环让主线程不会退出.</li>
</ul>
<p>上面的三个方法会按照容器的结构逐层调用相应的方法. 比如Server的start()会调用Service的start(), 而Service的start()会调用包含的Connector和Container的start(). </p>
<p>而Tomcat的入口方法并不在Catalina类里面, 而是在org.apache.catalina.startup.Bootstrap里面. 这个Bootstrap类似一个CatalinaAdaptor, 具体过程还是Catalina来完成的, 这样的好处是把启动入口和具体的管理类分开, 可以方便的创造出不同的启动方式, 每种启动方式只需要写相应的CatalinaAdaptor就好了. </p>
<h3 id="4-2-2-Bootstrap的启动过程"><a href="#4-2-2-Bootstrap的启动过程" class="headerlink" title="4.2.2 Bootstrap的启动过程"></a>4.2.2 Bootstrap的启动过程</h3><ul>
<li><ol>
<li>main(): 新建一个Bootstrap对象, 执行init()方法, 然后处理main方法传入的args参数命令, 如果为空默认执行setAwait() —&gt; load(args) —&gt; start().</li>
</ol>
</li>
<li><ol start="2">
<li>init(): 初始化ClassLoader创建Catalina实例赋值给catalinaDaemon变量, 后面对命令操作都是用catalinaDaemon.</li>
</ol>
</li>
<li><ol start="3">
<li>setAwait(): 通过反射调用对应Catalina的setAwait().</li>
</ol>
</li>
<li><ol start="4">
<li>load(args): 通过反射调用对应Catalina的load(args).</li>
</ol>
</li>
<li><ol start="5">
<li>start(): 通过反射调用对应的Catalina的start().</li>
</ol>
</li>
</ul>
<h3 id="4-2-3-Catalina的启动过程"><a href="#4-2-3-Catalina的启动过程" class="headerlink" title="4.2.3 Catalina的启动过程"></a>4.2.3 Catalina的启动过程</h3><ul>
<li><ol>
<li>setAwait(): 用于设置Server启动后是否进入等待的await标志. 可以看到start()后会用await标志判断是否执行await().</li>
</ol>
</li>
<li><ol start="2">
<li>load(args): 根据conf&#x2F;server.xml加载配置文件创建并初始化Server对象, 然后赋值给server属性(具体操作是通过开源项目Digester完成的), 然后调用server的init().</li>
</ol>
</li>
<li><ol start="3">
<li>start(): 调用server的start(), 然后根据await属性判断是否让程序进入等待状态. (server的await()方法内部会执行一个while循环, 当await()方法退出时会执行stop()从而关闭服务器)</li>
</ol>
</li>
</ul>
<h3 id="4-2-4-Server的启动过程"><a href="#4-2-4-Server的启动过程" class="headerlink" title="4.2.4 Server的启动过程"></a>4.2.4 Server的启动过程</h3><p>Server接口提供addService(), removeService来添加和删除Service. 而Server的init()和start()方法分别循环调用每个Service的init()和start()方法来启动所有Service. </p>
<p>Server的默认实现是org.apache.catalina.core.StandardServer, 而StandardServer继承自LifecycleMBeanBase, LifecycleMBeanBase又继承自LifecycleBase: </p>
<p><img src="/picture/2020-11-05-16-04-08.png"></p>
<p>init()和start()方法就定义在LifecycleBase中, LifecycleBase里的init()和start()方法又调用initInternal()和startInternal()这两个模板方法, 所以调用StandardServer的init()和start()方法时会执行StandardServer自己的initInternal()和startInternal()这两个方法, 这就是Tomcat生命周期的管理方式. initInternal()和startInternal()这两个方法分别循环调用了每一个Service的start()和init()方法. </p>
<p>StandardServer还实现了**await()**方法, Catalina就是调用它让服务器进入等待状态的. 但是啥时候退出呢? 这就是await()方法要干的活了. 它根据Server设置的端口号来关闭(这个端口号不是服务的端口号, 是专门用来监听停止容器命令的端口, 默认是8005). 根据这个端口号的值, 它有三种处理方法: </p>
<ul>
<li>port为-2, 则直接退出, 不进入循环. </li>
<li>port为-1, 进入一个循环, 只有调用了stopAwait方法才会退出循环. (方法关闭)</li>
<li>port为其他值, 会在port所在端口启动一个ServerSocket来监听关闭命令(默认为”SHUTDOWN”), 默认为8005, 如果接收到了则跳出循环. (网络命令关闭)</li>
</ul>
<h3 id="4-2-5-Service的启动过程"><a href="#4-2-5-Service的启动过程" class="headerlink" title="4.2.5 Service的启动过程"></a>4.2.5 Service的启动过程</h3><p>Service接口的默认实现是org.apache.catalina.core.StandardService, StandardService也继承LifecycleMBeanBase类, 所以init()和start()方法最终也会调用initInternal()和startInternal()方法. </p>
<p><img src="/picture/2020-11-05-16-21-49.png"></p>
<p>我们看StandardService中的initInternal()和startInternal()方法, 它其实是调用了container, executors, mapperListener, connectors的init()和start()方法. container和connectors前已经介绍过, mapperListener是Mapper的监听器, 它可以监听container容器的变化, executors是用在connectors中管理线程的线程池, 在server.xml配置文件中有参考用法, 不过默认是注释起来的: </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;</span></span><br><span class="line"><span class="comment">    maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>把上面的注释放开, Connector就会配置一个叫tomcatThreadPool的线程池, 最多可以同时启动150个线程, 最少要有4个可用线程. </p>
<p>整个Tomcat服务器启动流程就是: </p>
<p><img src="/picture/2020-11-05-17-23-55.jpg"></p>
<h3 id="4-2-6-Tomcat的生命周期管理"><a href="#4-2-6-Tomcat的生命周期管理" class="headerlink" title="4.2.6 Tomcat的生命周期管理"></a>4.2.6 Tomcat的生命周期管理</h3><p>下面的内容需要学习<strong>观察者模式</strong>才能看懂哦.<br>Tomcat通过org.apache.catalina.Lifecycle接口统一管理生命周期, 所有有生命周期的组件都要实现Lifecycle接口.<br>而这个生命周期管理的Lifecycle接口是拿来干嘛的呢? 由Lifecycle接口上面的注释我们可以了解到, 实现了这个接口的组件, 他们就会有以下的这些合法的状态值, 以及状态之间的转换, 在状态转换之间触发事件, 然后监听器们通过判断事件的类型来做相应处理. 下面这个是组件的状态机图(这个图看着难受, 过一眼就行了): </p>
<p><img src="/picture/2020-11-06-10-10-10.png"></p>
<p>这个接口主要有这些内容: </p>
<ul>
<li><ol>
<li>定义了13个String类型常量, 这是LifecycleEvent事件中的<strong>事件类型</strong>. 用于LifecycleEvent事件中的type属性, 作用是区分组件发出的LifecycleEvent事件时的状态(如初始化前, 启动前, 启动中等). 这种设计方式可以让多种状态都发送同一种类型的事件, 然后用其中的一个属性来区分状态而不用定义多种事件. 书本作者大佬说我们要学习借鉴这种方式.</li>
</ol>
</li>
<li><ol start="2">
<li>定义了三个管理监听器的方法: addLifecycleListener(), findLifecycleListeners(), removeLifecycleListener(), 分别用来添加, 查找, 删除LifecycleListener类型的监听器.</li>
</ol>
</li>
<li><ol start="3">
<li>定义了4个生命周期的方法: init(), start(), stop(), destroy(), 用于执行生命周期的各个阶段的操作.</li>
</ol>
</li>
<li><ol start="4">
<li>定义了获取当前状态的两个方法, getState()和getStateName()分别用来获取当前的状态. getState()返回值LifecycleState是枚举类型, 里面列举了<strong>生命周期的各个节点</strong>, getStateName()方法返回String类型的状态名字, 主要用于JMX中.</li>
</ol>
</li>
</ul>
<h3 id="4-2-7-Container分析"><a href="#4-2-7-Container分析" class="headerlink" title="4.2.7 Container分析"></a>4.2.7 Container分析</h3><p>Container是Tomcat中容器的接口, 因为作为Tomcat的容器组件所有有生命周期继承Lifecycle接口.<br>它有4个子接口(子容器)和一个默认实现ContainerBase, 而且子容器都继承默认实现ContainerBase: </p>
<p><img src="/picture/2020-11-06-14-54-35.png" alt="Container结构图"></p>
<p>Container的子容器Engine, Host, Context, Wrapper是逐层包含的关系, 其中Engine是最顶层, 每个Service最多只能有一个Engine, 每个Engine里面可以有多个Host, 每个Host下可以有多个Context, 每个Context下可以有多个Wrapper. </p>
<p><img src="/picture/2020-11-06-14-59-25.jpg"></p>
<ul>
<li>Engine: 引擎, 用来管理多个站点, 一个Service最多只能有一个Engine. (也就是很久之前结构图的Container)</li>
<li>Host: 代表一个站点, 也可以叫虚拟主机, 通过配置Host就可以添加站点. </li>
<li>Context: 代表一个应用程序, 对应着平时开发的一套程序, 或者一个WEB-INF目录以及下面的web.xml文件. </li>
<li>Wrapper: 每个Wrapper封装着一个Servlet.</li>
</ul>
<p>上面写得我觉得比较抽象, 还是直接看Tomcat目录吧:<br><strong>Host</strong>: Tomcat的默认Host(主机名)为localhost, 在conf&#x2F;server.xml也能看到相关配置(这里简单的抽取一些配置): </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Tomcat启动时默认监听所有IP地址, 如果仅仅本地测试可以在Service下的Connector中配置address&#x3D;”127.0.0.1”来设置仅监听本地. </p>
<p><img src="/picture/2020-11-06-15-04-52.png"></p>
<p><strong>Context</strong>: 代表应用, 而ROOT目录里的应用就是主应用, 直接使用主机名&#x2F;应用名就能访问对应的应用, 比如我们启动Tomcat后访问127.0.0.1&#x2F;docs就能访问docs这个应用了. </p>
<p><img src="/picture/2020-11-06-15-07-58.png"><br><img src="/picture/2020-11-06-15-48-24.jpg"></p>
<p>4种容器的配置方法:<br>作者简化了默认配置来供我们学习哦: </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&#x27;8005&#x27;</span> <span class="attr">shutdown</span>=<span class="string">&#x27;SHUTDOWN&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&#x27;Catalina&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&#x27;8080&#x27;</span> <span class="attr">protocol</span>=<span class="string">&#x27;HTTP/1.1&#x27;</span> <span class="attr">connectionTimeout</span>=<span class="string">&#x27;20000&#x27;</span> <span class="attr">redirectPort</span>=<span class="string">&#x27;8443&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&#x27;8009&#x27;</span> <span class="attr">protocol</span>=<span class="string">&#x27;AJP/1.3&#x27;</span> <span class="attr">redirectPort</span>=<span class="string">&#x27;8443&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&#x27;Catalina&#x27;</span> <span class="attr">defaultHost</span>=<span class="string">&#x27;localhost&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&#x27;localhost&#x27;</span>  <span class="attr">appBase</span>=<span class="string">&#x27;webapps&#x27;</span> <span class="attr">unpackWARs</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">autoDeploy</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Server: Server代表整个服务器, 在8005端口监听关闭命令”SHUTDOWN”. Server下有一个叫Catalina的默认Service. </li>
<li>Service: Service里定义了两个Connector, 一个是HTTP协议一个是AJP协议; 还定义了一个叫Catalina的Engine. </li>
<li>Engine: Engine里定义了一个名为localhost的Host. <ul>
<li>defaultHost属性代表接收到的请求域名如果在所有Host的name和Alias都找不到时使用默认的Host. 如果使用IP直接访问也会用到defaultHost, 如果删掉该属性, 启动后通过IP就没有办法访问咯.</li>
</ul>
</li>
<li>Host: 一个Host就代表一个主机咯. <ul>
<li>name属性代表主机名, 上面定义的主机名为localhost, 所以可以通过localhost可以访问. </li>
<li>appBase属性指定站点的位置, 比如上面定义的站点就是默认的webapps目录. </li>
<li>unpackWARs属性代表是否自动解压war文件</li>
<li>autoDeploy属性为true代表Tomcat在运行过程中在webapps目录中加入新的应用将会自动部署并启动.</li>
</ul>
</li>
<li>Alias: 这个是Host下的一个标签, 这个标签定义主机别名. 比如你可以把Engine的defaultHost属性删掉, 然后再加上Alias标签, 标签内的值为<a target="_blank" rel="noopener" href="http://www.localhost/">www.localhost</a>, 那么就能通过 <a target="_blank" rel="noopener" href="http://www.localhost/">www.localhost</a> 主机别名也能访问了.</li>
</ul>
<p>Context的三种配置方法: </p>
<ul>
<li><ol>
<li>通过文件配置(有5个位置)</li>
</ol>
<ul>
<li>1.1 conf&#x2F;server.xml文件中的Context标签. (配置单独的应用)</li>
<li>1.2 conf&#x2F;[enginename]&#x2F;[hostname]&#x2F;目录下以应用命名的xml文件. (配置单独的应用)</li>
<li>1.3 应用自己的&#x2F;META-INF&#x2F;context.xml文件. (配置单独的应用)</li>
<li>1.4 conf&#x2F;context.xml文件. (整个Tomcat中共享, Tomcat重启时才重新加载)</li>
<li>1.5 conf&#x2F;[enginename]&#x2F;[hostname]&#x2F;context.xml.default文件. (整个Host中共享)</li>
</ul>
</li>
<li><ol start="2">
<li>将WAR应用直接放到Host目录下, Tomcat会自动查找并添加到Host中.</li>
</ol>
</li>
<li><ol start="3">
<li>将应用文件夹放到Host目录下, Tomcat也会自动查找并添加到Host中.</li>
</ol>
</li>
</ul>
<p>Wrapper的配置就是再web.xml中配置的Servlet, 一个Servlet对应一个Wrapper. 也可以在conf&#x2F;web.xml文件中配置全局的Wrapper, 处理Jsp的JspServlet就配置在这里, 所有不需要自己配置Jsp就可以处理Jsp请求了. </p>
<p>注: conf&#x2F;web.xml配置了两个全局Servlet, 一个是DefaultServlet, 另一个是JspServlet, 分别负责处理一些媒体文件和jsp文件. 如果应用中配置了对应的url-pattern标签将会覆盖这两个默认的Servlet. 所有在使用SpringMVC配置DispatcherServlet的mapping为&#x2F;的时候, 会覆盖DefaultServlet, 这时类似.jpg, .png这种静态资源就得不到处理, 所以就会报404错误, 所以对于这些静态资源在SpringMVC里需要做格外的处理. </p>
<p>由于Service下的所有站点都是共享Connector, 所以监听的端口都一样. 如果想要添加监听不同端口的站点可以通过不同的Service配置, Service也是在conf&#x2F;server.xml文件中配置的. </p>
<p>&#x2F;&#x2F; TODO 然后巴拉巴拉就是Container启动的内容了, 这我懒了不写了, 启动完就会启动下面的管道了</p>
<h3 id="4-2-8-Pipeline-Value管道"><a href="#4-2-8-Pipeline-Value管道" class="headerlink" title="4.2.8 Pipeline-Value管道"></a>4.2.8 Pipeline-Value管道</h3><p>Container处理请求是使用Pipeline-Value管道来处理的. 这种处理方式能确保每一层都能有序的执行到, 从顶层Engine到Host到Context再到Wrapper…<br>这个模式类似于设计模式中的<strong>责任链模式</strong>. 但又有几点不同: </p>
<ul>
<li><ol>
<li>每个Pipeline都有特定的Valve(对, 是Valve不是Value), 且是最后一个执行, 这个Valve叫BaseValve, 是不可删除滴.</li>
</ol>
</li>
<li><ol start="2">
<li>上层容器的管道的BaseValve会调用下层容器的管道. 四个容器的BaseValve分别是StandardEngineValve, StandardHostValve, StandardContextValve, StandardWrapperValve.</li>
</ol>
</li>
</ul>
<p>它们的执行流程如下图: </p>
<p><img src="/picture/2020-11-09-10-45-31.png"></p>
<p>在Engine的管道中依次执行Engine的各个Valve, 最后执行StandardEngineValve用于调用Host的管道, 然后执行Host的Valve, 这样依此类推执行Wrapper管道中的StandardWrapperValve. </p>
<p>在Filter中用到的FilterChain其实就是这种模式, FilterChain相当于Pipeline, 每个Filter都相当于一个Valve, Servlet相当于最后的BaseValve. </p>
<p>管道呢既是一个组件(所以有生命周期), 又是拿来处理请求的, 所以就分两部分咯. </p>
<ul>
<li>首先就是org.apache.catalina.core.ContainerBase的startInternal()和stopInternal()对管道进行启动和关闭. </li>
<li>然后处理请求是调用Valve的invoke()方法, 比如org.apache.catalina.core.StandardEngineValve中处理完会调用host的首个Valve, 一层一层下来直到最后的StandardWrapperValve.</li>
</ul>
<p>所以总的流程就是, Connector在接收到请求之后会调用最顶层容器的Pipeline来处理, 最顶层处理完会在BaseValve里调用下一层容器的Pipeline处理, 这样可以逐层调用所有容器的Pipeline来处理. 处理到最后, Wrapper的Pipeline最后会在其BaseValue(StandardWrapperValve)中创建FilterChain并调用其doFilter方法来处理请求, FilterChain包含着我们配置的与请求相匹配的Filter和Servlet, 其doFilter方法会依次调用所有Filter的doFilter方法和Servlet的service方法, 这样请求就得到处理了. </p>
<h3 id="4-2-9-Connector分析"><a href="#4-2-9-Connector分析" class="headerlink" title="4.2.9 Connector分析"></a>4.2.9 Connector分析</h3><p>简单来说Connector用来接收请求然后封装成Request和Response来具体处理, 它的底层就是使用Socket来进行连接的, Request和Response是按照HTTP协议来封装的, 所以Connector同时实现了TCP&#x2F;IP协议和HTTP协议, 封装完之后就交给Container进行处理, Container就是Servlet的容器, 处理完后再返回给Connector最后Connector使用Socket将处理结果返回给客户端, 整个请求就处理完了. 作者提供的结构关系图: </p>
<p><img src="/picture/2020-11-09-11-54-34.jpg"></p>
<p>&#x2F;&#x2F; TODO: 砍刀部动手, 这部分细节就砍了</p>
<h2 id="4-3-Spring-MVC"><a href="#4-3-Spring-MVC" class="headerlink" title="4.3 Spring MVC"></a>4.3 Spring MVC</h2><h3 id="4-3-1-整体结构"><a href="#4-3-1-整体结构" class="headerlink" title="4.3.1 整体结构"></a>4.3.1 整体结构</h3><p>上一波Spring MVC中核心的继承结构图: </p>
<p><img src="/picture/2020-11-09-14-24-42.png"></p>
<p>图中Java方面的三个类之前已经讲过了, 下面都是讲SpringMVC中的HttpServletBean, FrameworkServlet和DispatcherServlet这三个类.<br>这三个类直接实现三个接口, EnvironmentAware, EnvironmentCapable, ApplicationContextAware. 这种XXXAware在Spring里表示对XXX可感知, 也就是说某个类想使用Spring的一些东西, 可以实现这个接口然后实现对应的set方法, Spring就会给你带过来. </p>
<h3 id="4-3-2-HttpServletBean介绍"><a href="#4-3-2-HttpServletBean介绍" class="headerlink" title="4.3.2 HttpServletBean介绍"></a>4.3.2 HttpServletBean介绍</h3><p>在之前对Servlet的分析时, 我们知道创建Servlet时, 它的init()方法会被容器调用, 而org.springframework.web.servlet.HttpServletBean的init()方法将Servlet中配置的参数使用BeanWrapper设置到DispatcherServlet的相关属性中, 然后调用模板方法initServletBean(), 子类就通过这个方法初始化. </p>
<p>对于这个HttpServletBean, 它的上一级GenericServlet有一个使用transient修饰的ServletConfig, 这个修饰符表示修饰的内容不会被序列化, 在这里可能是config不是很重要所以不用序列化吧. </p>
<p>注: BeanWrapper怎么用? 它是Spring提供的操作JavaBean属性的工具, 用它可以直接修改一个对象的属性. 作者举了个例子: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanWrapperTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        bw.setPropertyValue(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">        <span class="type">PropertyValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        bw.setPropertyValue(value);</span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-FrameworkServlet介绍"><a href="#4-3-3-FrameworkServlet介绍" class="headerlink" title="4.3.3 FrameworkServlet介绍"></a>4.3.3 FrameworkServlet介绍</h3><p>根据上面HttpServletBean可知, 这个FrameworkServlet的初始化入口方法是initServletBean(), 然后它的核心代码主要是初始化WebApplicationContext还有初始化FrameworkServlet. &#x2F;&#x2F; TODO: 下面巴拉巴拉就懒得写了</p>
<h3 id="4-3-4-DispatcherServlet介绍"><a href="#4-3-4-DispatcherServlet介绍" class="headerlink" title="4.3.4 DispatcherServlet介绍"></a>4.3.4 DispatcherServlet介绍</h3><p>onRefresh()方法是DispatcherServlet入口方法, DispatcherServlet的创建过程主要是对9大组件进行初始化. </p>
<h3 id="4-3-5-HttpServletBean使用"><a href="#4-3-5-HttpServletBean使用" class="headerlink" title="4.3.5 HttpServletBean使用"></a>4.3.5 HttpServletBean使用</h3><p>作者说这个东西主要参与了创建工作, 没有涉及请求的处理. </p>
<h3 id="4-3-6-FrameworkServlet使用"><a href="#4-3-6-FrameworkServlet使用" class="headerlink" title="4.3.6 FrameworkServlet使用"></a>4.3.6 FrameworkServlet使用</h3><ul>
<li>对service()方法添加了对PATCH的处理, 将需要自己处理的请求都集中到了processRequest()进行统一处理, 这和HttpServlet中根据request的类型分开到不同方法处理相反. </li>
<li>processRequest里面主要的处理逻辑交给了doService, 这是一个模板方法等子类实现. 然后就是对request获取到的LocaleContext和RequestAttributes进行了保存, 处理完之后恢复, 最后发布了ServletRequestHandleEvent事件.</li>
</ul>
<h3 id="4-3-7-DispatcherServlet使用"><a href="#4-3-7-DispatcherServlet使用" class="headerlink" title="4.3.7 DispatcherServlet使用"></a>4.3.7 DispatcherServlet使用</h3><p>通过前面分析, 它的入口方法是doService()…&#x2F;&#x2F; TODO: 具体的就不再写了, 这个类主要解释三个概念: HandlerMapping, Handler和HandlerAdapter. </p>
<ul>
<li>Handler: 也就是处理器, 它直接对应MVC中的C也就是Controller层, 它的具体表现形式有很多, 可以是类也可以是方法, 作者说如果你想到别的表现形式也可以使用, 它的类型是Object嘛. 在平常我们写Controller时标注的@RequestMapping的方法都可以看成一个Handler, 只要可以实际处理请求就可以是Handler. </li>
<li>HandlerMapping: SpringMVC中会处理很多请求, 每个请求都需要一个Handler来处理, 而它就是拿来查找Handler的. </li>
<li>HandlerAdapter: 从名字能看出它是一个适配器, 因为Handler可以是任意形式的, 但是Servlet处理的方法结构是固定的, 都是以request和response为参数的方法(如doService方法), 而这个HandlerAdapter就是让固定的Servlet处理方法调用灵活的Handler来处理.</li>
</ul>
<p>另外View和ViewResolver的原理也和这个类似. View是用来展示数据的, 而ViewResolver用来查找View. View就像是模板, Model就是数据, ViewResolver就是使用哪个模板. </p>
<p>这一节doDispatch()内容有点多, &#x2F;&#x2F;TODO: 以后再补了直接上图: </p>
<p><img src="/picture/2020-11-09-17-07-08.jpg"></p>
<p>三个Servlet的处理过程大致如下: </p>
<ul>
<li><p>HttpServletBean: 没有参与实际请求的处理. </p>
</li>
<li><p>FrameworkServlet: 将不同类型的请求合并到了processRequest方法统一处理, processRequest主要做了: </p>
<ul>
<li>调用doService模板方法具体处理请求. </li>
<li>将LocaleContext和ServletRequestAttributes在请求前设置到了LocaleContextHolder和RequestContextHolder, 并在请求处理完成后恢复. </li>
<li>请求处理完后发布了ServletRequestHandledEvent事件.</li>
</ul>
</li>
<li><p>DispatcherServlet: doService方法给request设置了一些属性并将请求交给doDispatch方法具体处理.</p>
</li>
</ul>
<p>DispatcherServlet中的doDispatch方法完成了SpringMVC中请求处理过程的顶层设计, 它使用了DispatcherServlet中的九大组件完成了具体的请求处理. </p>
<h2 id="4-4-Spring-MVC组件"><a href="#4-4-Spring-MVC组件" class="headerlink" title="4.4 Spring MVC组件"></a>4.4 Spring MVC组件</h2><p>作者要跟我们讲讲DispatcherServlet中直接初始化的那9个组件啦. </p>
<h3 id="4-4-1-组件整体概览"><a href="#4-4-1-组件整体概览" class="headerlink" title="4.4.1 组件整体概览"></a>4.4.1 组件整体概览</h3><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>它只有一个getHandler()方法返回HandlerExecutionChain.<br>它的作用是根据request找到相应的处理器Handler和Interceptor.<br>查找Handler是按照顺序遍历所有的HandlerMapping, 当找到一个HandlerMapping后立即停止查找并返回.<br>在org.springframework.web.servlet.DispatcherServlet中, getHandler()会遍历所有的HandlerMapping, 当其中一个HandlerMapping返回了HandlerExecutionChain之后就直接返回. </p>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>它有三个方法: </p>
<ul>
<li>supports() 判断是否可以使用某个Handler</li>
<li>handle() 是用来具体使用Handler干活. </li>
<li>getLastModified() 是获取资源的LastModified, 资源最后一次修改时间</li>
</ul>
<p>在org.springframework.web.servlet.DispatcherServlet中, getHandlerAdapter()将遍历所有的HandlerAdapter, 找到一个support对应handler的Adapter就直接返回. </p>
<h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>其他工作的组件工作中可能出现问题, 那出现问题后咋办咧? 很明显我们需要一个专门的角色对异常情况进行处理. 在SpringMVC中这个角色就是HandlerExceptionResolver.<br>简单来说这个组件就是根据异常解析出ModelAndView, 然后再交给render方法进行渲染. 因为它在render之前工作的, 解析出ModelAndView之后render才去渲染, 所以它就不能处理render过程中的异常了. </p>
<p>&#x2F;&#x2F; TODO 懒了</p>
<h3 id="SpringMVC总结"><a href="#SpringMVC总结" class="headerlink" title="SpringMVC总结"></a>SpringMVC总结</h3><p>Spring MVC是Spring的Web MVC模式框架,它主要是围绕处理请求分发的DispatcherServlet来设计的.它的具体流程如图4所示.</p>
<p><img src="/picture/2021-03-01-23-18-17.jpg"><br>DispatcherServlet的处理工作流</p>
<p>Spring MVC的处理又和J2EE默认的分请求处理不一样,在这里它又用DispatcherServlet统一进行处理了,而请求如何进行处理又交给了doDispatch()方法来处理,其实就是调用各种相关的组件来各自处理.要解释各组件的处理流程,首先要分清楚三个概念.<br>1.Handler<br>Handler是处理器,它可以直接对应到MVC中的Controller层,它有很多种表现形式,可以是类也可以是方法,只要可以处理实际请求的就是Handler.比如项目中使用注解@RequestMapping标注的方法就是一个Handler.<br>2.HandlerMapping<br>HandlerMapping是处理器映射器的意思,它主要用来将请求映射到相应的Handler来处理.<br>3.HandlerAdapter<br>HandlerAdapter是处理器适配器,因为Handler可以是多种形式的因此十分灵活,但是Servlet处理请求的方法是固定的,因此需要有这个适配器来将灵活的Handler转换成能供Servlet调用的方式来处理.</p>
<p>同样View和ViewResolver的原理也和上面三个概念的抽象类似,View是用来展示数据的模板,Model是数据,ViewResolver是用来查找使用哪个View模板来渲染的.</p>
<p>因此DispatcherServlet的处理工作流程如下:<br>1.客户端向服务器发送请求(Incoming request).<br>2.请求被前端控制器(Front controller主要是DispatcherServlet)捕获,组件HandlerMapping根据URI(请求资源标识符)获得相关的Handler.<br>3.DispatcherServlet将使用适合的HandlerAdapter来处理获得的Handler.(如果成功获得HandlerAdapter那就会执行相应Interceptor的preHandle()方法)<br>4.HandlerAdapter使用Handler处理请求.(在此之前根据配置Spring会帮你做一些格外的工作,比如提取request作为Handler的入参,数据转换,数据格式化,数据验证等.处理完后执行相应Interceptor的postHandle()方法)<br>5.Controller(也就是Handler被)执行完之后返回一个model对象.<br>6.前端控制器根据返回的model对象和view来选择合适的视图解析器(ViewResolver).<br>7.视图解析器通过model来对响应(response)进行渲染.<br>8.前端控制器根据返回的渲染结果返回给客户端</p>
<h3 id="4-5-总结与补充"><a href="#4-5-总结与补充" class="headerlink" title="4.5 总结与补充"></a>4.5 总结与补充</h3><p>&#x2F;&#x2F; TODO 后面Servlet3.0提供了使用异步处理请求的内容. </p>
<p>参考: </p>
<ul>
<li>书籍: Spring技术内幕：深入解析Spring架</li>
<li>书籍: 看透Spring_MVC：源代码分析与实践</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/csujiangyu/article/details/53455094">AOP的实现的几种方式</a></li>
</ul>

            
        </div>
        
            

            <footer>
                
  
  <div class="tags">
    <a href="/tags/Note/">Note</a>, <a href="/tags/Java/">Java</a>, <a href="/tags/Spring/">Spring</a>
  </div>

            </footer>
        
    </div>
</article></div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <ul class="entry">
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
    <li><a href="/tags/Blog/">Blog</a><small>1</small></li>
    <li><a href="/tags/Book/">Book</a><small>2</small></li>
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
    <li><a href="/tags/Essay/">Essay</a><small>9</small></li>
    <li><a href="/tags/Game/">Game</a><small>2</small></li>
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
    <li><a href="/tags/Hexo/">Hexo</a><small>1</small></li>
    <li><a href="/tags/Java/">Java</a><small>5</small></li>
    <li><a href="/tags/Lifestyle/">Lifestyle</a><small>2</small></li>
    <li><a href="/tags/Maven/">Maven</a><small>1</small></li>
    <li><a href="/tags/MySQL/">MySQL</a><small>1</small></li>
    <li><a href="/tags/Network/">Network</a><small>2</small></li>
    <li><a href="/tags/Nginx/">Nginx</a><small>1</small></li>
    <li><a href="/tags/Note/">Note</a><small>7</small></li>
    <li><a href="/tags/Phone/">Phone</a><small>2</small></li>
    <li><a href="/tags/RFID/">RFID</a><small>2</small></li>
    <li><a href="/tags/Spring/">Spring</a><small>1</small></li>
    <li><a href="/tags/Virtual-Machine/">Virtual Machine</a><small>1</small></li>
    <li><a href="/tags/Win10/">Win10</a><small>5</small></li>
  </ul>
</div>


  <div class="widget footer">
  
  <span>&copy;2017-2025 SomeExp</span>
  
  </br>
  <span>Powered by <a target="_blank" rel="noopener" href="http://hexo.io" >Hexo</a></span>
  </br>
    <span>Theme by <a target="_blank" rel="noopener" href="https://github.com/thesomeexp/hexo-theme-light-simple" >hexo-theme-light-simple</a></span>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
</body>
</html>
