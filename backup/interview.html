<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>面试笔记 | SomeExp</title>
  <meta name="author" content="SomeExp">
  <meta name="description" content="SomeExp&#39;s Blog">
  <meta name="og:description" content="SomeExp&#39;s Blog">  
  <meta name="robots" content="noindex">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:image" content="/unicorn.jpg"/>
  <meta property="og:title" content="面试笔记"/>
  
  <meta property="og:site_name" content="SomeExp"/>
  <link rel="icon" href="/unicorn.jpg">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">SomeExp</a></h1>
</div>
<nav id="main-nav" class="alignright">
  <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/archives">Archives</a></li>
      <li><a href="/about">About</a></li>
      <li><a href="/links">Links</a></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="page">
    <div class="post-content">
        <header>
            
  
    <h1 class="title">面试笔记</h1>
  

            
        </header>
        <div class="entry">
            
                <p><a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a> 161k 疑似骗 star<br><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/">https://snailclimb.gitee.io/javaguide/#/</a> 131k<br><a target="_blank" rel="noopener" href="https://doocs.gitee.io/advanced-java/#/">https://doocs.gitee.io/advanced-java/#/</a> 68k<br><a target="_blank" rel="noopener" href="https://github.com/xingshaocheng/architect-awesome">https://github.com/xingshaocheng/architect-awesome</a> 57k<br><a target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily">https://github.com/AobingJava/JavaFamily</a> 32k<br><a target="_blank" rel="noopener" href="https://github.com/javagrowing/JGrowing/blob/master/JGrade.png">https://github.com/javagrowing/JGrowing/blob/master/JGrade.png</a> 4k<br><a target="_blank" rel="noopener" href="http://notfound9.github.io/interviewGuide/#/">http://notfound9.github.io/interviewGuide/#/</a> 4k<br><a target="_blank" rel="noopener" href="https://github.com/allentofight/easy-cs">https://github.com/allentofight/easy-cs</a> 1k<br><a target="_blank" rel="noopener" href="http://www.jayh.club/#/">http://www.jayh.club/#/</a> 1k<br><a target="_blank" rel="noopener" href="https://www.pdai.tech/">https://www.pdai.tech/</a> ?k<br><a target="_blank" rel="noopener" href="https://hadyang.com/interview/docs/basic/">https://hadyang.com/interview/docs/basic/</a> ?k<br><a target="_blank" rel="noopener" href="https://osjobs.net/topk/all/">https://osjobs.net/topk/all/</a> 算法 ?k</p>
<ol>
<li>Spring组件化思想: Service与Component有没有本质区别?</li>
<li>输入输出流的包装: 多次读取时有什么解决办法?</li>
<li>Http协议: 如何获取客户端浏览器的中域名?</li>
<li>序列化: 什么是序列化, 有没有碰到什么问题? </li>
<li>服务间通讯: 签名和认证方式如何处理?</li>
<li>线程池: 创建线程池最重要的参数有哪些? </li>
<li>创建线程时一般设置哪些属性?</li>
<li>Web会话&#x2F;登录用户的信息一般如何保存? 有什么好处?</li>
<li>JVM一般设置哪些启动参数?</li>
<li>GC算法: G1的混合GC是怎么回事?</li>
<li>内存配置: 内存溢出、内存泄漏、与并发量有什么关系?</li>
<li>并发: TPS、QPS、响应时间, 并发量, 有什么关系?</li>
<li>MySQL数据库的大表, 业务需要加字段, 你会考虑哪些问题? </li>
<li>Kafka或者MQ怎么保证顺序消费?</li>
<li>Redis与本地缓存的选择, 需要权衡考虑哪些维度?</li>
<li>Linux操作系统: 怎么看磁盘, 怎么看目录的总大小, 怎么看内存, 怎么看当前用户?</li>
<li>数据结构: HashMap的时间复杂度, Redis使用跳表有什么好处?</li>
<li>链路追踪与业务指标, 有什么使用经验或者技巧?</li>
<li>问题排查: 举一个工作中碰到过的,具体的排查案例。</li>
<li>系统拆分与架构设计方面有哪些值得分享的经验或技巧?</li>
</ol>
<p>面试问题</p>
<ul>
<li>工作时间和考勤? 雨天迟到怎么算?</li>
<li>公司内部是否会有考试?</li>
<li>部门加班情况和加班费怎么算?</li>
<li>公司有电脑还是自带电脑?</li>
<li>公司每月发薪日?</li>
</ul>
<p><strong>Java</strong><br>HashMap 红黑树原因: 可以利用链表对内存的使用率以及红黑树的高效检索, 是一种很有效率的结构. AVL 树是一种高度平衡的二叉树, 所以查找效率非常高, 但是为了维护这种高度平衡, 要付出更多的代价. (每次插入, 删除都要做调整)</p>
<p><strong>多线程线程池</strong></p>
<ul>
<li>newCachedThreadPool: 可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程.</li>
<li>newFixedThreadPool: 固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待.</li>
<li>newScheduledThreadPool: 周期性的线程池，支持定时及周期性执行任务.</li>
<li>newSingleThreadExecutor: 单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行.</li>
</ul>
<p>ThreadPoolExecutor 线程池, corePoolSize&#x3D;5, maximumPoolSize&#x3D;10, queueCapacity&#x3D;10, 有20个耗时任务交给这个线程池执行, 线程池会如何执行这20个任务?</p>
<ul>
<li>如果当前线程数&lt;corePoolSize, 则创建新线程执行该任务.</li>
<li>如果当前线程数&gt;&#x3D;corePoolSize, 则将任务存入队列.</li>
<li>如果阻塞队列已满, 且当前线程数&lt;maximumPoolSize, 则新建线程执行该任务.</li>
<li>如果阻塞队列已满, 且当前线程数&gt;&#x3D;maximumPoolSize, 则抛出异常.</li>
</ul>
<p><strong>AQS</strong> (AbstractQueuedSynchronizer) 是抽象队列同步器, 主要用来构建锁和同步器. ReentrantLock, Semaphore 都是基于 AQS 构造的. </p>
<p>AQS 核心思想: 如果请求的共享资源空闲, 就将请求资源的线程设为有效的工作线程, 并将共享资源设为锁定状态. 如果共享资源被占用, 那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制, 这个机制 AQS 是基于 CLH锁 (Craig, Landin, and Hagersten locks) 实现的.</p>
<p>CLH锁是对自旋锁的一种改进, 是一个虚拟的双向队列 (不存在队列实例, 仅存在结点之间的关联关系), 暂时获取不到锁的线程将被加入到该队列中.</p>
<p>JVM<br>Java内存区域(运行时数据区域)<br>线程私有: 程序计数器, 虚拟机栈, 本地方法栈<br>线程共享: 堆, 方法区, 直接内存(非运行时数据区的一部分)</p>
<p>Java1.8之后:<br><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png"></p>
<ul>
<li>程序计数器: 1.字节码解释器通过改变它来依次读取指令, 实现代码流程控制. 2. 多线程情况下, 用于记录线程执行位置.</li>
<li>虚拟机栈: 为虚拟机执行 Java 方法 (也就是字节码) 服务. 栈内存不允许动态扩展且栈深度超出最大深度时, 抛出 StackOverflow. 虚拟机在动态扩展栈时无法申请到足够的内存空间, 则抛出 OutOfMemoryError.</li>
<li>本地方法栈: 为虚拟机使用到的 Native 方法服务.</li>
<li>堆: 存放对象实例, 几乎所有对象实例以及数组都在这里分配内存. 随着 JIT 编译器 (Just-In-Time) 的发展与逃逸分析技术逐渐成熟, 栈上分配, 标量替换优化技术导致一些微妙的变化. 堆是垃圾收集器管理的主要区域, 因此也被称作 GC堆. 进一步划分堆的目的是更好地分配和回收内存.</li>
<li>方法区: 运行时数据区域的一块逻辑区域. 存储已被虚拟机加载的类信息, 字段信息, 方法信息, 常量, 静态变量, 即时编译器编译后的代码缓存等数据. 具体实现: 永久代&#x2F;元空间.</li>
</ul>
<p>对象的创建 (类分初设执)</p>
<ul>
<li><ol>
<li>类加载检查<br>虚拟机遇到 new 指令时, 检查是否能在常量池中定位到这个类的符号引用, 检查这个符号引用代表的类是否已被加载, 解析和初始化过. 如果没有则执行类加载过程.</li>
</ol>
</li>
<li><ol start="2">
<li>分配内存<br>从堆中为新对象分配内存. 分配方式有<strong>指针碰撞</strong>和<strong>空闲列表</strong>, 选分配方式由堆是否规整决定(就是垃圾收集器是否带有压缩整理功能决定, 标记-清除&#x2F;标记-整理).</li>
</ol>
<ul>
<li><p>指针碰撞: </p>
<ul>
<li>场合: 内存规整 (没有内存碎片)</li>
<li>原理: 用过的内存整合到一边，没有用过的内存放另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li><p>空闲列表</p>
<ul>
<li>场合: 内存不规整</li>
<li>原理: 虚拟机维护一个列表，该列表中记录哪些内存块是可用的，分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>该分配方式的 GC 收集器：CMS</li>
</ul>
<p>内存分配并发问题:<br>在实际开发过程中，创建对象是很频繁的事情, 必须确保线程安全:</p>
<ul>
<li>CAS + 失败重试: 虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>TLAB (Thread Local Allocation Buffer):  为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>初始化零值<br>虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
</ol>
</li>
<li><ol start="4">
<li>设置对象头<br>例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
</ol>
</li>
<li><ol start="5">
<li>执行 init 方法<br>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ol>
</li>
</ul>
<p>对象的内存布局<br>Hotspot虚拟机中, 可分为: 对象头, 实例数据, 对齐填充</p>
<ul>
<li>对象头: 一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针.</li>
<li>实例数据: 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</li>
<li>对齐填充: 仅仅起占位作用</li>
</ul>
<p>对象的访问定位<br>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>句柄</strong>、<strong>直接指针</strong>。</p>
<ul>
<li>句柄: Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。(在对象被移动时只会改变句柄中的实例数据指针)</li>
<li>直接指针: reference 中存储的直接就是对象的地址。(速度快，它节省了一次指针定位的时间开销。对象移动时需要修改 reference)</li>
</ul>
<p>堆空间基本结构:<br>新生代: Eden, S0, S1<br>老年代: Tenured<br>永久代: MetaSpace</p>
<p>死亡对象判断</p>
<ul>
<li>引用计数法<br>每当有一个地方引用它，计数器就+1, 引用失效计数器-1, 计数器为0时代表失效. (简单，效率高，但主流虚拟机没有选择这个算法，主要的原因是它很难解决对象之间相互循环引用的问题。)</li>
<li>可达性分析算法<br>基本思想是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</li>
</ul>
<p>引用类型</p>
<ul>
<li>强引用: 垃圾回收器绝不会回收. 内存空间不足时抛出 OOM.</li>
<li>软引用: 内存充足就不会回收, 内存不足就会回收. 可用来实现内存敏感的高速缓存.</li>
<li>弱引用: 比软引用拥有更短的生命周期. 垃圾回收器线程扫描到只具有弱引用的对象, 不管内存空间足够与否, 都会回收它的内存. 由于垃圾回收器是一个优先级很低的线程, 因此不一定会很快发现那些只具有弱引用的对象.</li>
<li>虚引用: 如果一个对象仅持有虚引用, 那么它就和没有任何引用一样, 在任何时候都有可能被垃圾回收. 虚引用主要用来跟踪对象被垃圾回收的活动.</li>
</ul>
<p>程序设计中很少使用弱引用与虚引用, 使用软引用较多, 因为软引用可以加速 JVM 堆垃圾内存的回收速度, 维护系统的运行安全, 防止内存溢出等问题的产生.</p>
<p>判断废弃常量<br>没有任何对象引用它, 那它就是废弃常量, 如果发生内存回收且有必要的话, 它就会被系统清出常量池了.</p>
<p>判断无用类</p>
<ul>
<li>该类所有实例都已经被回收.</li>
<li>加载该类的 ClassLoader 已经被回收.</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法.</li>
</ul>
<p>垃圾收集算法</p>
<ul>
<li>标记-清除: 首先标记出所有不需要回收的对象, 标记完成后统一回收掉所有没有被标记的对象. 存在问题:<ul>
<li>效率问题</li>
<li>空间问题 (产生大量不连续的碎片)</li>
</ul>
</li>
<li>标记-复制: 将内存分为大小相同的两块, 每次使用其中的一块. 一块的内存使用完后，将还存活的对象复制到另一块, 然后再把使用的空间清理掉.</li>
<li>标记-整理: 标记过程与“标记-清除”算法一样, 但后续步骤是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存.</li>
</ul>
<p>分代收集算法<br>根据对象存活周期的不同将内存分为几块.</p>
<ul>
<li>新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li>
<li>老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</li>
</ul>
<p>垃圾收集器<br>根据具体应用场景选择适合的垃圾收集器.</p>
<ul>
<li>Serial 收集器: 单线程, “Stop The World”. 新生代采用标记-复制算法，老年代采用标记-整理算法. 简单而高效. 适合 Client 模式下的虚拟机.</li>
<li>ParNew 收集器:  Serial 收集器的多线程版本. 新生代采用标记-复制算法，老年代采用标记-整理算法. Server 模式下的虚拟机的首选.</li>
<li>Parallel Scavenge 收集器: 吞吐量优先. 新生代采用标记-复制算法，老年代采用标记-整理算法. JDK1.8 默认收集器.</li>
<li>Serial Old 收集器: Serial 收集器的老年代版本. 一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</li>
<li>Parallel Old 收集器: Parallel Scavenge 收集器的老年代版本. 使用多线程和“标记-整理”算法。</li>
<li>CMS 收集器: 并发收集、低停顿. 以获取最短回收停顿时间为目标. 非常符合在注重用户体验的应用上使用. 第一次实现了让垃圾收集线程与用户线程（基本上）同时工作. 缺点:<ul>
<li>对 CPU 资源敏感.</li>
<li>无法处理浮动垃圾.</li>
<li>标记-清除 产生大量空间碎片.</li>
</ul>
</li>
<li>G1 收集器: 面向服务器的垃圾收集器,针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</li>
<li>ZGC 收集器: 与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，出现 Stop The World 的情况会更少.</li>
</ul>
<p>Minor GC 和 Full GC<br>Minor GC 是只收集新生代的 GC.<br>Full GC 就是收集整个堆, 包括新生代, 老年代, 永久代(1.8之后换为元空间)等收集所有部分的模式.</p>
<p>类加载过程<br>加载-&gt;连接-&gt;初始化<br>连接又分为: 验证-&gt;准备-&gt;解析</p>
<ul>
<li>加载: 将 class 文件加载到内存. 静态数据结构(.class .jar .war .jsp)转化成方法区中运行时的数据结构. 在堆中生成代表这个类的 Class 对象.</li>
<li>验证: 确保符合 JVM 规范和安全. </li>
<li>准备: 为静态变量在方法区中分配内存空间.</li>
<li>解析: 将常量池内的符号引用替换为直接引用.</li>
<li>初始化: 执行类静态资源初始化和非静态资源初始化的方法.</li>
<li>卸载: GC 将无用对象从内存中卸载.</li>
</ul>
<p>类加载器加载顺序<br>1.BootStrap ClassLoader: rt.jar<br>2.Extension ClassLoader: 加载扩展的 jar 包.<br>3.App ClassLoader: 指定的 classpath 下面的 jar 包.<br>4.Custom ClassLoader: 自定义的类加载器.</p>
<p>双亲委派模型<br>先判断是否被加载过, 已被加载的类会直接返回. 加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理. 隔离作用, 避免我们的代码影响到 JDK 的代码.</p>
<p><strong>JVM 问题排查</strong></p>
<ul>
<li>jmap 查看堆各个区域使用情况</li>
<li>jstack 查看线程和锁的使用情况</li>
<li>jstat 查看 full gc 发生次数以此判断是否需要调优</li>
</ul>
<p>Spring<br>Spring Bean 初始化</p>
<ul>
<li>实例化, 属性赋值(依赖注入), 初始化, 销毁</li>
<li>初始化相关: Aware 接口依赖注入, BeanPostProcessor 在初始化前后的处理, 以及 InitializingBean 和 init-method 的初始化操作.</li>
<li>销毁的具体操作, 有注册相关销毁回调接口, 最后通过 DisposableBean 和 destory-method 进行销毁.</li>
</ul>
<p>Spring 如何解决循环依赖问题<br>通过递归的方式获取目标bean及其所依赖的bean. 先实例化 Bean 再为其注入属性. (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84267654">https://zhuanlan.zhihu.com/p/84267654</a>)</p>
<p>Spring AOP 的了解<br>AOP (Aspect-Oriented Programming 面向切面编程) 能够将那些与业务无关, 被业务模块所共同调用的逻辑封装起来 (事务, 日志, 权限控制等), 便于减少系统的重复代码, 降低模块间的耦合度, 有利于维护和扩展. </p>
<p><strong>SpringBoot 中 bootstrap.yml 和 application.yml 的异同?</strong></p>
<ul>
<li><p>bootstrap.yml 先加载, application.yml 后加载.</p>
</li>
<li><p>bootstrap 是由 SpringCloud 配置上下文加载. application 由 SpringBoot 配置加载.</p>
</li>
<li><p>bootstrap 属性有高优先级. application 不会覆盖 bootstrap.</p>
</li>
<li><p>bootstrap 配置一些引导系统启动的参数, 一旦指定后不会变动. 如程序端口号, 配置中心地址等. application 应用级别的参数配置, 可能会根据业务需求做动态配置. 如日志级别, 一些开关参数等.</p>
</li>
<li><p>bootstrap.yml 和 applicaiton.yml 在同一目录下.</p>
</li>
</ul>
<p>假如配置文件中有相同的配置，后加载的配置会覆盖先加载的配置，所以如果使用Nacos配置中心的话，nacos上的配置的优先级会比较高。</p>
<p>OSI 七层模型</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</p>
<p>TCP&#x2F;IP 四层模型</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ul>
<p>TCP 与 UDP 区别</p>
<ul>
<li>是否面向连接: TCP 在传输数据前必须先建立连接, 结束后要释放连接. UDP 不需要先建立连接.</li>
<li>是否可靠传输: TCP 提供可靠传输, 在传输前通过三次握手来建立连接, 有确认、窗口、重传、拥塞控制机制. 主机收到 UDP 报文后, 不需要给出确认, 不保证数据不丢失, 不保证是否顺序到达. </li>
<li>是否有状态: TCP 会记录发出去消息的状态, 是否发送, 是否被接收了等等. UDP 是无状态服务, 就是发出去之后不管.</li>
<li>传输效率: TCP 比 UDP 多了连接, 确认, 重传等机制, 所以效率比 UDP 低.</li>
<li>传输形式: TCP 面向字节流, UDP 是面向报文的.</li>
<li>首部开销: TCP 首部开销 (20~60字节)比UDP首部开销(8字节)大.</li>
<li>是否提供广播或多播: TCP 只支持点对点通信, UDP 支持一对一, 一对多, 多对一, 多对多.</li>
</ul>
<p>什么时候选择 TCP, UDP?</p>
<ul>
<li>TCP 用于对传输准确性要求特别高的场景, 比如文件传输, 发送和接收邮件, 远程登陆等.</li>
<li>UDP 一般用于即时通信, 比如: 语音, 视频, 直播等等. 这些场景对数据传输的准确性要求不是特别高, 即使丢一两帧, 给人的感觉区别不大.</li>
</ul>
<p>三次握手:</p>
<ul>
<li>一次握手:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；</li>
<li>二次握手:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态;</li>
<li>三次握手:客户端发送带有带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成TCP三次握手。</li>
</ul>
<p>为什么要三次握手?<br>三次握手的目的是建立可靠的通信信道，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第2次握手传回了ACK，为什么还要传回SYN？<br>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<p>四次挥手</p>
<ul>
<li>第一次挥手 ：客户端发送一个 FIN（SEQ&#x3D;X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。</li>
<li>第二次挥手 ：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。</li>
<li>第三次挥手 ：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入LAST-ACK状态。</li>
<li>第四次挥手 ：客户端发送 ACK (SEQ&#x3D;y+1)标志的数据包-&gt;服务端并且进入TIME-WAIT状态，服务端在收到 ACK (SEQ&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ul>
<p>为什么要四次挥手?<br>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？<br>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<p>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？<br>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<p>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？<br>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<p><strong>超时重传</strong><br>重传机制的一种方式, 发送数据时设定一个定时器, 超过指定时间没有收到 ACK 就会重发该数据.</p>
<p><strong>RTT</strong> (Round-Trip Time 往返时延)<br>是数据从网络一端传送到另一端所需的时间, 就是包的往返时间.</p>
<p><strong>RTO</strong> (Retransmission Timeout 超时重传时间)</p>
<ul>
<li>较大的 RTO 重发慢, 没有效率, 性能差.</li>
<li>较小的 RTO 重发快, 增加网络拥塞, 导致更多的超时和重发.<br>超时重传时间 RTO 应该略大于报文往返 RTT 的值. (根据网络情况动态变化的值)</li>
</ul>
<p><strong>快速重传</strong> (Fast Retransmit)<br>当收到三个相同的 ACK 报文时, 会在定时器过期之前, 重传丢失的包. 是以数据驱动重传. </p>
<ul>
<li>重传部分: SACK (Selective Acknowledgment 选择性确认). TCP 头部添加 SACK 字段, 缓存一些信息, 就可以实现只重传丢失的数据. D-SACK (Duplicate SACK): 使用 SACK 来告诉发送方有哪些数据被重复接收了.</li>
<li>重传所有</li>
</ul>
<p><strong>滑动窗口</strong><br>无需等待确认应答, 而可以继续发送的最大值.</p>
<p><strong>接收方决定窗口大小</strong><br>TCP 头部里有一个 Window 字段, 就是窗口大小. 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据. 于是发送端就可以根据这个接收端的处理能力来发送数据, 而不会导致接收端处理不过来.</p>
<p><strong>操作系统缓冲区与滑动窗口的关系</strong><br>TCP 不允许同时减少缓存又收缩窗口, 而是采用先收缩窗口, 再减少缓存, 从而避免丢包.</p>
<p><strong>窗口关闭</strong><br>窗口关闭可能会导致潜在的死锁. 解决:<br>收到零窗口通知的一方启动计时器, 计时器超时就发送窗口探测报文.</p>
<p><strong>糊涂窗口综合症</strong><br>因为 TCP 报文开销并不小, 如果数据量较小也继续发包就不够经济实惠. 解决:</p>
<ul>
<li>让接收方不通告小窗口给发送方. (当窗口大小小于一定值时, 直接通告发送方窗口为0)</li>
<li>让发送方避免发送小数据.</li>
</ul>
<p><strong>避免发送方发送小数据</strong><br>通常使用 Nagle 算法, 该算法思路是延时处理, 满足一下两条件之一才能发:</p>
<ul>
<li>要等到窗口大小 &gt;&#x3D; MSS 或是 数据大小 &gt;&#x3D; MSS.</li>
<li>收到之前发送数据的 ack 回包.</li>
</ul>
<p><strong>拥塞控制</strong><br>流量控制是避免发送方填满接收方的缓存, 但是并不知道网络中发生了什么.<br>当网络发送拥塞时, TCP 会自我牺牲, 降低发送的数据量.<br>拥塞控制目的是避免发送方的数据填满整个网络. 在发送方定义了一个拥塞窗口.</p>
<p><strong>发送窗口是拥塞窗口和接受窗口中的最小值</strong><br>拥塞窗口会根据网络的拥塞程度动态变化.</p>
<p><strong>发生了超时重传, 就认为出现了拥塞</strong><br>发送方没在规定时间内收到 ack 应答报文, 发生了超时重传, 就会认为出现了拥塞.</p>
<p><strong>拥塞控制算法: 慢启动, 拥塞避免, 拥塞发生, 快速恢复</strong><br>主要是这四个算法.</p>
<p><strong>慢启动: 发送方每收到一个 ack, 拥塞窗口的大小就会加一</strong><br>慢启动算法发包个数指数性增长.</p>
<p><strong>当大于慢启动门限时就会使用 拥塞避免算法</strong><br>慢启动门限 ssthresh (slow start threshold) .</p>
<p><strong>拥塞避免算法是一种线性增长的算法</strong><br>规则是每收到一个 ACK 时，拥塞窗口 增加 1&#x2F;拥塞窗口.</p>
<p><strong>增长到拥塞, 出现丢包, 当触发重传, 就进入拥塞发生算法</strong><br>重传机制:</p>
<ul>
<li>超时重传: 慢启动门限减半, 拥塞窗口重置为1. (激进, 反映强烈, 会造成网络卡顿)</li>
<li>快速重传: 门限为当前拥塞窗口值, 拥塞窗口变为一半, 然后进入快速恢复算法.</li>
</ul>
<p><strong>快速恢复将维持回原来比较高的值, 后续呈线性增长</strong><br>参考: <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14888059/3790683">https://blog.51cto.com/u_14888059&#x2F;3790683</a></p>
<p>MySQL<br>MySQL 为什么用 B+树?</p>
<ul>
<li>哈希虽然能提供 O(1) 的单数据行性能, 但对范围和排序无法很好的支持.</li>
<li>B 树能够在非叶子结点中存储数据, 查询连续数据时可能带来更多的随机 I&#x2F;O.</li>
<li>而 B+ 树叶子节点可以通过指针相互连接, 能够减少顺序遍历时产生的额外随机 I&#x2F;O.</li>
</ul>
<p>binlog (二进制日志)<br>逻辑日志，记录内容是语句的原始逻辑. 记录所有 DDL(Data Definition Language) 和 DML(Data Manipulation Language) 语句. 主要两个作用:</p>
<ul>
<li>数据恢复: 数据操作出问题&#x2F;数据库宕机数据丢失, 可以根据 binlog 来回放历史数据.</li>
<li>主从数据: 多机备份业务, 可以监听写库的 Binlog 日志, 同步写库的所有更改.</li>
</ul>
<p>redo log (事务日志)<br>是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</p>
<p>undo log (回滚日志)</p>
<p>两阶段提交:<br>写入数据后, InnoDB 把数据保存在内存中, 同时记录 redo log, redo log 进入 prepare 状态, 然后告诉执行器执行完成了. 执行器收到通知后记录 binlog, 然后调用引擎接口, 提交 redo log 为提交状态.</p>
<p>两阶段提交的异常重启:</p>
<ul>
<li>判断 redo log 是否完整, 如果完整则立即提交.</li>
<li>如果 redo log 是预提交, 判断 binlog 是否完整, 完整就提交, 不完整则回滚事务.</li>
</ul>
<p><strong>MySQL 深分页 limit 优化:</strong></p>
<ul>
<li>以 last_* 作为查询条件, 使用浅分页: 没有页码的应用场景.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id, name ...</span><br><span class="line">from t</span><br><span class="line">where id &gt; #&#123;last_id&#125;,create_time &gt; #&#123;last_create_time&#125;</span><br><span class="line">order by create_time desc</span><br><span class="line">limit 0, 20;</span><br></pre></td></tr></table></figure></li>
<li>连表子查询, 先查询 id 再通过 in 查详情:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT   </span><br><span class="line">    id, m_id, NAME, identity_no, address, create_time, modify_time </span><br><span class="line">FROM t2</span><br><span class="line">JOIN ( SELECT id FROM t2 ORDER BY create_time desc LIMIT 1000000, 20 ) x USING ( id );</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>MySQL 分库分表</strong><br>分表策略:</p>
<ul>
<li>range 范围: 比如根据 id, 0到300万一张表, 300万到600万一场表.</li>
<li>hash 取模: 指定 key 取模, 数据分到不同的表中.</li>
<li>一致性哈希: 在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。解决分布式哈希中的动态伸缩问题.</li>
</ul>
<p>Redis<br>5种基本数据结构</p>
<ul>
<li>String (字符串): 场景: 缓存 token, 图片地址, 序列化后的对象.</li>
<li>List (列表): 实现为双向链表. 场景: 最新文章, 最新动态.</li>
<li>Set (集合): 无序集合. 轻易实现交集, 并集, 差集操作. 场景: 1. 存放数据不能重复的场景, 网站 UV 统计(数量巨大就用 HyperLogLog). 共同好友. 2. 需要随机获取数据源中的元素的场景, 抽奖.</li>
<li>Sorted Set (有序集合): 比 Set 多了 score 权重参数. 场景: 1. 需要随机获取数据源中的元素根据某个权重进行排序, 排行榜. 2. 需要存储的数据有优先级或者重要程度的场景, 优先级任务队列.</li>
<li>Hash (哈希): String 类型的键值对. 场景: 对象数据存储(用户信息、商品信息、文章信息、购物车信息. )</li>
<li>HyperLogLogs (基数统计): 场景: 数量量巨大（百万、千万级别以上）的计数场景, 热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计.</li>
<li>Bitmap (位存储): 只需要一个 bit 位来表示某个元素对应的值或者状态. 场景(0&#x2F;1即可表示): 用户签到情况, 用户行为统计(点赞过某个视频).</li>
<li>Geospatial (地理位置): 底层也是 GeoHash. 场景: 附近的人.</li>
</ul>
<p><strong>跳表</strong> (skiplist)<br>由多层链表组成, 通过先比较上一层的大小, 可以很快找到该值在下一层的区间范围. 时间复杂度 log(n).<br><img src="/picture/interview-Skip_list_add.gif" alt="skiplist"><br>跳表比B+树层级更高，需要更多的磁盘I&#x2F;O. 但 Redis 是基于内存的数据库, 不用考虑磁盘 I&#x2F;O 影响性能问题.</p>
<p><strong>压缩列表</strong> (ziplist)<br>本质上就是一个字节数组，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素.<br><img src="/picture/interview-ziplist.png" alt="ziplist"><br>存储空间连续结构在数据量小时可以有效节省空间, 但数据量比较多, 修改元素时, 必须重新分配存储空间, 会影响执行效率.</p>
<p><strong>quicklist</strong><br>是 LinkedList 和 ziplist 的混合. 将 LinkedList 按段切分, 每一段使用 ziplist 存储. 多个 ziplist 使用双向指针串联器来.<br><img src="/picture/interview-quicklist.webp" alt="quicklist"></p>
<p>内存淘汰机制<br>Redis 提供 6 种数据淘汰策略:</p>
<ol>
<li>volatile-lru (least recently used): 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰.</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰. </li>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰. </li>
<li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）.</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰. </li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<p>4.0版本后增加了:<br>7. volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰.<br>8. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key.</p>
<p>持久化机制</p>
<ol>
<li>快照（snapshotting，RDB）<br>将 Redis 某一时刻的数据持久化到磁盘中. 是一种快照式的持久化方案. RDB 是一个非常紧凑(有压缩)的文件. 适合备份, 远程传输. 通常用于主从, 提高 Redis 性能, 还可以留在本地重启时使用.<br>Redis 提供了两个命令来生成 RDB 快照文件：</li>
</ol>
<ul>
<li>save : 主线程执行，会阻塞主线程；</li>
<li>bgsave : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
<p>RDB 缺点: </p>
<ul>
<li>基于时间间隔的, 可能存在一定程度的数据丢失. </li>
<li>子进程占用和主进程相同的内存空间, 可能导致内存不足.</li>
</ul>
<ol start="2">
<li>只追加文件（append-only file, AOF）<br>AOF 方式是将执行过的写指令记录下来, 在数据恢复时按照从前到后的顺序再将指令都执行一遍. 比快照式实时性更好.<br>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。<br>三种不同的AOF持久化方式:</li>
</ol>
<ul>
<li>always: 每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</li>
<li>everysec: 每秒钟同步一次，显式地将多个写命令同步到硬盘</li>
<li>no: 让操作系统决定何时进行同步</li>
</ul>
<p>AOF 缺点: </p>
<ul>
<li>较大的存储空间: 与 RDB 相比, AOF 文件通常较大, 占用较多磁盘空间.</li>
<li>数据加载速度慢: 由于需要重放 AOF 文件中的命令, 恢复速度相对较慢.</li>
</ul>
<ol start="3">
<li>混合持久化 (RDB + AOF)<br>Redis 首先使用 RDB 持久化将内存中的数据快照存储到磁盘上, 然后再使用 AOF 持久化将所有新的写操作追加到 AOF 文件中.</li>
</ol>
<ul>
<li>在系统崩溃时, 可以通过 RDB 文件快速恢复, 而 AOF 文件可以用于恢复最近的修改.</li>
<li>RDB 持久化可以减少 AOF 文件的大小, 从而减少磁盘空间的使用.</li>
<li>在 RDB 持久化中, Redis 可以使用子进程来将快照写入磁盘, 这样可以避免主进程的阻塞.</li>
</ul>
<p>缺点:<br>较大的存储空间, 需要同时维护 RDB 文件和 AOF 文件, 可能占用较多的磁盘空间.</p>
<p><strong>什么是深拷贝和浅拷贝? JavaScript 对象如何进行深拷贝?</strong><br>浅拷贝只是增加了一个指针指向已存在的内存. 深拷贝就是增加一个指针并且申请一个新的内存, 使这个增加的指针指向这个新的内存.<br>JSON.parse( JSON.stringify() )<br>先将需要拷贝的对象进行 JSON 字符串化, 然后再 parse 解析出来.</p>
<p><strong>现有一张用户表user(id ,name …. )，存在除ID外大量相同的记录，请写一条SQL删除重复记录</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line"><span class="keyword">where</span> exist(</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">MAX</span>(id) id, name</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">user</span> </span><br><span class="line">  groud <span class="keyword">by</span> name</span><br><span class="line">  <span class="keyword">having</span> <span class="built_in">count</span>(<span class="number">1</span>)<span class="operator">&gt;</span><span class="number">1</span>) T</span><br><span class="line">  <span class="keyword">where</span> user.name <span class="operator">=</span> T.name</span><br><span class="line">  <span class="keyword">and</span> user.id <span class="operator">&lt;</span> T.id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>什么是 SQL 注入? 如何防止?</strong><br>SQL注入是一种常见的Web应用安全漏洞，可以通过在SQL语句中插入恶意代码来破坏数据库的完整性。</p>
<ul>
<li>对数据进行有效性检查, 如限制字符集, 长度以及格式.</li>
<li>使用预处理语句或存储过程.</li>
<li>使用参数化查询, 避免直接在 SQL 语句中拼接用户输入的数据.</li>
<li>限制对数据库的访问权限, 只允许必要的操作.</li>
<li>定期执行安全审计和监测, 以及对发现的漏洞进行及时修复.</li>
</ul>
<p><strong>MQ 重复消费, 消息幂等</strong></p>
<ul>
<li>改造业务, 使得重复消费时不影响最终结果: version 版本号控制.</li>
<li>基于数据库唯一主键进行约束, 消费完向数据库 insert, 如果重复消费就会主键冲突.</li>
<li>通过记录关键 key, 重复消息过来时, 先判断 key 是否被处理过.</li>
</ul>
<p><strong>MQ 如何保证消息不丢失, 进行可靠传输?</strong></p>
<ul>
<li>RabbitMQ提供事务机制（transaction）和确认机制（confirm）两种模式来确保生产者不丢消息.</li>
<li>通过开启持久化磁盘来确保消息队列不会丢数据.</li>
<li>采用手动确认代替自动确认, 确保处理完后再发送确认. 确保消费者不丢消息.</li>
</ul>
<p><strong>文章类</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification JVM 虚拟机规范 (oracle)</a><br><a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide 面试 (javaguide)</a></p>
<p><strong>问答类</strong></p>
<p><a target="_blank" rel="noopener" href="https://ayase.moe/2021/03/09/customized-git-config/">Git IncludeIf (ayase)</a><br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/">Java Concurrency  yield, sleep, join Methods (geeksforgeeks)</a><br><a target="_blank" rel="noopener" href="https://jodiejackson.com/">jodiejackson</a><br><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-wait-notify">wait and notify() Methods in Java (baeldung)</a><br>[wait, notify, await, signal (Java并发编程实战)]Condition 对象中, 与 wait, notify, notifyAll 方法对应的分别是 await, signal, signalAll. 但是, Condition 对 Object 进行了扩展, 因而它也包含 wait 和 notify 方法. 一定要确保使用正确的版本, await 和 signal.</p>

            
        </div>
        
            

            <footer>
                
            </footer>
        
    </div>
</article></div></div>
    <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <ul class="entry">
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
    <li><a href="/tags/Blog/">Blog</a><small>1</small></li>
    <li><a href="/tags/Book/">Book</a><small>2</small></li>
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
    <li><a href="/tags/Essay/">Essay</a><small>9</small></li>
    <li><a href="/tags/Game/">Game</a><small>2</small></li>
    <li><a href="/tags/Git/">Git</a><small>1</small></li>
    <li><a href="/tags/Hexo/">Hexo</a><small>1</small></li>
    <li><a href="/tags/Java/">Java</a><small>5</small></li>
    <li><a href="/tags/Lifestyle/">Lifestyle</a><small>2</small></li>
    <li><a href="/tags/Maven/">Maven</a><small>1</small></li>
    <li><a href="/tags/MySQL/">MySQL</a><small>1</small></li>
    <li><a href="/tags/Network/">Network</a><small>2</small></li>
    <li><a href="/tags/Nginx/">Nginx</a><small>1</small></li>
    <li><a href="/tags/Note/">Note</a><small>7</small></li>
    <li><a href="/tags/Phone/">Phone</a><small>2</small></li>
    <li><a href="/tags/RFID/">RFID</a><small>2</small></li>
    <li><a href="/tags/Spring/">Spring</a><small>1</small></li>
    <li><a href="/tags/Virtual-Machine/">Virtual Machine</a><small>1</small></li>
    <li><a href="/tags/Win10/">Win10</a><small>5</small></li>
  </ul>
</div>


  <div class="widget footer">
  
  <span>&copy;2017-2024 SomeExp</span>
  
  </br>
  <span>Powered by <a target="_blank" rel="noopener" href="http://hexo.io" >Hexo</a></span>
  </br>
    <span>Theme by <a target="_blank" rel="noopener" href="https://github.com/thesomeexp/hexo-theme-light-simple" >hexo-theme-light-simple</a></span>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
</body>
</html>
