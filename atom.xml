<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SomeExp</title>
  
  
  <link href="https://someexp.com/atom.xml" rel="self"/>
  
  <link href="https://someexp.com/"/>
  <updated>2025-03-21T16:00:00.000Z</updated>
  <id>https://someexp.com/</id>
  
  <author>
    <name>SomeExp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stevens-Johnson 综合征自救指南</title>
    <link href="https://someexp.com/2025/stevens-johnson-syndrome-self-rescue-guide/"/>
    <id>https://someexp.com/2025/stevens-johnson-syndrome-self-rescue-guide/</id>
    <published>2025-03-21T16:00:00.000Z</published>
    <updated>2025-03-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录每位热心病友的经验分享.</p><span id="more"></span><script>  window.location.href = "/sjs";</script>]]></content>
    
    
    <summary type="html">记录每位热心病友的经验分享.</summary>
    
    
    
    
    <category term="Guide" scheme="https://someexp.com/tags/Guide/"/>
    
  </entry>
  
  <entry>
    <title>2024年年度碎碎念</title>
    <link href="https://someexp.com/2024/annual-summary/"/>
    <id>https://someexp.com/2024/annual-summary/</id>
    <published>2024-12-25T16:00:00.000Z</published>
    <updated>2024-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>What doesn’t kill you makes you stronger.</p><span id="more"></span><p><strong>区分主观感受和客观事实.</strong></p><p><strong>让自己过得更好, 就是让世界过得更好.</strong> （类似于看不见的手)</p><p><strong>孤独的解药是独处.</strong></p><p><strong>认识到社会资源分配的不平等, 承认个人能力有限. 可以利用有限的资源, 创造最大的价值.</strong></p><p><strong>可以多关注自己可以掌控的东西.</strong></p><p><strong>主要取决于你看待事情的方式.</strong></p><p><strong>破财消灾, 应该有解决的办法.</strong></p><p><strong>我们活在一个信息越来越多, 意义越来越少的社会里.</strong></p><p><strong>你怎么看待世界, 世界就是怎么样的.</strong></p><p><strong>承认偏见.</strong></p><p><strong>你不是你, 你只是活在这个时代.</strong></p><p><strong>请关注自己的感受, 如果能让你感到好点, 可以去做.</strong></p><p><strong>人的精力有限, 你想过一种怎么样的生活? (简化 与 美)</strong></p><p><strong>追求进步而不是完美.</strong></p><p><strong>希望你自由地活着，永远在看花的路上.</strong></p>]]></content>
    
    
    <summary type="html">What doesn&#39;t kill you makes you stronger.</summary>
    
    
    
    
    <category term="Essay" scheme="https://someexp.com/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢的游戏</title>
    <link href="https://someexp.com/2024/favorite-games/"/>
    <id>https://someexp.com/2024/favorite-games/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2024-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>游戏推荐榜.</p><span id="more"></span><p><strong>2024</strong></p><p><strong>夜族崛起</strong> (多人)<br>头目设计和动作角色扮演要素战斗十分出色. 建议自建服务器游玩以加快游戏节奏.</p><p><strong>木筏求生(Raft)</strong> (多人)<br>一款带着家到处探险的生存游戏. </p><p><strong>格兰蒂亚秘闻</strong><br>季节地图和时间谜题设计出色, 非常完整的像素ARPG游戏. 虽然毫无操作手感可言.</p><p><strong>护核纪元</strong> (多人)<br>像素游戏缝合.</p><p><strong>哈迪斯2</strong><br>节奏手感都不错的俯视角肉鸽.</p><p><strong>超级马力欧兄弟 惊奇</strong><br>可爱画风, 合作合家欢.</p><p><strong>极品飞车系列21&#x2F;22</strong><br>经典.</p><p><strong>地痞街区</strong> (多人)<br>2D像素, 各种美式黑色幽默, 可惜游戏内容有限.</p><p><strong>塞尔达旷野之息</strong><br>会对自由度感到惊艳, 整体画风配音感觉舒适. 后期就会闷一点.</p><p><strong>二之国2 亡灵王国</strong><br>吉卜力风格, 围绕国家建设的 JRPG. 虽然剧情老派, 闪避迟钝.</p><p><strong>对马岛之魂</strong><br>优秀的调色.</p><p><strong>星露谷物语</strong><br>像素农牧场游戏, 不用多说.</p><p><strong>GTA V</strong><br>虽然任务重复, UI交互老旧.</p><p><strong>Apex Legends</strong><br>没游戏玩时就在这坐牢.</p><p><strong>Before 2024:</strong></p><p><strong>上古卷轴5:天际</strong></p><p><strong>其它:</strong></p><p>多人同屏游戏<br>Moving Out<br>Unrailed Epic<br>Cuphead<br>Gang beasts<br>Ultimate Chicken Horse<br>Broforce<br>HELLDIVERS<br>Magicka 2: Gates of Midgård<br>Tricky Towers</p><p>双人<br>A Way Out<br>It Takes Two<br>Unravel Two</p><p>如果遗老们想要找回以前老游戏的感觉, 不应该指望新游戏往回走, 去复刻老游戏, 而是应该直接去玩老游戏. 老游戏依然有它的光芒, 都是时代的选择, 没有好坏. </p>]]></content>
    
    
    <summary type="html">游戏推荐榜.</summary>
    
    
    
    
    <category term="Game" scheme="https://someexp.com/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>对中国人寿保险公司拒赔感到羞耻</title>
    <link href="https://someexp.com/2024/shame-on-china-life-insurance-company/"/>
    <id>https://someexp.com/2024/shame-on-china-life-insurance-company/</id>
    <published>2024-11-28T16:00:00.000Z</published>
    <updated>2024-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下生病住院了, 人寿保险公司拒赔相关事宜.</p><span id="more"></span><p>今年8月份的时候我因为生病在 南方医科大学皮肤病医院 住院了, 确诊 Steven Johnson 综合征, 因病情比较严重, 医生说要用丙球, 但是医生说医院药房没有这个药了, 所以走了外购买了 27瓶 静注人免疫球蛋白(pH4). 在院治疗了7天后出院.</p><p>因为今年年初 (2024年01月21号) 的时候我有购买 中国人寿保险 的  国寿如E康悦百万医疗保险(盛典版), 于是在出院后在<a href="https://i.imgur.com/SLqzXyo.png">服务经理</a>的帮助下收集和整理了住院期间产生的医疗费用发票和病案, 在8月28号向该保险公司提交了理赔申请, 后面收到理赔核定书, 于9月18号结案.</p><p>在医疗保险理赔个人通知书内明细显示, 8月6号的住院医疗票据金额 9114.63元, 扣减掉社保统筹 5161.52元, 因为有1万元以内的免赔额, 赔付金额合计 0元. 而外购的 静注人免疫球蛋白(pH4) 共 23529.32元 并没有赔付.</p><p>我原以为事情就这样结束了, 后续在小红书上有一位一样疾病的病友找我联系, 说是他在北京的医院住院就诊, 也是使用丙球, 因为北京的医院药房有药, 虽然这个药物也是不走医保, 但是医院能给他开出这个发票, 也就是算在了住院费用里, 后续他找他买的友邦医疗保险报销, 保险公司全额给他赔付了. 于是我在10月25号打 95519 向中国人寿保险公司反映这件事情, 后续并没有收到回复.</p><p>过了许久, 晚上我刚好刷到医保DGR相关的内容, 然后又觉得保险公司给我的赔付结果不合理, 以为这和医保有关于是在<a href="https://v2ex.com/t/1090550">v2ex</a>发帖吐槽(因为原帖已在v2ex水深火热区无法访问, 我<a href="/backup/unfairness-of-medical-insurance">补了个原帖</a>). 收到热心网友回复相关的案例: <a href="http://js.news.cn/20240408/08d939c8f42241fda422a1366849a9dc/c.html">院外购药，保险公司能不能赔？(新华网江苏频道)</a>, <a href="https://www.21jingji.com/article/20231012/herald/8af3ff43e97faaba30c5e4597b81d333.html">外购药是否属于保险理赔的范围？(21经济网)</a>, <a href="http://qzr.cn/sys/119429.html">医疗险拒赔院外购买、非清单内药品，是否合理？(圈中人 保险专业网)</a></p><p>根据热心网友的回帖帮助, 我在11月22号挂了原医生的号去了医院, 想着让医生开具原开药处方, 但是医生说门诊系统和住院系统是两套系统, 没有办法给我开具当时的处方, 然后让我找医务科. 去了医务科医务科的医生说我的病案里面的医嘱里已经有写什么时间段用了什么药, 是可以作为医院开具药物并使用的证明. 于是我向中国人寿保险公司打电话反映了此事.</p><p>11月24号我收到服务经理给我发来的消息, 依然说是 “医药公司的购药发票不予赔付”. 服务经理给我发来她与保险客服相关的截图, 显示 <a href="https://i.imgur.com/ynQtywE.jpeg">“那医院能不能开具证明没有这个药呢?”</a>. 我继续询问她有跟医生的谈话录音, 证明要怎么开? 有没有模板? 是不是有证明就一定可以赔付? 销售人员就留了一句语音 <a href="https://i.imgur.com/IBYNbGH.png">“我再问一下他，问清楚了回复。”</a>. 一直到12月2日(星期一), 都没有任何回复.</p><p>我在11月25号, 11月26号, 相继拨打过保险公司电话反映, 最后保险公司那边回电解释理赔结果是按合同走的, 依然是拒赔, 并说没有其它方案.</p><p>我看了一下保险合同里面的责任免除条款, 其中有 “未经医生处方自行购买的药品”, “非医院药房购买的药品” 都在责任免除内有写.</p><p>我在小红书上刷到有网友说打 12378 投诉保险后问题得到了解决.</p><p>于是我11月26号, 11月27号, 11月28号, 每天都有打过去投诉并反映我的诉求, 但客服都是只传达到对应保险的客服, 依然也是没能解决我的问题. </p><p>今天11月29号, 保险客服给我来电也是说都是以按合同走的, 以及10日内答复给我一种拖延时间的感觉. 然后我打 12378 再也打不通了, 都是嘟嘟嘟嘟说忙碌就没了.</p><p>总结下来无论是打中国人寿保险的客服电话投诉, 还是打 12378, 目前都没有提供方案解决我这一个问题.</p><p>接下来我感觉我还是得去一趟医院让医生开出原处方, 无论后续保险公司是否会给我提供方案, 还是非得要我走诉讼要用上.</p><p>因为博客并没有评论功能, 如果你想对本文做评论欢迎移步: <a href="https://www.zhihu.com/question/5485170167">知乎</a>, <a href="https://v2ex.com/t/1093769">v2ex</a> 或 <a href="https://bsky.app/profile/someexp.bsky.social/post/3lc36td4x6k2t">Bluesky</a>. </p><p>——— 原帖后续 ———</p><p>11月30日我再次返回医院, 找医生开了当时的处方, 并将发票照片发给服务经理联系保险公司. 但是收到的回复还是<a href="https://i.imgur.com/1mCDdYn.png">要我开什么医药证明</a>(也就是11月24号当时的聊天截图), 根据服务经理的截图回复显示, <a href="https://i.imgur.com/aF73v46.jpeg">“客户给的是处方的图片, 应该是从医院拿药的啊”, “你有没有跟客户说清楚要定点医院开的发票才能报销”</a>. 依然是没有给我赔付.</p><p>12月4日, 我再次打 12378 向专员说明了我提供了处方保险公司依然不赔付的事情, 也转接中国人寿相关的客服说明了此事, 客服说1天内会有专员回电我更进. 同日我收到专员的回电, 说会继续反馈处理然后再给我答复.</p><p>12月14日, 中国人寿相关人员联系我线下走协议赔付, 网上搜 协议赔付 一般是和保险公司协商好金额, 觉得协商的金额可以接受就可以签字(一般是权衡你诉讼能胜诉的金额和赔付金额), 然后该理赔就算完结. (这里要注意的是签协议自己也要保留一份有盖保险公司章的协议, 拍照也行)</p><p>协议约定在给定时间内支付赔款, 但是过了约定时间对方还没赔付, 律师说一般都会给的, 叫我多等一会不着急. 但我就一直催他们… 最后还是等了超出协议约定时间内快一个月才收到钱… </p><p><strong>Q&amp;A:</strong><br><strong>为什么这个拒赔案子看起来合理, 但是又不合理?</strong><br>这个案子的关键点在于购药发票是否是医院的, 而只有好的医院药房才有药, 是不是意味着有些人的命天生就不值钱?</p>]]></content>
    
    
    <summary type="html">记录一下生病住院了, 人寿保险公司拒赔相关事宜.</summary>
    
    
    
    
    <category term="Essay" scheme="https://someexp.com/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>选购推荐清单</title>
    <link href="https://someexp.com/2024/shopping/"/>
    <id>https://someexp.com/2024/shopping/</id>
    <published>2024-08-29T16:00:00.000Z</published>
    <updated>2024-08-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写的<a href="/2022/life-notes">生活笔记</a>网友反馈还行, 希望我能出一份带图文和链接的, 于是就诞生了这篇.</p><span id="more"></span><script>  window.location.href = "/shopping";</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写的&lt;a href=&quot;/2022/life-notes&quot;&gt;生活笔记&lt;/a&gt;网友反馈还行, 希望我能出一份带图文和链接的, 于是就诞生了这篇.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Lifestyle" scheme="https://someexp.com/tags/Lifestyle/"/>
    
  </entry>
  
  <entry>
    <title>2023年年度小结</title>
    <link href="https://someexp.com/2023/annual-summary/"/>
    <id>https://someexp.com/2023/annual-summary/</id>
    <published>2023-12-22T16:00:00.000Z</published>
    <updated>2023-12-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>copy 2020, paste 2023.</p><span id="more"></span><p>翻阅以前自己写过的内容, 不只是没有年度总结, 而且很少发内容了, 以至于这篇总结我都是复制 2020 年的文件生成的.</p><p>因为去年 10 月辞去了工作, 所以终于有全部的时间来做自己想做的事情. 那是一段每天都能看自己想看的书的美好时光, 以至于成为了目前为止看书最多的一年. </p><p>在那之前我认为人生最重要的是健康, 于是我读了 默克家庭医学手册 这类 家庭医学参考书. </p><p>之后我也想对我自己思考的问题寻找一些解答, 比如: “我是什么?” 之类所谓 “寻找自己” 的问题.</p><p>于是我去阅读 人体的故事, 枪炮、病菌与钢铁, 这类希望能从人类历史找到答案的书. 其实很幸运, 它也给了我从人类历史这方面给出的答案. </p><p>它们也转变了我对人生的态度, 人生苦短, 及时行乐, 让我觉得人生最重要的是体验. </p><p>我最喜欢看的是科普书, 虽然科普这个标签似乎是给小孩子定制的, 但并不妨碍它能给我想了解的领域一份大纲. </p><p>于是陆陆续续看了 人类食物百科 (了解人类饮食), 自我管理之书 (心理学相关), 心理学百科, 哲学百科等等. 它们也从不同方面给出了问题的解答. </p><p>越来越多来自不同方面的答案, 使我对人生最重要的东西的定义产生了动摇, 是什么? 心流? </p><p>所以, 其实如果从不同方面看, 就会有不同的结论&#x2F;答案, 它们都有很合理的解释, 似乎没有一个是最正确最重要的, 它们都很好. </p><p>所以我会觉得, <strong>没有什么是非常重要的</strong>. 这会收获很多来自不同方面的见解. (意思是包容)</p><p>也了解到<strong>人很容易忘记&#x2F;记错东西, 也很容易归因错误从而责怪自己</strong>. </p><p>收获了一堆关于自我问题的答案之后, 我又在思考一些人和社会&#x2F;环境的问题. </p><p>跟之前一样, 陆陆续续看了 经济学百科, 社会学百科 … </p><p>意识到资源分配的不平等, <strong>源于不同环境的个体, 就不应该用统一的评判标准</strong>. </p><p>如果从宏观的角度看, <strong>所有这些学科试图解释问题而产生的结论&#x2F;答案, 都是具有时代背景的, 没有人能脱离得了时代</strong>, 它可能在这个时代被批为错误, 但放在另一个时代却是正确的. </p><p>在我认为寻找到问题的答案之后, 顷刻间我觉得自己老了, 因为后续的日子就比较少看书输入了, 会因为自己缺少变化的可能而感到害怕. </p><p>时间很快, 这是 2023 的我.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;copy 2020, paste 2023.&lt;/p&gt;</summary>
    
    
    
    
    <category term="Essay" scheme="https://someexp.com/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>生活笔记</title>
    <link href="https://someexp.com/2022/life-notes/"/>
    <id>https://someexp.com/2022/life-notes/</id>
    <published>2022-01-28T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>丁香生活研究所的文章整理. 选购, 种草笔记. </p><span id="more"></span><p><a href="#%E8%A1%A3">衣</a>, <a href="#%E9%A3%9F">食</a>, <a href="#%E4%BD%8F">住</a>, <a href="#%E8%A1%8C">行</a>, <a href="#%E7%94%B5%E5%99%A8">电器</a>, <a href="#%E5%AF%B9%E6%AF%94%E6%8E%A8%E8%8D%90">对比推荐</a>, <a href="#%E4%B8%AA%E6%8A%A4%E7%BB%93%E8%AE%BA">个护结论</a>, <a href="#%E9%A2%84%E9%98%B2">预防</a>, <a href="#%E8%BF%90%E5%8A%A8%E6%8A%80%E5%B7%A7">运动技巧</a>, <a href="#%E5%BA%94%E6%80%A5">应急</a>, <a href="#%E7%A7%8D%E8%8D%89%E4%B8%8E%E6%8B%94%E8%8D%89">种草与拔草</a></p><h1 id="衣"><a href="#衣" class="headerlink" title="衣"></a>衣</h1><p>衣服:<br>领口螺纹稳定性;</p><p>保暖袜:<br>COOLMAX + 羊毛; 想要耐穿，不容易磨出洞的袜子，看袜头袜跟。</p><p>厚睡衣:<br>面料保暖性: 羊羔绒 ≈ 珊瑚绒 ＞法兰绒。<br>因为羊羔绒和珊瑚绒的绒毛，对比法兰绒是要更长，更蓬松的。绒毛长且蓬松时，就可以储存更多空气。而空气是热的不良导体，可以有效防止热量流失，从而帮助我们更好地「保温」。但要注意的是——厚睡衣的里层、外层，并不都需要长且蓬松的绒毛。如果里面是长长长长的绒毛，建议不要买。<br>注意剪裁：袖口、裤口选有收口工艺的。建议选有「长罗纹收口」的。<br>看看有没有这个加分项：帽子。护住了头部、颈部，温暖的感觉会更明显。<br>如果你对保暖还有更高要求，那可以注意一下厚睡衣有没有「夹棉、夹层」。</p><p>保暖显瘦内衣:</p><ul><li>4种纤维混纺:<ul><li>涤纶: 也可以用绵纶, 棉代替. 锦纶 &gt; 涤纶 &gt; 棉.</li><li>腈纶: (人造羊毛), 有着不错的卷曲度, 蓬松度, 形成保温绝佳的空气层.</li><li>粘纤: 能用莫代尔, 棉花代替. 吸湿性: 莫代尔 &gt; 粘纤 &gt; 棉花.</li><li>氨纶: 这种纤维有着非常好的弹力, 混纺在衣服里, 可以让衣服贴身但不紧绷, 从而减少漏风.</li></ul></li><li>想要更保暖，加个关键词: 磨毛<ul><li>磨毛工艺其实就是用硬毛刷，把面料表面磨起一层均匀的，细密卷曲的绒毛。绒毛可以很好地储存空气，减少热量流失，从而帮助保暖，并且软软的绒毛穿起来也更亲肤舒适。</li><li>如果绒毛很长——那它就不是磨毛了，而是拉毛。能做拉毛的基本都是化学纤维，用类似鱼钩的钢针把面料中的纱线勾出来，保暖效果更好，在寒冷地区更适合。虽然穿起来暖和，吸湿排汗效果却不好，容易捂一身汗，而且长长的绒毛容易起静电，吸附皮脂、皮屑、灰尘，对呼吸道敏感或有鼻炎的朋友不太友好。<br>推荐: 德绒是一个纱线商标的名字，英文为 Dralon。, 它其实是一种腈纶，只不过比普通腈纶更好。如果预算充足或对保暖有较高追求，可以选择购买德绒的秋衣秋裤。如果预算不充足，也不用介意，普通腈纶完全够用。</li></ul></li></ul><h1 id="食"><a href="#食" class="headerlink" title="食"></a>食</h1><p>下饭酱: 饭扫光剁椒酱, 川娃子烧椒酱, 春光黄灯笼辣椒酱, 吉香居野山椒牛肉酱, 酱先生青椒酱, 独角兽暴肌厨房 0 脂蒜蓉酱, 李锦记泰式甜辣酱.</p><p>荞麦面:<br>日本对荞麦面的相关规定 —— 荞麦面中的荞麦粉含量在 30 % 以上，可以不标注含量，50 % 以上可以称为优质级。<br>「低钠食品」为钠含量低于 120 毫克 &#x2F; 100 克.</p><ul><li>农夫慢 免煮荞麦面</li><li>虢一坊 青稞苦荞挂面</li><li>金龙鱼 荞麦挂面</li><li>荞工坊 纯荞麦鲜面条</li><li>白象 万年荞苦荞麦挂面</li></ul><p>牛肉干:</p><ul><li>朗琨超干牛肉干<ul><li>配料: 牛肉、食用盐、香辛料、味精、食品添加剂（D-异抗坏血酸钠、5’呈味核苷酸二钠）、食用香精</li><li>蛋白质: 57 克 &#x2F; 100 克</li><li>纳: 516 毫克 &#x2F; 100 克</li><li>价格: 58.8 元 &#x2F; 份</li><li>百克价格: 49.8 元 &#x2F; 100 克</li></ul></li><li>京东京造风干牛肉</li><li>姑娘追手撕风干牛肉干 香辣 &#x2F; 椒麻</li><li>薄荷高蛋白风干牛肉</li><li>肌肉小王子牛肉棒</li></ul><p>酸奶:<br>4 款不加蔗糖: </p><ul><li>君乐宝简醇 0 添加蔗糖酸奶<ul><li>蛋白质含量: 3.0 克 &#x2F; 100 克</li><li>钙含量: 100 毫克 &#x2F; 100 克</li><li>碳水化合物含量: 6.2 克 &#x2F; 100 克</li><li>价格: 2.8 元 &#x2F; 150 克</li></ul></li><li>和润纯酸奶</li><li>北海牧场 0 蔗糖 风味发酵乳</li><li>新希望致轻风味酸乳</li></ul><p>4 款相对低糖:</p><ul><li>光明畅优风味发酵乳<ul><li>蛋白质含量: 2.8 克 &#x2F; 100 克</li><li>碳水化合物含量: 11.4 克 &#x2F; 100 克</li><li>价格: 2 元 &#x2F; 100 克</li></ul></li><li>君乐宝风味发酵乳（复原乳）</li><li>简爱酸奶滑滑</li><li>卡士原味鲜酪乳</li></ul><p>冰激凌:<br>平价低卡:</p><ul><li>零度企鹅酸奶口味冰淇淋 <ul><li>热量: 95 千卡</li><li>规格: 56 克</li><li>价格: 5.3 元</li></ul></li><li>雀巢呈真牛奶味冰淇淋</li><li>伊利妙趣非常熊猫 黑糖牛奶口味冰淇淋</li><li>蒙牛俄式奶纯冰淇淋</li><li>东北大板草原奶冰淇淋</li><li>和路雪千层雪棒 香草口味冰淇淋</li></ul><p>雪糕:<br>平价低卡:</p><ul><li>明治海盐荔枝雪糕<ul><li>热量: 66 千卡</li><li>规格: 46 克</li><li>价格: 3.6 元</li></ul></li><li>蒙牛绿色心情 炼乳红豆加绿豆口味雪糕</li><li>礼拜天大东北 红豆糯米方糕</li><li>伊利小布丁奶油口味雪糕</li><li>光明大白兔雪糕</li></ul><p>零食:<br>喜欢吃肉的:</p><ul><li>Keep 即食低脂牛肉 香辣味<ul><li>规格: 100 克</li><li>热量: 158.4 千卡 &#x2F; 100 克</li><li>钠含量: 465 毫克 &#x2F; 100 克 约 1.2 克盐</li><li>价格: 29 元 &#x2F; 100 克</li></ul></li><li>薄荷健康 虎皮鱿鱼鱼蛋 香辣味 (我自己吃过感觉不是很好吃)</li><li>薄荷健康 低脂鸡肉肠 香辣味 (我自己吃过感觉不是很好吃)</li></ul><p>喜欢吃素的:</p><ul><li>王辣辣魔芋制毛肚 重庆老火锅味<ul><li>规格: 72 克</li><li>热量: 72.1 千卡 &#x2F; 100 克</li><li>钠含量: 501 毫克 &#x2F; 100 克 约 1.3 克盐</li><li>价格: 20.5 元 &#x2F; 100 克</li></ul></li><li>周黑鸭周小伴 麻辣烤面筋</li><li>肌肉小王子 香辣味海带结</li></ul><p>711低卡零食:</p><ul><li>小伶鼬低脂鸡肉脆 藤椒味<ul><li>热量: 93.4 千卡 &#x2F; 包</li><li>钠含量: 383 毫克 &#x2F; 包</li><li>规格: 25 克</li><li>价格: 11.8 元</li></ul></li><li>红薯鲜生鲜蒸红薯干</li><li>北海牧场 0 蔗糖酸奶 白桃流心玫瑰</li><li>美玉子日式溏心蛋</li></ul><p>全家低卡零食</p><ul><li>全家魔芋奶油蛋糕</li><li>星期零蛋白棒 潮汕卤水味</li><li>亚洲噢嘿沙示汽水</li></ul><p>便利蜂低卡零食</p><ul><li>蜂质选混合坚果果粒</li><li>蜂质选甘栗仁 </li><li>赛味馆零卡吸吸冻 阳光玫瑰葡萄味</li><li>Zuo一下蒟蒻果冻 巨峰葡萄味</li><li>光明如实奇亚籽藜麦酸奶</li></ul><p>罗森低卡零食:</p><ul><li>ffit8 蛋白棒豆乳味</li></ul><p>无糖气泡水:</p><ul><li>元气森林 卡曼橘味苏打气泡水<ul><li>配料表: 水、赤藓糖醇、二氧化碳、碳酸氢钠、柠檬酸、三氯蔗糖、食用香精</li><li>钠含量: 0 mg &#x2F; 100 ml</li><li>价格: 6.6 元 &#x2F; 480 ml</li></ul></li><li>清泉出山 青提味苏打气泡水</li><li>喜茶 海盐柚子味无糖气泡水</li><li>雪碧 纤维＋柠檬味汽水</li><li>Bubly 微笑趣泡 蜜柚味气泡水</li><li>AHHA 柚子海盐味气泡水</li></ul><p>水果:<br>季节表<br><img src="/picture/2022-01-29-19-58-54.webp" alt="季节表"></p><p>黄桃罐头:<br>GB 7098 是「罐头执行标准」, GB &#x2F; T 13516 是更有针对性的「桃罐头执行标准」.<br>质量等级: 优等品 &gt; 一级品</p><p>纸巾:<br>基础信息不能少: 生产企业名称, 地址, 电话, 产品名称, 执行标准号<br>质量等级: 优等品 &gt; 一等品 &gt; 合格品<br>原料: 木浆 &gt; 草浆 &gt; 废纸浆 (用得起棉制品不用在意这一条)<br>注: 搓搓就掉毛的纸别再用了; 保质期一般 2-3 年, 当心囤着会过期;</p><h1 id="住"><a href="#住" class="headerlink" title="住"></a>住</h1><p>广州租房注意事项:</p><ul><li>整体:<ul><li>空间划分: 阳台, 厨房, 卫生间隔离?</li><li>外部: 周围噪音(空调外机位置)？周围异味? 周围污染? 网络信号? 光线(指南针看方位)? 通风?</li><li>内部: 地面平整? 有突出的地方? </li><li>电路: 入口开关位置？开关插座? 数量？容易接触到电管？空气开关? 漏电断路器?</li><li>进水管: 水龙头水管是否老化? 明暗管? 开关水龙头会有震动声音? 水管类型(铜管&gt;PPR&gt;PVC)？水管走顶? 高楼层水压(高层的水管越细越好)?</li><li>出水管: 分排水管, 排污管？地平？泄水坡？可能积水的地方? </li><li>窗户: 开合通畅? 漏风? 油烟味？防雨？与邻居窗距离? 风向? 是否有多个方向的窗户? 窗帘顶部遮光?</li><li>墙面: 空鼓&#x2F;缝隙？防滑瓷砖？瓷砖间的填缝剂&#x2F;美缝剂填好了? 厨卫包立管?</li><li>灯光: 双控? 灯光安装位置(该亮的地方亮)? </li><li>门: 开合通畅? 漏风? 隔音? 形成凹位?</li><li>动线便捷?</li><li>地漏: 地漏在动线上？地漏与门距离远? 地漏四周遮挡物？地漏在瓷砖中间？与排水管的走向, 位置, 设计不当洗手盆和洗衣机的水容易从其它地漏溢出.</li><li>洗手盆: P-Trap? (S-Trap 有虹吸问题)</li></ul></li><li>厅&#x2F;卧室:<ul><li>电路? 灯光? 适合安装新风系统? 空调冷管距离? 与外面隔音? 桌床头插座?</li></ul></li><li>厨房:<ul><li>电路? 灯光? 地漏? 水管? 洗手盆? 防滑地板? 抽油烟机管道长度? 止逆阀?</li></ul></li><li>卫生间:<ul><li>电路? 灯光? 地漏? 水管? 洗手盆? 防滑地板? 距离厅卧位置? 有门槛石? 泄水坡(四周有无遮挡物)? 热水器插头距离？水压？窗户&#x2F;排气扇? 止逆阀? 开关位置合理?</li></ul></li><li>阳台: <ul><li>地漏? 雨污分流? 阳台内墙? 采光通风? 进水口合理? 防雨?</li><li>双阳台动线迂回?</li></ul></li></ul><p>推荐书籍: 小家越住越大</p><p>床垫:<br>一项发表在《柳叶刀》上的研究，就把 313 个腰痛患者分成两组，让他们分别睡硬床和软硬适中的床，结果显示——软硬适中的床垫，对腰痛的缓解效果较好。<br>建议: 独立袋装弹簧; 铺垫层，选几层材质组合在一起的; 最好去线下店铺试睡;</p><p>毛巾:<br>建议: 化纤毛巾, 超细旦纤维毛巾, 珊瑚绒毛巾; 涤纶、锦纶混纺;(涤纶，也叫聚酯纤维；锦纶，也叫聚酰胺纤维)<br>挑选原则: </p><ul><li>选择 聚酰胺纤维 (锦纶) 比例高的, 越高品质可能越好</li><li>喜欢厚实松软的, 记住一个公式: 克重 &#x2F; 长 &#x2F; 宽 &gt;&#x3D; 300, 数值越高可能越好.<br>(举个例子: 72克 &#x2F; 0.5 米 &#x2F; 0.3 米 &#x3D; 480, 数值为 480, 超出 300, 那这款超细旦纤维毛巾应该是厚实又松软的.)</li></ul><p>羽绒被:</p><ul><li>绒子含量越高，羽绒被越蓬松保暖，一般选 85% 、90% 就够用。</li><li>被面材质选涤棉混纺的(棉+聚酯纤维)</li><li>立衬工艺选错位式的</li><li>认准 A 类纺织品和 OEKO TEX 认证</li></ul><p>四件套:</p><ul><li>支数 (英支, 常以S表示) 60S, 80S, 100S 越高越好. (注: 公支, 常以 N 表示, 1公支&#x3D;1.69X英支, 注意看单位)</li><li>纯棉就选新疆长绒棉, 一定要有<strong>长绒棉</strong>三个字; 莫代尔, 莱赛尔面料性能要优于纯棉;</li><li>织造方式: 缎纹(贡缎) &gt; 斜纹 &gt; 平纹</li><li>印花工艺: 看到<strong>涂料印花</strong>扭头就跑; 活性印花只是是一个安全的基本要求, 不用支付过高溢价;</li></ul><h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><h1 id="电器"><a href="#电器" class="headerlink" title="电器"></a>电器</h1><h1 id="对比推荐"><a href="#对比推荐" class="headerlink" title="对比推荐"></a>对比推荐</h1><p>身体乳:<br><a href="http://www.pifukezazhi.com/CN/Y2016/V49/I8/537">中国皮肤清洁指南</a>(<a href="http://www.pifukezazhi.com/">http://www.pifukezazhi.com</a>)<br>建议：对于所有人群来说，尤其是婴幼儿、老人和皮肤干燥人群和湿疹人群，洗澡后应尽量在 3 分钟里涂上保湿产品。<br>如果使用的是高浓度酸类产品，像 Alpha Hydrox 果酸身体乳，使用频次也不能太高，油性皮肤大概一周 1～2 次，而干性皮肤两周一次就够了。<br>一旦感觉到刺痛，或其他皮肤不适的症状，就应该立刻停止使用。<br>身体乳(不考虑价格第一类): 滑到挂不住手，干敏皮的最爱</p><details><summary>玉泽皮肤屏障修护身体乳 (0.70 CNY/ml)</summary><ul><li>主要成分: 甘油、红花籽油、牛油果树果脂、油橄榄果油、鳄梨油、尿囊素</li><li>规格: 280 ml &#x2F; 瓶</li><li>价格: 198 元</details></li></ul><details><summary>艾惟诺天然燕麦润肤乳 (0.42 CNY/ml)</summary><ul><li>主要成分: 甘油、二硬脂基二甲基氯化铵、矿脂、棕榈酸异丙酯、鲸蜡醇、聚二甲基硅氧烷、燕麦仁细粉、燕麦仁油、异丙醇、牛油果树果脂</li><li>规格: 354 ml &#x2F; 瓶</li><li>价格: 148 元</details></li></ul><details><summary>适乐肤神酰 C 乳 (0.54 CNY/ml)</summary><ul><li>主要成分: 甘油、鲸蜡醇、聚二甲基硅氧烷、神经酰胺 1、神经酰胺 3、神经酰胺 6 Ⅱ、透明质酸</li><li>规格: 236 ml &#x2F; 瓶</li><li>价格: 128 元</details></li></ul><p>身体乳(第二类): 提亮肤色、去鸡皮，肌肤进阶之路</p><details><summary>凡士林大粉瓶 (0.14 CNY/ml)</summary><ul><li>主要成分: 肉豆蔻酸异丙酯、矿油、甘油硬脂酸酯、棕榈酸、烟酰胺</li><li>规格: 400 ml &#x2F; 瓶</li><li>价格: 56.9 元</details></li></ul><details><summary>玉兰油烟酰胺身体乳 (0.28 CNY/ml)</summary><ul><li>主要成分: 甘油、烟酰胺、矿脂、聚二甲基硅氧烷、硬脂醇</li><li>规格: 250 ml &#x2F; 瓶</li><li>价格: 69.9 元</details></li></ul><details><summary>sesderma 焕白保湿身体乳 (0.42 CNY/ml)</summary><ul><li>主要成分: 鲸蜡醇、甘油、烟酰胺、传明酸、植物鞘氨醇、甘草次酸、乳香酸、神经酰胺和 VE 衍生物</li><li>规格: 400 ml &#x2F; 瓶</li><li>价格: 168 元</details></li></ul><details><summary>Alpha Hydrox 果酸身体乳 (0.45 CNY/ml)</summary><ul><li>主要成分: 矿脂、甘油、羟基乙酸、硬脂酸、鲸蜡醇</li><li>规格: 340 ml &#x2F; 瓶</li><li>价格: 169 元</details></li></ul><p>防晒霜:</p><details><summary>Mistine 小黄帽防晒霜 (1.7 CNY/ml)</summary><ul><li>类型: 纯化学防晒</li><li>防晒值: SPF 50＋，PA++++</li><li>价格: 69 元&#x2F; 40 毫升</li><li>适合肤质: 敏感肌除外</details></li></ul><details><summary>兰蔻小白管防晒乳 (16 CNY/ml)</summary><ul><li>类型: 纯化学防晒</li><li>防晒值: SPF 50，PA++++</li><li>价格: 480 元&#x2F; 30 毫升</li><li>适合肤质: 敏感肌除外</details></li></ul><details><summary>碧柔小蓝瓶 (0.8 CNY/ml)</summary><ul><li>类型: 纯化学防晒</li><li>防晒值: SPF 50，PA+++</li><li>价格: 69 元&#x2F; 90 毫升</li><li>适合肤质: 混油皮、油皮</li><li>备注: 配方里有酒精和香料，建议敏感肌谨慎使用。</details></li></ul><details><summary>薇诺娜清透防晒乳 (4 CNY/ml)</summary><ul><li>类型: 纯化学防晒</li><li>防晒值: SPF 48，PA+++</li><li>价格: 199 元&#x2F;50 克</li><li>适合肤质: 油皮、混油皮</details></li></ul><details><summary>怡思丁小蓝瓶 (2.8 CNY/ml)</summary><ul><li>类型: 纯化学防晒</li><li>防晒值: SPF 50+</li><li>价格: 139 元&#x2F; 50 毫升</li><li>适合肤质: 所有肤质</details></li></ul><details><summary>安热沙小金瓶防晒霜 (4.1 CNY/ml)</summary><ul><li>类型: 物化结合型防晒</li><li>防晒值: SPF 50+，PA++++</li><li>价格: 248 元&#x2F;60 毫升</li><li>适合肤质: 所有肤质，敏感肌除外</details></li></ul><details><summary>FANCL 倍护防晒隔离露 (4.9 CNY/ml)</summary><ul><li>类型: 纯物理防晒</li><li>防晒值: SPF 50+，PA++++</li><li>价格: 295 元&#x2F;60 毫升</li><li>适合肤质: 敏感肌</details></li></ul><p>沐浴露(第一类): 喜欢一冲即净的清爽肤感</p><details><summary>多芬 丰盈宠肤滋养美肤沐浴乳 (0.05 CNY/g)</summary><ul><li>规格: 1000 ml</li><li>价格: 49.9 元</details></li></ul><details><summary>曼秀雷敦 清爽沐浴露 (0.07 CNY/g)</summary><ul><li>规格: 500 ml</li><li>价格: 35 元</details></li></ul><details><summary>蜜浓 温和保润洁肤皂 (1 CNY/g)</summary><ul><li>规格: 80 克</li><li>价格: 80 元</details></li></ul><p>沐浴露(第二类): 温和清洁的同时保持滋润</p><details><summary>可悠然 美肌沐浴露 (0.12 CNY/g)</summary><ul><li>规格: 550 ml</li><li>价格: 67 元</details></li></ul><details><summary>珂润 润浸保湿泡泡沐浴液 (0.16 CNY/g)</summary><ul><li>规格: 480 ml</li><li>价格: 79 元</details></li></ul><details><summary>优色林 均衡护理温和沐浴油 (0.39 CNY/g)</summary><ul><li>规格: 400 ml</li><li>价格: 155 元</details></li></ul><p>沐浴露(第三类): 洗完后整个人都是香香的</p><details><summary>力士 沉醉星河沐浴露 (0.14 CNY/g)</summary><ul><li>规格: 470 ml</li><li>价格: 64.9 元</details></li></ul><details><summary>清扬男士 深海探险古龙香氛沐浴露 (0.12 CNY/g)</summary><ul><li>规格: 500 ml</li><li>价格: 59 元</details></li></ul><p>洗发水(第一类): 控油蓬松</p><details><summary>多芬 空气丰盈保湿洗发露 (0.12 CNY/ml)</summary><ul><li>规格: 480 毫升</li><li>价格: 59.9 元</details></li></ul><details><summary>吕 紫吕洗发水 (0.16 CNY/ml)</summary><ul><li>规格: 400 毫升</li><li>价格: 65 元</details></li></ul><details><summary>水之密语 男士控油净润泡沫洗发水 (0.13 CNY/ml)</summary><ul><li>规格: 500 毫升</li><li>价格: 66 元</details></li></ul><p>洗发水(第二类): 柔顺保湿</p><details><summary>潘婷 丝质顺滑洗发水 (0.1 CNY/ml)</summary><ul><li>规格: 200 毫升</li><li>价格: 19.8 元</details></li></ul><details><summary>黛丝恩摩洛哥油洗发水 (0.17 CNY/ml)</summary><ul><li>规格: 450 毫升</li><li>价格: 78 元</details></li></ul><p>洗发水(第三类): 去屑止痒</p><details><summary>海飞丝专研去屑洗发水 头皮控油排浊型 (0.27 CNY/ml)</summary><ul><li>规格: 300 毫升</li><li>价格: 79.9 元</li><li>备注: 但是前阵子欧盟禁用了吡硫翁锌（ZPT），这导致很多在售的去屑洗发水都紧急调整了配方。多年来，海飞丝主打的去屑有效成分正是吡硫翁锌（ZPT）。从去年开始陆续换成了「呲罗克酮乙醇铵盐」为主的去屑体系，相比下来更安全。</details></li></ul><details><summary>清扬去屑洗发水 清爽控油型 (0.06 CNY/ml)</summary><ul><li>规格: 1200 毫升</li><li>价格: 66.9 元</details></li></ul><details><summary>珂润浸润保湿洗发水 (0.2 CNY/ml)</summary><ul><li>规格: 420 毫升</li><li>价格: 86 元</li><li>备注: 不太好买到，可以去屈x氏、万x 或网上官方旗舰店找找看。</details></li></ul><p>牙膏:<br>买含氟的, 摩擦剂优先水合硅石.<br>牙膏(第一类): 基础清洁篇</p><details><summary>黑人双重薄荷牙膏 (0.08 CNY/g)</summary><ul><li>成分表: 磷酸氢钙二水合物、水、甘油、山梨（糖）醇、磷酸氢钙、月桂醇硫酸酯钠、香精（含天然留兰香薄荷精华和椒样薄荷精华）、皱波角叉菜、月桂酰肌氨酸钠、单氟磷酸钠 0.1%、焦磷酸四钠、糖精钠</li><li>价格: 16.9 元 &#x2F; 225 克</li><li>备注: 使用含氟牙膏是安全、有效的防龋齿措施。而目前有充分证据显示，每天使用含氟量 ≥0.1% 的牙膏刷牙两次，可达到良好的防龋效果。</details></li></ul><details><summary>高露洁全面防蛀牙膏 (0.06 CNY/g)</summary><ul><li>成分表: 磷酸氢钙二水合物、水、山梨（糖）醇、月桂醇硫酸酯钠、水合硅石、香精（超爽薄荷型）、单氟磷酸钠、焦磷酸四钠、纤维素胶、黄原胶、糖精钠、氟化钠</li><li>价格: 13.9 元 &#x2F; 250 克</li><li>备注: 水合硅石这种人工合成的颗粒，因为硬度适中、圆润均匀，能较好地清洁牙面，但又不至于对牙面造成过大磨损，属于比较推荐的一种摩擦剂。</details></li></ul><details><summary>佳洁士高阶全优 7 效牙膏 (0.17 CNY/g)</summary><ul><li>成分表: 水、山梨（糖）醇、水合硅石、葡萄酸钠、月桂醇硫酸酯钠、皱波角叉菜、食用香精（料）（含氰甲基苯基薄薄荷烷基甲酰胺）、氯化亚锡、黄原胶、柠檬酸锌、氢氧化钠、氟化钠 0.15%、糖精钠、CI 74160、CI 42090</li><li>价格: 24.9 元 &#x2F; 140 克</details></li></ul><p>牙膏(第二类): 抗敏感篇</p><details><summary>冷酸灵专研抗敏牙膏 (0.1 CNY/g)</summary><ul><li>成分表: 磷酸氢钙二水合物、甘油、水、硝酸钾、月桂醇硫酸酯钠、水合硅石、香精、纤维素胶、氯化锶六水合物、黄原胶、聚乙二醇-32、焦磷酸四钠、糖精钠、聚丙烯酸钠、月桂酰肌氨酸钠、苯甲酸钠</li><li>价格: 13.9 元 &#x2F; 110 克</li><li>备注: 冷酸灵这款牙膏不含氟，所以不适合长期使用，或者大家可以搭配着其他含氟的牙膏一起交替着使用。</details></li></ul><details><summary>舒适达多效护理牙膏 (0.2 CNY/g)</summary><ul><li>成分表: 水、水合硅石、山梨（糖）醇、硝酸钾、甘油、聚乙二醇-6、月桂醇硫酸酯钠、CI 77891、黄原胶、柠檬酸锌、香精、椰油酰胺丙基甜菜碱、氟化钠、糖精钠、氢氧化钠</li><li>价格: 38.8 元 &#x2F; 180 克</li><li>备注: 因为每个人牙敏感的原因不太一样，存在个体差异，所以大家可以尝试一下各种抗敏牙膏，看看哪种对自己是比较有效的。</details></li></ul><p>牙膏(第三类): 消肿镇痛止血篇<br>宣称消肿镇痛止血的牙膏，建议大家谨慎。<br>目前市面上宣称消肿镇痛止血的牙膏，很多是添加了氨甲苯酸、凝血素等成分，来帮助消除软组织的红、肿、痛甚至止血，但这并没有妥善解决病症。<br>很可能在未来的某一天火山爆发……引发牙龈萎缩、牙齿松动等更加严重的后果。<br>所以如果你的牙龈经常出现肿痛、出血等情况，还是建议尽早去看医生，咨询医生意见选择消肿镇痛止血牙膏，这可别拖延噢。</p><p>洗衣液(第一类): 饭菜类油污<br>要对付这类饭菜油污，可以选择含「酶」的洗衣液。</p><details><summary>奥妙深层洁净洗衣液 (0.014 CNY/g)</summary><ul><li>产品类型: 洗衣液</li><li>主要功效: 含酶洗衣液，针对用餐时的污渍有很好的清洁效果。</li><li>主要成分: 表面活性剂、酶</li><li>参考价格: 3kg &#x2F; 42.9 元</li><li>备注: 奥妙这款是老牌的含酶洗衣液了，联合利华专供的复合酵素，去油污能力一直很不错。pH 值中性，需要局部处理污渍、手洗揉搓的时候，也不用担心伤手。</details></li></ul><details><summary>花王洁霸无磷酵素洗衣液 (0.021 CNY/g)</summary><ul><li>产品类型: 洗衣液</li><li>主要功效: 含酶洗衣液，清洁油污，快速漂洗。</li><li>主要成分: 表面活性剂，酶</li><li>参考价格: 2kg &#x2F; 42.8 元</li><li>备注: 花王洁霸这款同样是含复合酶制剂的洗衣液，起泡丰富细腻，漂洗时能更快速地冲干净。适合洗衣追求效率、爱用「快洗模式」的人。</details></li></ul><p>洗衣液(第二类): 有色饮料和笔迹类污渍<br>氧漂助洗剂就能帮到你！放进洗衣机前，把氧漂助洗剂涂抹在污渍处，停留几分钟，让有效成分充分浸润，再揉搓，效果就会好得多。</p><details><summary>立白白漂液 (0.017 CNY/g)</summary><ul><li>产品类型: 氧漂助洗剂</li><li>主要功效: 漂白衣物、杀灭细菌</li><li>主要成分: 次氯酸钠</li><li>参考价格: 1kg &#x2F; 16.9 元</details></li></ul><details><summary>Vanish 焕彩粉 (0.080 CNY/g)</summary><ul><li>产品类型: 氧漂助洗剂</li><li>主要功效: 漂亮彩色衣物，去渍护色。</li><li>主要成分: 活氧因子、表面活性剂、酵素、纤维素酶</li><li>参考价格: 1kg &#x2F; 79.9 元</li><li>备注: 这款含有酶制剂，只能用在棉、麻、聚酯纤维的面料上，不能用来洗本身含有蛋白质的丝绸、皮革、羊毛、羽绒等衣物。如果是笔迹类的污渍，就真的很难完全清洗干净了……因为笔墨被设计出来就是要渗透进纤维的，衣服当然也不在话下。稍微能拯救下的办法是，先用酒精对污渍处进行擦拭，然后再涂上彩漂&#x2F;白漂剂搓揉一下，也许能淡化。一个贴心小提示：氧漂助洗剂通常比较刺激，搓洗时记得带手套哦。</details></li></ul><p>洗衣液(第三类): 干涸的血渍<br>血渍内含有大量的蛋白质，会渗透到纤维内部凝固，导致一般洗衣液很难彻底清除。<br>如果是新鲜的血渍，还有一个你们意想不到的预处理神器：隐形眼镜护理液！护理液中大部分会添加硼砂类成分，对去除蛋白质有很好的效果。在血迹处滴上几滴，揉搓几分钟后再正常洗，会有惊喜哦。再强调下，血渍尽量用冷水洗。热水会让蛋白质变性，附着在纤维内部形成蛋白胶，就更洗不掉了。</p><details><summary>小林制药女性内衣洗涤剂 (0.23 CNY/ml)</summary><ul><li>产品类型: 内衣专用洗剂</li><li>主要功效: 去常规污渍和血渍，可以手洗。</li><li>主要成分: SAS（仲烷基磺酸钠）</li><li>参考价格: 300 ml &#x2F; 69 元</li><li>备注: 添加了小林独有的高渗透率表面活性剂 SAS（仲烷基磺酸钠），并且也是高度浓缩，不需要用很多就能达到去渍效果。</details></li></ul><details><summary>花王内衣内裤清洗剂 (0.56 CNY/ml)</summary><ul><li>产品类型: 内衣专用洗剂</li><li>主要功效: 去常规污渍和血渍，可以手洗</li><li>主要成分: 表面活性剂，酶</li><li>参考价格: 80ml &#x2F; 44.5 元</li><li>备注: 但缺点是偏贵，容量很小不太经用。更适合用作经期内裤的专用清洗剂。</details></li></ul><p>洗衣液(第四类): 发黄的汗渍<br>泛黄的部分可能是变性的蛋白质导致。</p><details><summary>Vanish 衣领净 (0.10 CNY/ml)</summary><ul><li>产品类型: 衣领净</li><li>主要功效: 去除汗渍导致的发黄</li><li>主要成分: 氧化剂</li><li>参考价格: 500ml &#x2F; 49.9 元</li><li>备注: 如果不想专门买一瓶的话，我们也有一个很神奇的替代方案：洗衣机槽清洁剂。洗衣机槽清洁剂的主要成分是过碳酸钠，在热水中倒入洗衣机槽清洁剂后，浸泡发黄的部分即可去除汗渍。</details></li></ul><p>洗衣液(第五类): 进阶护理需求(5.1 去静电、防磨损)<br>而柔顺剂能除静电的效果可不是吹的，一般主要成分是季铵盐类表面活性剂，能中和纤维电荷，达到除静电的效果。<br>并且，它能停留在衣服的表面，形成保护层。如果有一些比较娇贵的面料，比如真丝，在洗衣时使用柔顺剂可以有效减少衣服磨损，让喜欢的衣服更耐穿。</p><details><summary>金纺纯净温和柔顺剂 (0.011 CNY/ml)</summary><ul><li>产品类型: 柔顺剂</li><li>主要功效: 去除静电，减少衣物磨损。温和配方，敏感肌适用。</li><li>主要成分: 季铵盐类阳离子表面活性剂</li><li>参考价格: 4L &#x2F; 43.9 元</details></li></ul><p>洗衣液(第五类): 进阶护理需求(5.2 增添香气)</p><details><summary>当妮二合一香水洗衣液 (0.021 CNY/g)</summary><ul><li>产品类型: 洗衣液</li><li>主要功效: 去除污渍，柔顺，持久留香。</li><li>主要成分: 表面活性剂，香精，微胶囊</li><li>参考价格: 1.9kg &#x2F; 39.8 元</details></li></ul><p>洗衣液(第五类): 进阶护理需求(5.3 护色鲜亮)<br>浅色衣服多洗几次容易发黄显旧，想要衣服保持颜色鲜亮，可以购买添加了荧光增白剂的洗衣液。</p><details><summary>蓝月亮深层洁净洗衣液 (0.018 CNY/g)</summary><ul><li>产品类型: 洗衣液</li><li>主要功效: 去渍，护色，亮彩</li><li>主要成分: 表面活性剂，荧光增白剂</li><li>参考价格: 2kg &#x2F; 36.8 元</li><li>备注: 国家对荧光增白剂的检测还是挺严格的，它也并不会轻易从衣服上大量迁移到皮肤。选择正规厂商的产品就不用太担心。</details></li></ul><p>醋:<br>国标GB&#x2F;T 18187-2000要求: 酿造食醋的总酸(以乙酸计)应该&gt;&#x3D;3.5克&#x2F;100毫升<br>建议: 酿造食醋, 固态发酵.</p><ul><li>CUCU 阳光老陈醋<ul><li>总酸: ≥ 4.5 克 &#x2F; 100 毫升</li><li>配料: 生活饮用水、高粱、玉米、豌豆、大麦、麸皮、谷糠、稻壳、食用盐、香辛料、苯甲酸钠</li><li>规格: 420 毫升 &#x2F; 瓶</li><li>价格: 5.5 元</li><li>单毫升价格: 0.013 元&#x2F;克</li></ul></li></ul><h1 id="个护结论"><a href="#个护结论" class="headerlink" title="个护结论"></a>个护结论</h1><h1 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h1><p>体检:<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTg0MjA5OQ==&mid=2654943936&idx=1&sn=9e298c9877f7a2ec475e49f3aedc5511&chksm=8445401cb332c90a4b60ecd07418a631919bdf25ca8a41b8414ae33519cc7daf298c956415c5&scene=27#wechat_redirect">别再花冤枉钱了，要做的体检项目就这些</a></p><p>洗牙:</p><p>牙线:</p><h1 id="运动技巧"><a href="#运动技巧" class="headerlink" title="运动技巧"></a>运动技巧</h1><h1 id="应急"><a href="#应急" class="headerlink" title="应急"></a>应急</h1><p>应急包:</p><ul><li>水源和食物: 在城市地区发生水源和食物完全断供的风险较低，虽然需要水源和食物，但是也不需要大量储备。可以按照每人 3 升的饮用水储备，以应对短期的停水。然后可以储备一些压缩饼干、罐头等保持期长的食品应急。</li><li>急救包：包含伤口处理工具、急救药品和急救参考书籍等。</li><li>手电筒及备用电池。紧急时刻逃生照明或停电时照明，可以准备多个。</li><li>急救保温毯。具有保温、反光等功能，适合在地震等情形下遮风挡雨、保温保暖。淘宝几块钱就能买一张。</li><li>卫生用品。湿纸巾、纸巾、一次性毛巾、酒精棉片。</li><li>充电宝&#x2F;备用电源及充电线。</li><li>身份、银行资料的复印件，保存在防水袋里。</li><li>备用现金。</li></ul><p>另外，如果你处于地震、海啸、洪水等自然灾害易发频发的地区，还要额外准备一些东西.<br>应对地震，应急包中建议包括至少 3 天的食物和水；灭火器和口哨；还可以准备安全帽、口罩。<br>安全帽可以减轻被物体砸中的损伤。佩戴口罩可以减少吸入灰尘，普通口罩也比不戴好。<br>在海啸和洪水频发的地区，可以准备救生衣，至少一人一件；如果家里有小朋友，记得为小朋友准备专用的救生衣。<br>另外，除了地震、海啸等自然灾害意外，我们的生活中还可能会遇到其他的灾害危险，所以研究所还整理了一些日常防火防灾的东西。</p><p>烟雾报警器<br>有一点注意，大部分的烟雾报警器不太建议在厨房使用，因为在厨房炒菜本来就有油烟，容易误报警，如果厨房想要拥有，可以选择温感式烟雾报警器。在家里安装时，记得避开风口，不然烟都被吹没了，也没办法报警。</p><p>灭火毯<br>国外许多家庭都会在厨房常备灭火毯，放在灶台上。无论是油锅起火、其他物品燃着了还是人身上着火，用灭火毯扑在火上紧紧盖住就行了，不过，深层油锅可能不太适合。材质上，石棉比玻璃纤维更好，但更贵。不过基本上都不会超过一百元。</p><p>防毒面具<br>火灾时，会产生大量有毒物质，如一氧化碳和氰化物。用湿毛巾捂住口鼻并不能阻挡一氧化碳和有毒气体。这个时候防毒面具才能真正起效。<br>防毒面具分为两种，一种叫过滤式防毒面具，顾名思义，它可以过滤有毒气体，比较网红的品牌有火焰战士、德尔格等。<br>还有一种是自生氧式防毒面具，通过利用人呼出的二氧化碳和水产生氧气 (潜水艇的氧气也是通过这种方式产生的)，可以在氧气浓度低的环境中使用。这种面具价格会比较高，大概在几百元左右，目前能买到的型号比较少，大家也是认准 3C 认证就好。</p><p>燃气报警器 &#x2F; 一氧化碳报警器<br>很多人可能分不清楚燃气报警器及和一氧化碳报警器，有可能会买错。<br>一氧化碳报警器适用烧煤烧炭的家庭，它主要是检测空气中的一氧化碳浓度，防止中毒，如果想买，也可以考虑海曼或者霍尼韦尔。<br>燃气报警器呢，比较适用使用天然气、液化石油气的家庭，可以探测到甲烷和丙烷。<br>虽然许多城市使用的燃气已经添加了警示性气体，使得燃气泄漏时人们可以闻到气味，及时作出响应。但如果家里经常没有人、或者只有老人小孩，安装一个还是有必要的。<br>可以考虑小米-霍尼韦尔联名天然气报警器、海康威视天然气报警器。<br>这里还要特别提醒一下，也要记得定期检修、更换家中的燃气设备和耗材，避免因为设备老化、故障带来的危险。</p><p>灭火器<br>其实大部分居民楼的楼道间都有灭火器，所以倒不需要每个家庭必须自备灭火器。<br>但是要确保自己知道灭火器的类型（一般是干粉和水基两种，具体要参考灭火器上的标志），位置在哪，有没有过期，也要知道如何使用，不然真有火情的时候只能两眼抓瞎。<br>如果火情蔓延极快，不应尝试自行扑灭，应该立即报警、关闭电源、立即逃生。</p><p>最后，不光要对自己的生命负责，也要对家庭成员负责。确保每个家庭成员 ，包括老年人、残障人群和小朋友，都了解防护用品的位置和应对灾害的基本方法哦。</p><h1 id="种草与拔草"><a href="#种草与拔草" class="headerlink" title="种草与拔草"></a>种草与拔草</h1><p>懒人抹布? 超细纤维抹布? 鱼鳞布? 陶瓷刀? 湿厕纸? 液体创可贴? 骨传导耳机? 夏天五指袜? </p><p>测试好玩:<br>紫外线卡? 牙菌斑显示剂?</p><p>我倾家荡产也要买(不构成推荐建议):<br>不锈钢晾衣架; 不锈钢马桶刷; 铝制置物架;<br>贵的路由器, 贵的就是好的hhh;<br>晶钻&#x2F;晶彩锅, 实在是太好看了;</p><h1 id="选购七律"><a href="#选购七律" class="headerlink" title="选购七律"></a>选购七律</h1><ul><li>不要纠结了，没有最好的产品，也没有最适合的。</li><li>没有远超时代的技术，没有黑科技，没有神奇。</li><li>便宜没好货，不代表昂贵就是好货。</li><li>字体越大、颜色越深的内容，越不可信。</li><li>大部分新奇产品的结局是吃灰，买前给自己一天的冷静期。</li><li>不要相信 KOL、发烧友、评测和导购文，网上的信息九成九都是营销材料。</li><li>不要相信我，绝大部分旁人的使用感受，对你毫无价值。</li></ul><p>注：以上仅指民用消费领域<sup><a href="https://www.qwyw.org/archives/2414">来源</a></sup></p><p>多bb两句:</p><ul><li>健康原则, 做对身体伤害最小的事</li><li>八二法则, 专业的事交给专业的东西去做</li><li>刚需能一步到位, 就一步到位</li></ul><p>参考:<br>丁香生活研究所<br><a href="https://www.guiderank-app.com/">盖得排行</a><br><a href="https://qwyw.org/">器物与我</a><br><a href="https://www.ymdie.com/">亚马跌</a></p>]]></content>
    
    
    <summary type="html">丁香生活研究所的文章整理. 选购, 种草笔记.</summary>
    
    
    
    
    <category term="Note" scheme="https://someexp.com/tags/Note/"/>
    
    <category term="Lifestyle" scheme="https://someexp.com/tags/Lifestyle/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Android</title>
    <link href="https://someexp.com/2021/how-to-use-android/"/>
    <id>https://someexp.com/2021/how-to-use-android/</id>
    <published>2021-04-14T16:00:00.000Z</published>
    <updated>2021-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Android 的指南. 正确使用姿势是什么? 如何隔离流氓应用? </p><span id="more"></span><p>不知道你是不是从 <a href="/2020/how-to-use-windows10">如何使用windows10</a> 过来的呢?</p><h1 id="关于系统"><a href="#关于系统" class="headerlink" title="关于系统"></a>关于系统</h1><p>Android 作为移动系统, 其安全性和稳定性远不如类似 Windows 这样的桌面系统的. 下面都是围绕如何防流氓软件介绍的.<br>系统使用出厂 ROM 优点是厂商会给你提供安全更新, 缺点是厂商会给你塞各种奇奇怪怪的系统应用, 而你作为用户还可能无法卸载, 而系统应用拥有的权限比普通应用高, 厂商开发的系统应用质量又参差不齐, 因此我个人还是建议刷人气高的开源 ROM , 比如 AOSP ROM. 总之看个人喜好吧, 不刷也不会导致大的问题. 刷机途中会经过各种操作, 一不小心还可能会变砖, 因此风险和收益并重的情况下需要自行抉择与承担后果啦.</p><h2 id="为什么不用漂亮的个人定制-ROM"><a href="#为什么不用漂亮的个人定制-ROM" class="headerlink" title="为什么不用漂亮的个人定制 ROM ?"></a>为什么不用漂亮的个人定制 ROM ?</h2><p>非开源的 ROM 或者不知道哪个网站下载的定制 ROM 很难确保它是安全的, 有可能 ROM 中有一些恶意程序. 建议还是刷官方提供的 ROM 和开源 ROM.</p><h1 id="关于应用程序"><a href="#关于应用程序" class="headerlink" title="关于应用程序"></a>关于应用程序</h1><p>这边建议所有软件统一从谷歌商店(Google Play Store)或者 F-Droid 下载, 这个需要安装谷歌框架, 对于不喜欢谷歌框架的我都是从一些镜像站下载应用安装包手动安装的.</p><h1 id="Shelter"><a href="#Shelter" class="headerlink" title="Shelter"></a>Shelter</h1><h2 id="为什么使用-Shelter"><a href="#为什么使用-Shelter" class="headerlink" title="为什么使用 Shelter?"></a>为什么使用 Shelter?</h2><p>Shelter 是一个利用 Android 工作空间特性实现存储隔离的应用, 重点是它无需 root 权限就能使用. 这简直是我这类不喜欢使用高权限用户的福音. Shelter 开源简单易于使用. 同样你也可以使用 Island + 冰箱 的组合达到同样的效果.</p><p>Shelter 利用 Android 工作空间的特性, 也因此 Shelter 安装完并初始化后你的手机会有两个空间, 主空间和工作空间:</p><ul><li>主空间默认是&#x2F;storage&#x2F;emulated&#x2F;0</li><li>工作空间是&#x2F;storage&#x2F;emulated&#x2F;10</li></ul><p>安装在不同空间的应用, 它们存储和访问的路径是隔离开来的, 也因此我们可以把信任的程序和私密的资料放在其中一个空间, 就能防止另外空间的程序读取了.</p><h2 id="工作空间中的-Android-data-目录无法访问"><a href="#工作空间中的-Android-data-目录无法访问" class="headerlink" title="工作空间中的 Android&#x2F;data 目录无法访问"></a>工作空间中的 Android&#x2F;data 目录无法访问</h2><p>Android 对 &#x2F;Android&#x2F;data, &#x2F;Android&#x2F;obb 之类的路径设置了特殊的权限, 因此可能无法操作这些文件夹, 解决办法是想办法给程序权限就好了. 在这里我是使用了 X-plore 这个文件管理器来操作这些路径的, 在操作前它会提示授权.</p><h2 id="Shelter-中安装的微信无法使用小程序"><a href="#Shelter-中安装的微信无法使用小程序" class="headerlink" title="Shelter 中安装的微信无法使用小程序"></a>Shelter 中安装的微信无法使用小程序</h2><p>关于微信中无法使用小程序的解决方案看<a href="https://www.52pojie.cn/thread-1051304-1-1.html">这里</a>, 其它的应用出现啥奇奇怪怪的问题估计也和这个有关吧.</p><p>最后附上 Shelter 安装和简单设置演示<a href="https://b23.tv/0RArGf">视频</a>.</p><h1 id="我的习惯"><a href="#我的习惯" class="headerlink" title="我的习惯"></a>我的习惯</h1><p>同样推荐我日常使用中觉得不错的软件, 其中有的软件需要 Root 权限, 应用建议优先从Google商店&#x2F;F-Droid&#x2F;官网下载, 使用教程找搜索引擎:</p><h2 id="手机应用管理类"><a href="#手机应用管理类" class="headerlink" title="手机应用管理类"></a>手机应用管理类</h2><ol><li>写轮眼MyAndroidTools, 能极大的优化你的手机.</li><li>App Ops, 自动化你的应用权限, 直接忽略读取手机状态、剪贴板、定位, 拒绝设备识别码, 剪贴板监视器 等等 建模板 自动套用.</li><li>黑阈（黑域）, 后台管理.</li><li>绿色守护 Greenify, 后台管理.</li><li>冰箱 IceBox, 冻结应用的App.</li><li>存储重定向&#x2F;存储空间隔离&#x2F;Storage Isolation, 完美解决了手机里各种流氓乱💩的现象, 还&#x2F;stroage0一个清净.</li><li>Isoland, 利用工作空间隔离流氓应用.</li><li>Shelter, 比起Isoland我更推荐这个, 无需root利用工作空间特性隔离那些流氓应用.</li><li>一指禅&#x2F;李跳跳, 一款跳过启动页广告的APP.</li></ol><h2 id="文件管理类"><a href="#文件管理类" class="headerlink" title="文件管理类"></a>文件管理类</h2><ol><li>MT管理器, 功能最多的文件管理器了.</li><li>SolidExplorer 安卓上好看的文件管理器, 支持挂载sftp&#x2F;mega等云服务.</li><li>SD Maid(给root后还可以用来整自启动管理.</li><li>Root Explorer(RE 管理器)</li></ol><h2 id="ROOT管理器-插件模块类"><a href="#ROOT管理器-插件模块类" class="headerlink" title="ROOT管理器&#x2F;插件模块类"></a>ROOT管理器&#x2F;插件模块类</h2><ol><li>Magisk, 现在广为人知的root管理器.</li><li>xposed edge, 很出名的边缘手势的模块, 让你的手机支持全面屏手势.</li></ol><h2 id="客户端模拟器类"><a href="#客户端模拟器类" class="headerlink" title="客户端模拟器类"></a>客户端模拟器类</h2><ol><li>Termux, 是一个Android 下的终端模拟器.</li><li>JuiceSSH, ssh客户端, 也支持telnet或者连接手机的本地shell.</li><li>spacedesk, 可以将任何有屏幕的设备当成显示器.</li></ol><h2 id="阅读类"><a href="#阅读类" class="headerlink" title="阅读类"></a>阅读类</h2><ol><li>ReadEra, (支持众多格式以及完全免费).</li><li>厚墨, 极简设计, 纯粹阅读.无广告, 无推送.</li><li>Wit Reader, 有时候ReadEra乱码我就用这个.</li></ol><h2 id="笔记类"><a href="#笔记类" class="headerlink" title="笔记类"></a>笔记类</h2><ol><li>Joplin, 全平台,多种同步方式, markdown编辑.</li><li>纯纯写作, 绝不丢失文本编辑器.</li></ol><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ol><li>F-Droid, 开源应用的应用商店.</li><li>Telegram sms (用telegram（收短信）.</li><li>VLC（全平台通用的媒体播放器, 主推网络播放, 配好源后甚至可以用它看电视）.</li><li>1dm+, 强大的下载器. (老用户会记得它叫IDM哈)</li><li>Share 微博客户端, 简洁, 轻便, 无广告.</li><li>Luxury QQ, QQ魔改美化包, 采用更前卫的设计理念, 并支持数不清的自定义.</li><li>一个木函&#x2F;WoodBox, 把n多不太常用的功能集合在一个软件而且还能控制在一个极小的体积.</li><li>Tasker, 老牌的自动化软件了, 功能强大, 学习成本高.</li><li>HiPER Calc, 科学计算器, 一般感觉用不到.</li><li>Type Machine, 一个纯粹的输入历史记录工具.</li></ol><h2 id="桌面主题类"><a href="#桌面主题类" class="headerlink" title="桌面主题类"></a>桌面主题类</h2><ol><li>Lawnchair, 原生的桌面软件.</li><li>Substratum, 优质的自定义主题软件.</li></ol><h2 id="备份类"><a href="#备份类" class="headerlink" title="备份类"></a>备份类</h2><ol><li>钛备份, 老牌备份恢复工具.</li><li>Swift Backup, 也是不错的.</li></ol>]]></content>
    
    
    <summary type="html">使用 Android 的指南. 正确使用姿势是什么? 如何隔离流氓应用?</summary>
    
    
    
    
    <category term="Phone" scheme="https://someexp.com/tags/Phone/"/>
    
    <category term="Android" scheme="https://someexp.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Cookie 和 Session</title>
    <link href="https://someexp.com/2021/cookie-and-session/"/>
    <id>https://someexp.com/2021/cookie-and-session/</id>
    <published>2021-03-15T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie, Session, Token, SessionId 到底是什么?</p><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>由于HTTP协议是无状态的, 也就是两次HTTP请求之间是没有任何关联的, 服务器并不知道它上一次处理的请求, 和它下一次处理的请求是否是同一个用户所为, 可能是同一个用户发来的两次HTTP请求, 也可能是两个用户分别发来的HTTP请求.<br>人们为了服务器能分清HTTP请求是否是同一个用户发来的, 使用了不同的手段, 其中比较常用的就是使用Cookie.<br>以Tomcat服务器为例, 当用户1发送请求到服务器时, 服务器判断请求是否允许使用Cookie, 如果允许使用, 那么将会在请求头中返回”Set-Cookie:”+”key”+”value”, 来提示浏览器将对应的”key”+”value”保存到浏览器的Cookie中, 保存成功后, 今后用户1的每一次对这个网站发送请求, 浏览器都会自动携带上保存的Cookie, 这时服务器根据Cookie中的内容, 就能知道这次HTTP请求是哪个用户了. (在Tomcat中, 默认的Cookie的key名是叫”JSESSIONID”)</p><h1 id="SessionId"><a href="#SessionId" class="headerlink" title="SessionId"></a>SessionId</h1><p>对于上面的例子, 我们把Cookie中key为”JSESSIONID”对应的值叫做SessionId. 不同的服务器给用户生成的SessionId不一样, 对应的key名也可能不一样.</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session也就是一次会话, 也就是用户从第一次进入网站, 到关闭了这个页面这段时间就算一次Session. 当然这是抽象的Session. 实际上服务器也有一个叫Session的, 服务器的Session是一块可以保存因会话产生的内容的地方, 它只存在服务器, 不会返回给客户端. 通常SessionId和Session是绑定的关系, 服务器根据SessionId来区分不同用户产生的存在Session中的信息.</p><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>Token通常是服务器颁发给用户端的凭证, 是一个更加抽象名词.</p><h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="服务器颁发给客户端的SessionId是否会重复或冲突"><a href="#服务器颁发给客户端的SessionId是否会重复或冲突" class="headerlink" title="服务器颁发给客户端的SessionId是否会重复或冲突?"></a>服务器颁发给客户端的SessionId是否会重复或冲突?</h2><p>答: 是有可能生成重复的SessionId的, Tomcat8.5.23源代码中org.apache.catalina.session.ManagerBase的generateSessionId方法中, 使用了一个生成SessionId的while循环来确保生成的SessionId没有重复:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generate and return a new session identifier.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new session id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">generateSessionId</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Not thread-safe but if one of multiple increments is lost</span></span><br><span class="line">            <span class="comment">// that is not a big deal since the fact that there was any</span></span><br><span class="line">            <span class="comment">// duplicate is a much bigger issue.</span></span><br><span class="line">            duplicates++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = sessionIdGenerator.generateSessionId();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (sessions.containsKey(result));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么可以把X-CSRF-Token放在Cookie来防止CSRF攻击"><a href="#为什么可以把X-CSRF-Token放在Cookie来防止CSRF攻击" class="headerlink" title="为什么可以把X-CSRF-Token放在Cookie来防止CSRF攻击?"></a>为什么可以把X-CSRF-Token放在Cookie来防止CSRF攻击?</h2><p>答: 假如站点B想要攻击站点A, 虽然跨站攻击触发了站点A相关的请求, 请求中也携带了Cookie的所有内容(浏览器会自动携带), 但是站点B无法读取站点A中的Cookie的内容(浏览器的跨域防御策略). 所以站点A在防止CSRF攻击时, 对一些能够修改服务器资源的请求, 从Cookie中取出对应的X-CSRF-Token放在表单上, 服务器验证表单中的Token和Cookie中的Token是否相同, 如果不同则不是用户主动触发的请求, 如果相同才是合法的请求.</p>]]></content>
    
    
    <summary type="html">Cookie, Session, Token, SessionId 到底是什么?</summary>
    
    
    
    
    <category term="Network" scheme="https://someexp.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 的学习</title>
    <link href="https://someexp.com/2021/mysql-learning/"/>
    <id>https://someexp.com/2021/mysql-learning/</id>
    <published>2021-02-21T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 MySQL 基础, 架构, 事物, 并发, 索引的笔记.</p><span id="more"></span><p>内容主要来自于&lt;高性能 MySQL&gt;. </p><h1 id="MySQL架构和基础"><a href="#MySQL架构和基础" class="headerlink" title="MySQL架构和基础"></a>MySQL架构和基础</h1><h2 id="MySQL逻辑架构图"><a href="#MySQL逻辑架构图" class="headerlink" title="MySQL逻辑架构图"></a>MySQL逻辑架构图</h2><p><img src="/picture/2021-02-22-15-09-11.png"></p><p>大致可分为三层</p><ul><li><strong>连接层</strong>: 不是MySQL独有的, 大部分C&#x2F;S架构都有类似的.</li><li><strong>缓存&#x2F;解析器&#x2F;优化器层</strong>: 大多数核心功能服务在这里, 所有跨存储引擎的存储过程, 触发器, 视图等也在这层.</li><li><strong>存储引擎层</strong>: 服务器层(上面两层)通过API与存储引擎层通信, 这一层不会去解析SQL, 不同存储引擎间也不会相互通信, 只是简单的响应上层服务器的请求.</li></ul><h2 id="缓存-解析-优化与执行"><a href="#缓存-解析-优化与执行" class="headerlink" title="缓存&#x2F;解析&#x2F;优化与执行"></a>缓存&#x2F;解析&#x2F;优化与执行</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>对于SELECT语句在解析之前会先检查查询缓存(Query Cache), 如果能命中缓存服务器就不再执行查询解析, 优化和执行的整个过程.</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>MySQL会解析查询, 创建内部数据结构(解析树), 并对其进行优化(重写查询, 决定表的读写顺序), 选择合适的索引等. </p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>用户可以通过关键字影响优化器的决策进程, 也可以请求优化器解释(explain)它是如何做优化决策的. 优化器通过请求存储引擎提供的信息来做优化. 优化器是存储引擎无关的, 但不同的存储引擎会影响优化器的决策. </p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>可以通过两种类型的锁系统来实现并发控制, 分别是<strong>共享锁</strong>(shared lock)和<strong>排他锁</strong>(exclusive lock), 也叫读锁(read lock)和写锁(write lock). 读锁是共享的, 不会相互阻塞, 在同一时刻可以同时读取同一个资源. 而写锁是排他的, 一个写锁会阻塞其他的读锁和写锁.</p><h3 id="锁粒度与锁策略"><a href="#锁粒度与锁策略" class="headerlink" title="锁粒度与锁策略"></a>锁粒度与锁策略</h3><p>一般锁定的资源数据量越少(锁粒度越小), 那么系统的并发程度就越高. 但是锁的各种操作(获得锁, 检查锁, 释放锁)会消耗时间和资源从而影响系统性能. 锁策略就是在锁的开销和数据的安全性之间寻求平衡. MySQL中两种重要的锁策略:</p><ul><li><strong>表锁</strong>(table lock): MySQL中最基本的开销最小的策略, 写锁能插入到锁队列中的读锁前.</li><li><strong>行级锁</strong>(row lock): 行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销). 行级锁只在存储引擎层实现.</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务并非专属MySQL, 它是构成单一逻辑操作的操作集合.<br>一个良好的事务处理系统必须具备ACID特性.</p><ul><li><strong>原子性</strong>(atomicity): 一个事务必须被视为一个不可分割的最小工作单位.</li><li><strong>一致性</strong>(consistency): 数据库总是从一个一致性(有效正确)的状态转换到另外一个一致性(有效正确)的状态.</li><li><strong>隔离性</strong>(isolation): 并发访问时, 事务之间相互影响的程度.(可以通过修改隔离级别来控制)</li><li><strong>持久性</strong>(durability): 事务提交后修改会永久保存到数据库中.(持久性也分很多种不同级别)</li></ul><p>MySQL中可以根据业务来选择是否需要支持事务的存储引擎.</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>较低级别的隔离通常可以执行更高的并发, 系统的开销也更低.<br>在并发执行事务时通常会遇到下列问题:</p><ul><li><strong>脏读</strong>(dirty read): 事务A读取了事务B修改了但未提交的数据.</li><li><strong>不可重复读</strong>(nonrepeatable read): 事务A读取了数据后, 事务B修改了该数据并提交, 未提交的事务A再次读取同样的数据发现和之前读的时候不一致.</li><li><strong>幻读</strong>(phantom read): 事务A读取了某个范围内的记录, 事务B在该范围内新增了记录并提交, 事务A再次读取该范围记录时就会产生幻行(phantom row).</li></ul><p>为解决上述问题, 就有了隔离级别的概念:</p><ul><li><strong>READ UNCOMMITTED</strong>(未提交读): 事务中的修改即使没有提交对其他事务也是可见的, 因此会导致脏读, 不可重复读, 幻读.</li><li><strong>READ COMMITTED</strong>(提交读): 解决了脏读问题, 但是还会有不可重复读, 幻读的问题. 因此这个级别也叫不可重复读.</li><li><strong>REPEATABLE READ</strong>(可重复读): 解决了脏读和不可重复读的问题, 但是还会有幻读的问题.</li><li><strong>SERIALIZABLE</strong>(可串行化): 最高的隔离级别, 通过强制事务串行化执行, 避免了上述的问题.</li></ul><p>和大多数数据库的默认隔离级别(READ COMMITTED)不一样, MySQL的默认隔离级别是REPEATABLE READ.</p><h3 id="多版本并发控制-MVCC-multiversion-concurrency-control"><a href="#多版本并发控制-MVCC-multiversion-concurrency-control" class="headerlink" title="多版本并发控制(MVCC, multiversion concurrency control)"></a>多版本并发控制(MVCC, multiversion concurrency control)</h3><p>MySQL中不同存储引擎的MVCC实现是不同的, 它可以使大多数读操作不用加锁, 因此开销更低. InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的. 一个保存了行的创建版本号, 一个保存行的删除版本号. 而这个版本号是系统自动递增的事务版本号. 在InnoDB可重复读隔离级别下, MVCC是如何操作的:</p><ul><li>SELECT<ul><li>a.只查找创建标识早于当前事务版本号的行.</li><li>b.行的删除标识未定义, 或者大于当前事务版本号.</li></ul></li><li>INSERT<ul><li>保存当前系统版本号作为创建标识.</li></ul></li><li>DELETE<ul><li>保存当前系统版本号作为删除标识.</li></ul></li><li>UPDATE<ul><li>同时保存当前版本号为创建标识和删除标识.</li></ul></li></ul><p>MVCC只工作在READ COMMITTED和REPEATABLE READ隔离级别下, 因为READ UNCOMMITTED总是读取最新数据, 不符合当前事务版本的数据行. SERIALIZABLE则会对所有行加锁.</p><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p>MySQL InnoDB支持三种锁定方式, 默认加锁方式是next-key lock锁.</p><ul><li><strong>行锁</strong>(Record Lock): 锁直接加在索引记录上, 锁住key.</li><li><strong>间隙锁</strong>(Gap Lock): 锁定索引记录间隙, 确保索引记录的间隙不变.</li><li><strong>Next-Key Lock</strong>: 行锁和间隙锁的组合.</li></ul><p>间隙锁在InnoDB的作用就是防止其他事务的插入操作, 以此来防止幻读的发生. 使用间隙锁的条件:</p><ul><li>1.必须在RR隔离级别下</li><li>2.检索条件必须有索引(全表扫描会锁定整张表)</li></ul><h1 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h1><p>MySQL中索引是在存储引擎层而不是服务器层实现的, 所以相同类型的索引在不同存储引擎下的工作方式可能并不一样. 而InnoDB底层使用的是B+树数据结构来存储数据.</p><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>一般索引没有特殊说明那多半说的就是B-Tree索引了. 但是很多说是用B-Tree数据结构存储数据的实际上用的又是B+Tree, 比如InnoDB, 所以就放在InnoDB说了.</p><h2 id="哈希索引-空间数据索引-全文索引-其他索引类别…"><a href="#哈希索引-空间数据索引-全文索引-其他索引类别…" class="headerlink" title="哈希索引, 空间数据索引, 全文索引, 其他索引类别…"></a>哈希索引, 空间数据索引, 全文索引, 其他索引类别…</h2><p>&#x2F;&#x2F; TODO</p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB使用的是B-Tree索引, 但底层实现使用的是B+Tree数据结构来存储数据.<br>同时InnoDB使用的是聚簇索引的数据存储方式, 具体的底层实现方式是在同一个结构中保存了索引的键(Key)和数据行.</p><h3 id="最小存储单位"><a href="#最小存储单位" class="headerlink" title="最小存储单位"></a>最小存储单位</h3><p>磁盘的基本存储单位是扇区(sector), 一般来说硬盘驱动器(HDD)的一个扇区大小为512字节, 所以基于这种磁盘建立的文件系统或者什么都好, 占用的磁盘空间一定都是512字节的倍数. 比如你在NTFS文件系统中创建一个文件, 打了两个字符进去保存, 然后点开属性你就会发现文件大小是2字节, 但是占用空间确是4K(实际上我自己亲自测试了一下发现并不是这样, 大小是2字节没错可是占用空间是0字节, 这是因为这个文件实在太小了, NTFS直接把数据存在文件元数据中了, 也就是NTFS MFT). 因为这种文件系统的基本存储单位是4K字节, 占用8个扇区. 而InnoDB的最小存储单位叫页(Page), 它默认占用16K字节, 你也可以手动看看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_page_size&#x27;</span>;</span><br></pre></td></tr></table></figure><p>默认输出的值是16384, 是这么多个字节的意思, 16384&#x2F;1024&#x3D;16K.</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>InnoDB的索引底层由树组成, 因此主要有两种节点, 这些节点每个都会占用一页, 一种大概长这样, 是非叶子结点:</p><p><img src="/picture/2021-02-23-11-32-17.png"></p><p>我这画图功夫希望你看得懂… 红色的代表Key, 绿色代表存储指针的地方, 蓝色就代表页了. 一个页除了Key和指针之外还有一些这个页的元数据, 比如页号啊, 用于事务的事务ID, MVCC回滚指针什么的这里没画出来.</p><p>另一种节点是叶子节点, 大概长这样:</p><p><img src="/picture/2021-02-23-11-40-08.png"></p><p>依然是占用一整页, 其中红色代表的是Key, 黄色代表的是数据.</p><p>使用InnoDB创建一张表时, 会默认使用主键创建聚簇索引, 这个通过主键创建的索引树也叫主键索引, 它的叶子节点存储的是整行数据. 我们创建表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people</span><br><span class="line">(</span><br><span class="line">    pel_id           <span class="type">int</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    pel_first_name      <span class="type">char</span>(<span class="number">16</span>),</span><br><span class="line">    pel_last_name     <span class="type">char</span>(<span class="number">16</span>),</span><br><span class="line">    pel_birthday  datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后插入10行数据, 那么通过主键创建的索引(主键索引)大概是长这个样子的(为了便于理解我们这里一个页中只存放3条记录,实际情况可以存放很多):</p><p><img src="/picture/2021-02-23-11-53-05.png"></p><p>(图中的一处错误:叶子节点的指针应该是双向的) 图中红色的代表Key, 黄色是数据字段值, 绿色的正方形小方块代表指针. 可以看到在叶子节点页中, 不仅保存了主键Key, 还保存数据行的所有数据, 术语”聚簇”就是表示数据行和相邻的键值紧凑地存储在一起(并不总是这样). 因此InnoDB的主键索引也可以叫聚簇索引(clustered index). 而非叶子的节点页中只包含了索引列, 这个例子中的索引列是红色的地方, 也就是对应表中的pel_id.</p><h3 id="二级索引-secondary-indexes"><a href="#二级索引-secondary-indexes" class="headerlink" title="二级索引(secondary indexes)"></a>二级索引(secondary indexes)</h3><p>二级索引和聚簇索引差不多, 主要是叶子节点的数据变成了Key+主键, 如果按照上面的例子创建一个由pel_birthday做Key的索引.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX people_pel_birthday_index <span class="keyword">ON</span> people(pel_birthday);</span><br></pre></td></tr></table></figure><p>那么树大概长这个样子:</p><p><img src="/picture/2021-02-23-12-30-45.png"></p><p>(图中的一处错误:叶子节点的指针应该是双向的) 可以看到这个二级索引叶子节点的数据实际上是主键值, 因此如果主键值过大, 那么索引占用的空间就大. 要是想获取行的其它数据还要通过这个主键再回主键索引中查询, 这个步骤称作回表.</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>这个不是InnoDB特有的, 这是满足某种情况我们就说索引覆盖. 如果一个索引包含了所有需要查询字段的值, 那么就无需回表, 这就是覆盖索引. 如果WHERE条件中的列是有索引可以覆盖, 那么可以使用延迟关联的策略来尽可能利用索引.(延迟覆盖简单来说就是利用WHERE条件中能被索引覆盖的条件查出对应的主键, 再使用这些主键从主键索引做连接查询过滤等, 提高效率)</p><p>&#x2F;&#x2F; todo:可预测性读, 自适应哈希, 插入缓冲区…</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>和InnoDB不同, MyISAM的主键索引和二级索引数据分布则要简单得多.</p><h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><p>MyISAM是按照数据插入的顺序存储在磁盘上, 同样以上面的表为例子, 假设我把上面InnoDB的数据dump出来然后随机插入到MyISAM引擎的表, 那么插进去的数据在MyISAM的分布方式是这样的:</p><p><img src="/picture/2021-02-23-17-35-42.png"></p><p>在行的旁边显示了行号(或者说是地址), 从0开始递增. 它会根据数据定长还是变长的行使用不同的策略来跳过行号.</p><h3 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM索引的叶子节点存放的是数据的行号(或者说是地址). 在索引找到行号(或者说是地址)后, 就会到数据分布中取出对应的记录.</p><p><img src="/picture/2021-02-23-17-50-17.png"></p><p>(图中的一处错误:叶子节点的指针应该是双向的) </p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>MyISAM的其它索引和主键索引大同小异. 比如使用pel_birthday做索引:</p><p><img src="/picture/2021-02-23-17-55-18.png"></p><p>(图中的一处错误:叶子节点的指针应该是双向的) </p><p>可以看到和主键索引一样, 叶子节点保存的也是数据的行号.</p><h2 id="InnoDB和MyISAM数据和索引区别"><a href="#InnoDB和MyISAM数据和索引区别" class="headerlink" title="InnoDB和MyISAM数据和索引区别"></a>InnoDB和MyISAM数据和索引区别</h2><p>高性能MySQL(第3版)中作者画了一张抽象图来描述.</p><p><img src="/picture/2021-02-23-18-01-16.webp"></p><p>图就比较直观了.</p><p>上面只用了单键值的索引做例子, 而多键值的索引大概是这样子的:</p><p><img src="/picture/2021-02-23-18-21-32.png"></p><p>index (a,b)的联合索引结构如上图(出自《MySQL技术内幕-InnoDB存储引擎》), 观察到每个节点中均同时包含a,b两个字段信息, 且字段a全局有序, 字段b局部有序(仅在字段a值相同时, 字段b是有序的).</p><h1 id="MySQL执行计划Extra"><a href="#MySQL执行计划Extra" class="headerlink" title="MySQL执行计划Extra"></a>MySQL执行计划Extra</h1><ul><li><strong>Using index</strong>: 查询的列被索引覆盖, 并且WHERE筛选条件是索引的前导列.</li><li><strong>Using where Using index</strong>: 查询的列被索引覆盖, 并且WHERE筛选条件是索引列之一, 可能不是索引的前导列. 这里的Using where代表使用了过滤，跟是否回表没有关系. 索引列的范围搜索也会出现它.</li><li><strong>Using index condition</strong>: 查询的列不全在索引中, 查询条件可以用到索引.(这个需要开启索引条件下推(ICP, Index-Condition-Pushdown)功能才有)</li></ul><p>参考:<br>高性能MySQL(第3版)<br><a href="https://cloud.tencent.com/developer/article/1443681">面试题：InnoDB中一棵B+树能存多少行数据？</a><br><a href="https://www.percona.com/blog/2019/05/08/mysql-innodb-sorted-index-builds/">MySQL InnoDB Sorted Index Builds</a><br><a href="https://fivezh.github.io/2020/01/19/mysql-icp/?utm_source=tuicool&utm_medium=referral">MySQL索引下推</a></p>]]></content>
    
    
    <summary type="html">关于 MySQL 基础, 架构, 事物, 并发, 索引的笔记.</summary>
    
    
    
    
    <category term="MySQL" scheme="https://someexp.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Servlet 中的 Filter</title>
    <link href="https://someexp.com/2021/servlet-filter/"/>
    <id>https://someexp.com/2021/servlet-filter/</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些 Tomcat 容器中常见的 Filter 和作用.</p><span id="more"></span><p>在Web容器中, Filter的作用是在访问特定资源前或后执行一些操作, 比如判断是否允许访问. </p><p>javax.servlet.Filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用于初始化过滤器, FilterConfig接口是过滤器的配置信息和初始配置参数的封装.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行过滤器的代码, 参数request, response为容器传入的请求与响应. </span></span><br><span class="line"><span class="comment">    FilterChain为一个特殊接口, 用于提醒容器是否继续执行, 如果过滤器内调用了</span></span><br><span class="line"><span class="comment">    FilterChain.doFilter(), 意思是提醒容器执行下一个过滤器, 如果没有下一个过滤器则</span></span><br><span class="line"><span class="comment">    执行对应的Servlet方法或者资源.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在容器卸载Filter之前调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml注册filter:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFitler<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器类路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.test.TestFiter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>word_file<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/word.txt<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在web.xml映射filter:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>testFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对不同的调用方式进行拦截, 可以配置多个dispatcher --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- REQUEST为默认值, 对进行拦截, 也就是一次请求. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- INCLUDE表示处理调用的Servlet包含另一个Servlet. 如jsp多页面include. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- FORWARD表示处理FORWARD转发的请求 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ERROR对配置的&lt;error-page&gt;起作用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常应用都会配置多个Filter, 这些Filter组合起来就称之为FilterChain, Tomcat容器会根据Filter在web.xml文件中配置的顺序来决定先调用哪个. Filter会调用FilterChain.doFilter()来表示提示容器执行下一个过滤器, 如果是最后一个过滤器执行时容器会调用目标资源.</p><p><img src="/picture/2021-02-20-12-35-51.png"></p><p>javax.servlet.GenericFilter对Filter获取配置或环境信息做了一个通用的实现.<br>javax.servlet.http.HttpFilter继承GenericFilter对请求和响应是否是http请求做了判断.</p><h2 id="Tomcat容器中的Filter"><a href="#Tomcat容器中的Filter" class="headerlink" title="Tomcat容器中的Filter"></a>Tomcat容器中的Filter</h2><p>而Tomcat容器默认也提供了一些过滤器:</p><ul><li>AddDefaultCharsetFilter: HTTP规范指出如果没有指定”text”的字符集, 那么会默认使用”ISO-8859-1”字符集. 但有的浏览器会试图自动检测字符集, 这种行为容易被XSS.</li><li>CorsFilter: 该过滤器是W3C的CORS(跨域资源共享)规范的实现, 这是一个跨域请求机制.</li><li>CsrfPreventionFilter: 该过滤器通过产生一个随机数并将其存储在session和URL中, 接收到下一个请求时将随机数进行比较, 如果是相同的就允许继续请求.</li><li>ExpiresFilter: 设置浏览器缓存.</li><li>FailedRequestFilter: 触发检查解析请求的参数, 如果有参数解析失败, 那么就返回400.</li><li>HttpHeaderSecurityFilter: 设置该头来提醒浏览器不要做怪异行为. (比如MIME类型嗅探)</li><li>RemoteAddrFilter: 根据客户端IP地址来过滤.</li><li>RemoteCIDRFilter: CIDR好像是一种网络的表示方法.</li><li>RemoteHostFilter: 根据客户端主机名是否符合指定正则表达式.</li><li>RemoteIpFilter: 获取原始客户端IP的过滤器.</li><li>RequestDumperFilter: 从请求中获取详细信息, 方便调试.</li><li>RestCsrfPreventionFilter: 提供基本的对REST API的CSRF保护.</li><li>SessionInitializerFilter: 通过HttpServletRequest来初始化HttpSession, 在一些WebSocket项目上可能需要.</li><li>SetCharacterEncodingFilter: 字符集编码过滤器, 通常在解析请求前使用来强制指定编码.</li><li>WebdavFixFilter: 修复与微软的WebDAV客户端连接的过滤器.</li></ul><p>参考:<br><a href="https://blog.csdn.net/u013087513/article/details/56835894">JAVAWEB开发之Servlet Filter（过滤器）详解包括post和get编码过滤器、URL访问权限控制、自动登录。以及装饰模式的使用</a><br><a href="https://blog.csdn.net/xiaokang123456kao/article/details/72885171">filter中的dispatcher标签解析</a><br><a href="https://blog.csdn.net/weixin_34307464/article/details/92591041">tomcat容器提供的过滤器Filters【译】</a><br><a href="https://www.cnblogs.com/jian0110/p/10512188.html">Tomcat常用的过滤器</a><br><a href="https://blog.csdn.net/myle69/article/details/83747018">利用 HTTP Security Headers 提升站点安全性</a></p>]]></content>
    
    
    <summary type="html">记录一些 Tomcat 容器中常见的 Filter 和作用.</summary>
    
    
    
    
    <category term="Java" scheme="https://someexp.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机相关书单</title>
    <link href="https://someexp.com/2021/books-about-computer-science/"/>
    <id>https://someexp.com/2021/books-about-computer-science/</id>
    <published>2020-12-31T16:00:00.000Z</published>
    <updated>2022-10-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机相关的书单, 非计算机类的书单请请看<a href="/2020/the-book-i-read">这里这里</a>. </p><span id="more"></span><p><strong>2024:</strong></p><p><a href="/book/designing-data-intensive-applications">数据密集型应用系统设计 笔记</a></p><p><strong>2023:</strong></p><p><a href="/book/the-go-programming-language">Go语言圣经 笔记</a></p><p><strong>2022:</strong></p><p><a href="/book/9787115424914">图解密码学技术 笔记</a></p><p><a href="/book/java-concurrency-in-practice">Java并发编程实战 笔记</a></p><p><strong>2021:</strong></p><p><a href="/book/csapp">深入理解计算机系统 笔记</a></p><p><a href="/book/the-art-of-readable-code">编写可读代码的艺术 笔记</a></p><p><a href="/book/9787115318978">图解 TCP&#x2F;IP 笔记</a></p><p><a href="/book/9787115351531">图解 HTTP 笔记</a></p><p><a href="/book/the-design-and-implementation-of-redis">Redis 设计与实现 笔记</a></p><p><a href="/book/hight-performance-mysql">高性能MySQL-第3版 笔记</a></p><p><a href="/book/mysql-crash-course">MySQL必知必会 笔记</a></p><p><a href="/book/sams-teach-yourself-sql-in-10-minutes">SQL必知必会-中文-第4版 笔记</a></p><p><strong>2020:</strong></p><p><a href="/2020/spring-learning">Spring技术内幕：深入解析Spring框架相关笔记</a></p><p><a href="/2020/basic-computer-network/">计算机网络-自顶向下方法(中文第六版) 笔记</a></p><p><a href="https://github.com/thesomeexp/DesignPatternLearning">软件秘笈-设计模式那点事-代码笔记</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机相关的书单, 非计算机类的书单请请看&lt;a href=&quot;/2020/the-book-i-read&quot;&gt;这里这里&lt;/a&gt;. &lt;/p&gt;</summary>
    
    
    
    
    <category term="Book" scheme="https://someexp.com/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>2020年年度小结</title>
    <link href="https://someexp.com/2020/annual-summary/"/>
    <id>https://someexp.com/2020/annual-summary/</id>
    <published>2020-12-29T16:00:00.000Z</published>
    <updated>2020-12-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2020这年我在想些什么呢? </p><span id="more"></span><p>2020即将过去了, 今年是特殊的一年, 因为疫情原因整个学期都在家里上直播课, 给了我在床上睡着上课以及一边做饭一边上课的体验. 那三个月我在家一个人做4-5个人的饭菜, 并觉得每天煮饭洗菜做菜洗碗特别花时间, 以后一定要想办法尽量缩短这些无意义时间的浪费. 一直到4月份我终于可以回学校上课了, 不过此时其实很多学校都还是不让学生回校的, 学了三四个月的框架知识, 然后8月份找实习, 当时海投, 面了一家感觉还行吧通过面试就去了, 不过其实应该多面一下的. 最后是在公司的三个月公司每个人都很好, 只是自己厌倦了工作无聊的劳动, 11月中旬做够三个月后就回学校玩了, 到最后决定备战明年考研(好吧, 还是工作吧, 毕竟条条大路通罗马).<br>这一年跟以前所有我度过的年都不一样, 因为大部分时间都是宅在家里, 少了很多跟人同学亲戚接触的机会, 所以就少了很多故事, 就觉得这一年过得特别快, 白过了一样. 但幸运的是这样也多了很多思考的空间, 今年也是我看书最多的一年, 并开始重新审视情感和锻炼问题. 后来<a href="https://vincent1q84.github.io/">老大</a>给我分享Pavel Durov的文章<a href="https://telegra.ph/Consume-Less-Create-More-Its-More-Fun-12-04">Consume Less. Create More. It’s More Fun.</a>, 让我从中得到一些灵感, 所以今年最重要的一个议题是, 我们真的理所当然需要这些东西吗? 比方说我们要减肥健身, 我们真的需要去健身房吗? (这也是 无器械健身作者马克·劳伦的观点, 其实并不需要) 我们学习, 真的要报名网课吗? 我们为了健康真的需要吃各种各样的保健品吗? 所以今年年底, 我开始对自己问这些问题, 当我需要购买很昂贵的物品时, 我会询问自己, 我们真的需要买这个才能好好的活着吗? 很多时候价格决定商品品质这毋容置疑, 但有时候是否真的一定要花费这么多钱呢? 于是我请教了实习薪资一个月只有200的医学生问他们是怎么生活的, 结果就是他们能用很便宜的价格买到很好的东西, 很多东西根本不需要话这么多钱, 生活其实可以很简单. 这绝对是今年最震撼我的事, 于是今后我每每做决策时一定要问问我自己, 我真的要这样才能那样吗? </p>]]></content>
    
    
    <summary type="html">2020这年我在想些什么呢?</summary>
    
    
    
    
    <category term="Essay" scheme="https://someexp.com/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>Maven 笔记</title>
    <link href="https://someexp.com/2020/maven-notes/"/>
    <id>https://someexp.com/2020/maven-notes/</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 笔记. </p><span id="more"></span><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><h3 id="1-1-约定"><a href="#1-1-约定" class="headerlink" title="1.1 约定"></a>1.1 约定</h3><p>Maven其实就是约定了项目的一些结构: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├─src</span><br><span class="line">│  ├─main</span><br><span class="line">│  │  ├─java  主程序的java文件</span><br><span class="line">│  │  └─resources  配置文件</span><br><span class="line">│  ├─test</span><br><span class="line">│  │  ├─java  测试程序代码</span><br><span class="line">│  │  └─resources  测试使用的配置</span><br><span class="line">└─pom.xml</span><br></pre></td></tr></table></figure><h3 id="1-2-坐标-gav"><a href="#1-2-坐标-gav" class="headerlink" title="1.2 坐标(gav)"></a>1.2 坐标(gav)</h3><p>用于唯一定义一个Maven项目的, 主要由: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;&lt;/groupId&gt;  组织名, 通常是公司或组织域名倒序+项目名</span><br><span class="line">&lt;artifactId&gt;&lt;/artifactId&gt;  模块名, 通常是工程名</span><br><span class="line">&lt;version&gt;&lt;/version&gt;  版本号</span><br></pre></td></tr></table></figure><p>三部分组成. </p><h3 id="1-3-依赖-dependency"><a href="#1-3-依赖-dependency" class="headerlink" title="1.3 依赖(dependency)"></a>1.3 依赖(dependency)</h3><p>想要导入相关的依赖包, 在pom.xml添加对应依赖的坐标:<br>比如导入gson的依赖: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.8.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-仓库-Repository"><a href="#1-4-仓库-Repository" class="headerlink" title="1.4 仓库(Repository)"></a>1.4 仓库(Repository)</h3><p>存放jar包, Maven插件(其实也就是jar包)等的地方. 有本地仓库, 中央仓库, 私服等区分. </p><h3 id="1-5-命令"><a href="#1-5-命令" class="headerlink" title="1.5 命令"></a>1.5 命令</h3><p>通过命令完成项目的构建. </p><ul><li>mvn clean: 清理target目录</li><li>mvn compile: 编译程序后放到target目录中</li><li>mvn test: 单元测试, 使用junit测试src&#x2F;main&#x2F;java目录中的程序是否符合要求</li><li>mvn package: 打包, 一般打包成jar或者war</li><li>mvn install: 把jar, war安装到本机仓库中</li></ul><h3 id="1-6-生命周期"><a href="#1-6-生命周期" class="headerlink" title="1.6 生命周期"></a>1.6 生命周期</h3><p>一个典型的Maven构建(build)生命周期的阶段:<br>validate -&gt; compile -&gt; test -&gt; package -&gt; verify -&gt; install -&gt; deploy<br>一般直接执行后面的插件, 前面的生命周期也会被执行. </p><h3 id="1-7-依赖范围"><a href="#1-7-依赖范围" class="headerlink" title="1.7 依赖范围"></a>1.7 依赖范围</h3><p>dependency可以设置scope标签, 为其依赖范围: </p><ul><li>compile: 默认范围, 也就是程序每个生命周期都需要. </li><li>test: 只在测试过程(test)中起作用的依赖. </li><li>provided: 提供者, 在编译测试时需要, 但是打包(package)安装(install)时不需要(比如说我要部署到tomcat, 这时servlet相关依赖可以不用, 因为环境提供了).</li></ul><h3 id="1-8-常用属性"><a href="#1-8-常用属性" class="headerlink" title="1.8 常用属性"></a>1.8 常用属性</h3><p>当一些依赖版本号类似时, 可以提取出来作为全局的属性. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;spring.version&gt;5.2.0&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-9-资源插件"><a href="#1-9-资源插件" class="headerlink" title="1.9 资源插件"></a>1.9 资源插件</h3><p>默认情况下mvn compile命令会把src&#x2F;main&#x2F;resources下的文件拷贝到target&#x2F;classes目录中, 对于src&#x2F;main&#x2F;java目录下的非.java文件不做处理. 如果需要处理就需要使用相关的插件. </p>]]></content>
    
    
    <summary type="html">Maven 笔记.</summary>
    
    
    
    
    <category term="Java" scheme="https://someexp.com/tags/Java/"/>
    
    <category term="Maven" scheme="https://someexp.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="https://someexp.com/2020/basic-computer-network/"/>
    <id>https://someexp.com/2020/basic-computer-network/</id>
    <published>2020-10-30T16:00:00.000Z</published>
    <updated>2024-11-06T09:51:55.423Z</updated>
    
    <content type="html"><![CDATA[<p>记录计算机网络学习的笔记. </p><span id="more"></span><h1 id="1-计算机网络和因特网"><a href="#1-计算机网络和因特网" class="headerlink" title="1. 计算机网络和因特网"></a>1. 计算机网络和因特网</h1><p>互联网是一个连接了全世界数以亿计的计算设备的网络. 以前这些计算设备通常是传统的桌面PC, Linux工作站或者说是服务器(用于提供存储传输Web页面和电子邮件等信息). 而现在越来越多非传统的因特网设备和因特网相连(如手机, 平板, 相机, 汽车等). 所有这些设备都称为主机(host)或端系统(end system). </p><p><img src="/picture/2020-10-31-17-32-02.jpg"></p><p>端系统通过通信链路(communication link)和分组交换机(packet switch)连接到一起. </p><ul><li>通讯链路: 可能是同轴电缆, 铜线, 光纤等, 不同链路提供不同的速率. </li><li>分组交换机: 可能是路由器(router), 链路交换机(link-layer switch)等.</li></ul><p>当一台端系统向另一台端系统发送数据时, 发送端会把数据分段, 为每段加上首部字节, 形成数据包分组(packet, 也叫数据包), 然后分组交换机就负责将这些分组, 向着它们需要到达的地方转发传输. </p><h2 id="1-1-网络的核心部分"><a href="#1-1-网络的核心部分" class="headerlink" title="1.1 网络的核心部分"></a>1.1 网络的核心部分</h2><p>在应用层中, 端系统之间彼此交换的是<strong>报文</strong>(message), 报文中包含协议设计者需要的任何东西. 可以理解成不同的内容, 比如可以执行的内容, 也可以是数据(电子邮件数据, JPEG图像或者是音频等). 为了能移动这些报文(也就是数据), 通过网络链路和交换机来实现有两种基本方法. </p><ul><li>分组交换(packet switching)</li><li>电路交换(circuit switching)</li></ul><p>下面就只讲用得比较多的的分组交换: </p><h3 id="1-1-1-分组交换"><a href="#1-1-1-分组交换" class="headerlink" title="1.1.1 分组交换"></a>1.1.1 分组交换</h3><p>分组交换会将长报文划分为较小的数据块, 称之为<strong>分组</strong>(packet). 多数分组交换机在链路的输入端采用<strong>存储转发传输机制</strong>(store-and-forward transmission). 简单来说就是分组交换机在转发一个分组之前, 需要从上游接收并缓存整个分组. 对于每个分组交换机, 它有多条输出链路, 也就是转发到下一跳, 对于每条输出链路分组交换机会有一个<strong>输出缓存</strong>(output buffer) (也叫<strong>输出队列</strong>output queue). </p><p><img src="/picture/2020-10-31-19-58-42.png"></p><p>缓存队列是在路由器内的, 图中为了展示它所以画在了外面. 图中蓝色小方块为一个分组(packet), 红色的为丢失的分组.<br>如果到达的分组需要传输到某条链路, 但发现链路正忙于传输其他分组, 那么到达分组需要在输出缓存中等待, 如果缓存满了那么就会出现分组丢失(<strong>丢包</strong>, 也就是图中红色的小方块). 到达的分组或者排队中的分组之一会被丢弃.<br>因此数据传输过程中除了<strong>存储转发时延</strong>以外, 分组还要承受输出缓存的<strong>排队时延</strong>(queue delay). </p><p>那路由器是怎么知道分组要转发给哪个路由呢? </p><p>不同计算机网络是使用不同的方式完成的, 下面就简要说一下因特网中采用的方法.<br>在因特网中每个端系统具有一个<strong>IP地址</strong>, 报文划分为分组时, 分组的首部就包含了目的地的IP地址. 当一个分组到达网络中的路由器时, 路由器会检查该分组的目的地址, 将该地址与路由器自身维护的<strong>转发表</strong>(forwarding table)对照查询, 查询到适当的输出链路, 那么路由器就会将该分组导向该出链路.<br>至于转发表是怎么来的, 作者说后面再说. 总之因特网具有一些特殊的<strong>路由选择协议</strong>(routing protocol)用于自动设置这些转发表. </p><h2 id="1-2-分组交换的时延"><a href="#1-2-分组交换的时延" class="headerlink" title="1.2 分组交换的时延"></a>1.2 分组交换的时延</h2><p>分组从一个结点沿路到后继节点过程中, 它在每个结点都经受了几种不同类型的时延. 其中最重要的为: </p><ul><li>结点处理时延(nodal processing delay): 检查比特级别的差错需要的时间, 检查首部以及决定将该分组导向何处需要的时间. </li><li>排队时延(queuing delay): 取决于先到达的正在排队的分组数量. </li><li>传输时延(transmission delay): 取决于分组的长度以及链路的传输速率. </li><li>传播时延(propagation delay): 取决于链路的物理媒体(光纤, 双绞铜线等). 也与链路的长度有关.</li></ul><h1 id="1A-体系结构"><a href="#1A-体系结构" class="headerlink" title="1A 体系结构"></a>1A 体系结构</h1><h2 id="1A-1-结构模型"><a href="#1A-1-结构模型" class="headerlink" title="1A.1 结构模型"></a>1A.1 结构模型</h2><p>首先是OSI和TCP&#x2F;IP的分层模型和对应关系: </p><p><img src="/picture/2020-10-30-23-59-13.jpg"></p><p>OSI参考模型一共分7层, 一般用于教学, 实际使用更多的是TCP&#x2F;IP的5层模型. 5层体系模型为: </p><ul><li><strong>应用层</strong>: 网络应用程序以及他们的应用层协议留存的地方. (如: HTTP提供Web文档请求和传送; SMTP提供电子邮件报文的传输; FTP提供两个端系统间文件传送; DNS域名解析系统等) 位于应用层的信息分组称为<strong>报文</strong>(message). </li><li><strong>运输层</strong>: 因特网的运输层在应用程序端点之间传送应用层报文. 因特网中有TCP和UDP这两种协议. TCP向应用程序提供了面向连接的服务, 包括应用层报文确保传递和流量控制机制, 会将长报文划分为短报文, 并提供拥塞控制机制. UDP面向无连接, 上面TCP有的它没有. 位于运输层的分组称为<strong>报文段</strong>(segment). </li><li><strong>网络层</strong>: 负责将称为<strong>数据报</strong>(datagram)的网络分组从一台主机移动到另一台. 上一层运输层会给网络层提供 报文段 和 目的地址 . 这一层包括著名的IP协议与许多路由选择协议, 但通常也会被称为IP层. </li><li><strong>链路层</strong>: 链路层负责将数据报传递给下一个结点. 它提供的服务取决于应用于该链路层的特定链路协议. 比如某些协议基于链路提供可靠传递, 但是这种可靠传递不同于TCP的端系统对端系统的可靠交付, 而是包括以太网, WiFi和电缆接入网的DOCSIS协议. 因为数据报从源到目的地传送通常需要经过几条链路, 所以一个数据报可能被沿途不同链路上的不同链路层协议处理. 链路层的分组称为<strong>帧</strong>(frame). </li><li><strong>物理层</strong>: 物理层的任务是将帧中的一个个<strong>比特</strong>从一个结点移动到下一结点. 这一层中的协议仍是链路相关的, 并且进一步与该层链路(例如: 双绞铜线, 单模光纤)的实际传输媒体相关. 比如: 以太网就有许多物理层协议, 有基于双绞铜线的, 有基于同轴电缆的, 还有基于光纤的… 在每种场合, 跨越这些链路移动一个比特是以不同的方式进行的.</li></ul><p>作者举的快递的例子非常容易理解: 我们在网上买东西, 首先确定自己所在的位置有相应的快递网点, 这个网点就相当于网络接入层, 然后需要告诉卖家地址, 这个地址相当网际互联层, 快递送货相当于传输层, 最后我们收到货物之后拆包使用相当于应用层.<br>而在BS结构中, TCP&#x2F;IP模型中的网络接入层没有相应协议, 网际互联层是IP协议, 传输层是TCP协议. </p><p>我们来看一下这套结构模型在实际中是怎么运作的: </p><p><img src="/picture/2020-10-31-13-05-39.webp"></p><p>可以看到用户A发送的数据, 经过一层一层<strong>封装</strong>(encapsulation)后发送到用户B的电脑, 然后再一层一层的拆开, 最终用户B得到用户A发送的消息, 这就是模型基本运作的样子. </p><h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-应用层原理"><a href="#2-1-应用层原理" class="headerlink" title="2.1 应用层原理"></a>2.1 应用层原理</h2><p>网络应用程序的体系结构大致可以分为: </p><ul><li>CS结构(client-server architecture): 由一个或多个客户端, 以及一个或多个服务端组成. </li><li>P2P结构(P2P architecture): 每终端都是客户端和服务端.</li></ul><p>下图展示了两个端系统应用层之间是如何通讯的:<br><img src="/picture/2020-11-01-16-05-14.jpg"></p><p>从一个端系统的进程向另外一个端系统的进程, 进程通过一个叫<strong>套接字</strong>(socket)的软件接口向网络发送报文和接收报文, 套接字是同一台主机内应用层与运输层之间的接口. 应用程序的开发者可以控制套接字在应用层端的一切, 但是对于该套接字的运输层端几乎没有控制权. 所以开发者对运输层的控制仅限于<strong>选择运输层协议</strong>或<strong>设定几个运输参数</strong>. </p><p>在因特网中, 主机由其<strong>IP地址</strong>(IP address)标识, 而接收进程由目的地<strong>端口号</strong>(port number)标识. 一般主机都给流行的应用分配了特定的端口号, 比如Web服务器用端口号80来标识, 邮件服务进程(使用SMTP协议)用端口号25来标识.</p><p>而在套接字另一侧是运输层协议负责把该报文传入接收进程的套接字. (如TCP&#x2F;UDP协议等)<br><strong>注:<strong>而无论TCP还是UDP都没有提供任何加密机制, 也就是传进套接字的数据, 跟到达目的地进程的数据是一样的. 意思就是如果中途链路有人嗅探, 那么他能看到传输的数据. 因此为了隐私和其他安全问题现在已经研制了加强版</strong>安全套接字层</strong>(Secure Sockets Layer, SSL). 它能提供进程到进程的安全性服务, 但它和TCP和UDP不在同一个层次上, 它是对TCP的加强, 这种强化是在应用层实现的. </p><h2 id="2-2-应用层协议-application-layer-protocol"><a href="#2-2-应用层协议-application-layer-protocol" class="headerlink" title="2.2 应用层协议(application-layer protocol)"></a>2.2 应用层协议(application-layer protocol)</h2><p>应用层协议定义了不同端系统上的应用程序进程如何相互传递报文. 比如报文类型, 报文语法, 字段语义, 何时如何发送等. </p><h3 id="2-2-1-Web和HTTP"><a href="#2-2-1-Web和HTTP" class="headerlink" title="2.2.1 Web和HTTP"></a>2.2.1 Web和HTTP</h3><p>Web的应用层协议是<strong>超文本传输协议</strong>(HyperText Transfer Protocol, HTTP). Web页面(Web page)(也叫文档)是由<strong>对象</strong>(object)组成的, 如一个HTML文件, 一个JPEG图形, 一个Java小程序这样的文件就是对象. 多数Web页面含有一个HTML基本文件(base HTML file)以及几个引用对象. 例如一个Web页面包含HTML文本和5个JPEG图形, 那么这个Web页面就有6个对象. 而<strong>Web浏览器</strong>(Web browser)实现了HTTP客户端, <strong>Web服务器</strong>(Web server)实现了HTTP的服务器端. 服务器向用户发送被客户端请求的资源, 假设一个用户在短短几秒钟内两次请求同一个对象, 但是服务器并不会因为刚刚给用户发送了它就不发送了, 而是和第一次请求时一样重新发送资源, 就好像服务器不记得之前做过这件事情一样. 因为HTTP服务器不会保存用户的相关信息, 所以我们说HTTP是一个<strong>无状态协议</strong>(stateless protocol). </p><p>我们都知道HTTP协议作为应用层的协议, 他在发送请求和接收报文时会使用传输层的TCP协议, 而TCP协议在建立连接时是需要进行”三次握手”的. 而在很多因特网应用程序中, 客户在一台服务器上停留的时间是比较久的, 如果客户的每一次请求和响应都需要经历”三次握手”, 那会消耗公用的网络资源. 所以就有请求和响应在一次TCP连接中完成, 而不是每次请求和响应都要建立一次TCP连接. 这就是<strong>持续性连接</strong>(persistent connection)和<strong>非持续性连接</strong>(non-persistent connection)的区别. </p><p>HTTP请求报文<br>下面是一个典型的HTTP请求报文: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/l.l</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/5.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure><p>它的第一行叫做<strong>请求行</strong>(request line), 其后继的行叫做<strong>首部行</strong>(header line).<br>请求行: </p><ul><li>第一个字段是请求方法字段, HTTP1.0包括GET, POST, HEAD; HTTP1.1新增了, OPTIONS, PUT, PATCH, DELETE, TRACE, CONNECT. </li><li>第二个字段是URL字段. 统一资源定位符. </li><li>第三个字段是HTTP版本字段.</li></ul><p>首部行: </p><ul><li>Host: 指明主机, 用于Web代理高速缓存. </li><li>Connection: close. 这一行表示不希望用持续性连接, 要求服务器发送完被请求对象后就关闭连接. </li><li>User-agent: 指明用户代理, 发送请求的浏览器类型. </li><li>Accept-language: 用户想得到该对象的什么语言的版本(如果服务器支持的话).</li></ul><p>下图是请求报文通用格式, 如果是GET方法时实体主体为空, 如果是POST就可以包含实体主体. 而GET可以在URL中用?带参.<br><img src="/picture/2020-11-01-23-13-44.jpg"></p><p>下面是典型的HTTP响应报文: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Tue , 09 Aug 2011 15:44:04 GMT</span><br><span class="line">Server: Apache/2.2.3 (CentOS)</span><br><span class="line">Last-Modified: Tue , 09 Aug 2011 15:11:03 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br><span class="line">(data data data data data ...)</span><br></pre></td></tr></table></figure><p>它由三个部分组成: 一个初始<strong>状态行</strong>(status line), 6个<strong>首部行</strong>(header line), 然后是<strong>实体体</strong>(entity body).<br>状态行: </p><ul><li>第一个字段是协议版本</li><li>第二个字段是状态码</li><li>第三个字段是相应状态信息</li></ul><p>首部行: </p><ul><li>Connection: close. 告诉客户, 发送完报文后将关闭该TCP连接. </li><li>Date: 服务器产生并发送该相应报文的日期和时间. (是检索到对象, 插入到报文, 并发送该响应报文的时间)</li><li>Server: 类似于HTTP请求中的User-agent, 表明是什么服务器产生的. </li><li>Last-Modified: 对本地客户或者网络缓存服务器上的对象缓存有用. </li><li>Content-Length: 被发送对象中的字节数. </li><li>Content-Type: 对象类型.</li></ul><p><img src="/picture/2020-11-01-23-35-08.jpg"></p><p>那么用户是如何与服务器交互的呢? </p><p>这里就要用到<strong>cookie</strong>了, cookie技术有4个组件: </p><ul><li>在HTTP响应报文中的一个cookie首部行. </li><li>在HTTP请求报文中的一个cookie首部行. </li><li>在用户端系统中保留有一个cookie文件, 并由用户的浏览器进行管理</li><li>位于Web站点的一个后端数据库</li></ul><p>简单来说这种技术允许服务器追踪并记录这个客户, 因为客户端和服务端都遵循HTTP协议, 只要服务端设置了cookie, 而且这个cookie没有过有效期, 那么客户端每次访问对应的服务端都会携带这个cookie, 因此服务器就会知道你访问过哪些内容, 但此时服务器并不知道你是谁(只要你没登录或者没其它证明你身份的操作), 它只认得cookie, 只要cookie存的值足够特别, 服务器就能唯一标识这个用户. 而只有在你登录了服务器后服务器将cookie与你绑定, 它才知道你是谁. </p><p>尽管cookie能简化用户的互联网购物活动, 但是它的使用仍然有争议, 因为他们被认为是对用户隐私的一种侵害. 比如结合cookie和用户提供的账户信息, Web站点可以知道很多用户的信息, 并且可能将这些信息卖给第三方. cookie也分为第一方cookie与第三方cookie等, 这就涉及到定向广告相关的内容了. </p><p><strong>Web缓存器</strong>(Web cache)也叫<strong>代理服务器</strong>(proxy server), 它可以大大减少客户对请求的响应时间, 特别是客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽.<br><img src="/picture/2020-11-01-23-52-11.jpg"></p><p>通过<strong>内容分发网络</strong>(Content Distribution Network, CDN), Web缓存器在因特网中发挥着越来越重要的作用.<br>Web缓存器给初始服务器发送的<strong>条件GET方法</strong>(conditional GET)的首部行包含一个” If-Modified -Since :”, 如果资源对象没有被修改那么返回空对象的响应, 否则返回修改后的对象和日期. 它给判断缓存中的内容是否是陈旧的行为提高了效率. </p><h3 id="2-2-2-文件传输协议-FTP"><a href="#2-2-2-文件传输协议-FTP" class="headerlink" title="2.2.2 文件传输协议:FTP"></a>2.2.2 文件传输协议:FTP</h3><p>FTP使用了两个并行的TCP连接来传输文件: </p><ul><li><strong>控制连接</strong>(control connection): 用于两主机之间传输控制信息, 如用户标识, 口令, 改变远程目录的命令以及存放(put)和获取(get)命令等. </li><li><strong>数据连接</strong>(data connection): 实际用于发送一个文件.</li></ul><p>因为FTP协议使用一个独立的TCP控制连接, 所以我们也称FTP的控制信息是<strong>带外</strong>(out-of-band)传送的. 而HTTP协议在传输文件的同一个TCP连接中发送请求和响应首部行的, 因此可以说是<strong>带内</strong>(in-band)发送控制信息的. </p><p>当用户主机与远程主机开始一个FTP会话时, FTP客户端首先在21端口与服务器端发起一个用于控制的TCP连接. 当FTP服务端从控制连接中接收到一个文件传输命令后, 服务端便向客户端发起一个TCP数据连接传输数据然后关闭连接. 所以在一个会话期间, 用户还需要传输另一个文件, FTP则要打开另一个数据连接. FTP必须在整个会话期间保留用户的<strong>状态</strong>(state), 把特定的用户账户与连接联系起来, 对每一个用户会话状态信息进行追踪, 这限制了FTP同时维持的会话数. </p><h3 id="2-2-3-因特网中的电子邮件"><a href="#2-2-3-因特网中的电子邮件" class="headerlink" title="2.2.3 因特网中的电子邮件"></a>2.2.3 因特网中的电子邮件</h3><p>&#x2F;&#x2F; TODO</p><h3 id="2-2-4-DNS-因特网的目录服务"><a href="#2-2-4-DNS-因特网的目录服务" class="headerlink" title="2.2.4 DNS: 因特网的目录服务"></a>2.2.4 DNS: 因特网的目录服务</h3><p>DNS能提供<strong>主机名</strong>(hosename)转换成<strong>IP地址</strong>(IP address)的目录服务, 这就是<strong>域名系统</strong>(Domain Name System, DNS)的主要任务. 它是: </p><ul><li>由分层的<strong>DNS服务器</strong>(DNS server)实现的分布式数据库</li><li>一个使得主机能查询分布式数据库的应用层协议, DNS协议使用53端口运行在UDP上</li></ul><p>它不直接与用户打交道, 而是为因特网上的用户应用程序以及其他软件提供一种核心功能, 就是将主机名转换为IP地址.<br>它还提供一些重要的服务: </p><ul><li><strong>主机别名</strong>(host aliasing): 有复杂主机名的主机能够拥有一个或者多个别名. 比如一台名为relay1.west-coast.enterprise.com的主机, 可能还有两个别名为enterprise.com和<a href="http://www.enterprise.com/">www.enterprise.com</a>. 在这种情况下relay1.west-coast.enterprise.com也称为<strong>规范主机名</strong>(canonical hostname). 主机别名比规范主机名更容易记忆. 应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址. </li><li><strong>邮件服务器别名</strong>(mail server aliasing): MX记录(后面介绍)允许一个公司的邮件服务器和Web服务器使用相同(别名化)的主机名. </li><li><strong>负载均衡</strong>(load distribution): 一些繁忙的站点它可能有很多台服务器来冗余该站点, 所以这些冗余的服务器每一台都有不同的IP地址, 而DNS数据库中能存储这些IP地址的集合, 当用户请求某个主机别名时, DNS服务器从数据库拿出的IP集合中选取一条返回.</li></ul><p>大致来说有三种DNS服务器: 根DNS服务器(Root DNS Server), 顶级域DNS服务器(Top-Level Domain, TLD DNS Server), 权威DNS服务器(Authoritative DNS Server). </p><p>它们的层次结构如下:<br><img src="/picture/2020-11-02-15-29-38.jpg"><br>如果DNS客户要决定主机名 <a href="http://www.someexp.com/">www.someexp.com</a> 的IP地址, 用户首先和根服务器之一联系, 它返回顶级域名com的TLD服务器的IP地址, 然后客户与这些TLD服务器之一联系, 它将为 someexp.com 返回权威服务器地址的IP, 最后客户与 someexp.com 权威服务器之一联系, 它为主机名 <a href="http://www.someexp.com/">www.someexp.com</a> 返回其IP地址. 得到IP地址后客户就能带着IP地址访问相关的服务了. 细看一下这三种类型的DNS服务器: </p><ul><li><strong>根DNS服务器</strong>(Root DNS Server): 在因特网上有13个根DNS服务器, 但每台”服务器”实际上是一个冗余服务器的网络, 到了2011年秋季共有247个根服务器. </li><li><strong>顶级域DNS服务器</strong>(Top-Level Domain, TLD DNS Server): 这些服务器负责顶级域名如com, org, net, edu和gov, 以及所有国家的顶级域名如cn, uk, fr, ca和jp等. </li><li><strong>权威DNS服务器</strong>(Authoritative DNS Server): 该服务器用来存储一些DNS记录, DNS记录能将主机名映射为IP地址. 一个组织机构能够实现它自己的权威DNS服务器来保存这些记录. 当然这些组织机构也能支付费用, 让一些记录存储在别的服务提供商的权威DNS服务器中. 多数大学和大公司实现和维护他们自己基本和辅助(备份)的DNS服务器.</li></ul><p>还有另一类重要的DNS称为<strong>本地DNS服务器</strong>(local DNS server). 每个ISP(如一个大学, 一个系, 一个公司或居民区ISP)都有一台本地DNS服务器. 当主机与某个ISP连接时, 该ISP提供一台主机的IP地址, 这个主机具有一台或者多台其本地DNS服务器的IP地址(通过DHCP, 会在后面讲到), 然后你就能得到DNS服务器地址. 当主机发出DNS请求时, 该请求会被发往本地DNS服务器, 它起着代理的作用, 并将请求转发到DNS服务器结构层次中. </p><p>例子:<br>假设主机cis.poly.edu想知道主机gaia.cs.umass.edu的IP地址, 假设理工大学(Polytechnic)的本地DNS服务器为dns.poly.edu, 并且gaia.cs.umass.edu的权威DNS服务器为dns.umass.edu. 如下图:<br><img src="/picture/2020-11-02-15-53-34.jpg"></p><ul><li><ol><li>请求主机cis.poly.edu首先向本地DNS服务器发送DNS查询报文, 报文含有被转换的主机名gaia.cs.umass.edu.</li></ol></li><li><ol start="2"><li>本地DNS服务器将该报文转发到根DNS服务器.</li></ol></li><li><ol start="3"><li>根服务器根据edu前缀向本地DNS服务器返回负责edu的TLD的IP地址列表.</li></ol></li><li><ol start="4"><li>本地DNS服务器向这些TLD服务器之一发送查询报文.</li></ol></li><li><ol start="5"><li>TLD服务器注意到umass.edu前缀, 并返回权威DNS服务器的IP地址, 这个权威DNS服务器负责马赛诸塞大学的dns.umass.edu.</li></ol></li><li><ol start="6"><li>本地DNS服务器向dns.umass.edu发查询报文.</li></ol></li><li><ol start="7"><li>dns.umass.edu用gaia.cs.umass.edu的IP地址进行响应.</li></ol></li><li><ol start="8"><li>本地服务器再把详情转发回请求主机.</li></ol></li></ul><p>上面为了获得一台主机名的映射, 发送了8份DNS报文, 4份查询4份响应. 而在实际场景中为了改善时延性能并减少在因特网上到处传输的DNS报文数量, DNS广泛使用了缓存技术, 也就是<strong>DNS缓存</strong>(DNS caching), 比方说上面的例子中的本地DNS服务器会缓存响应的信息. 例子假设了TLD服务器知道了目标主机的权威DNS服务器的IP地址, 一般而言这并不总是正确的. 相反, TLD服务器只是知道目标主机到TLD服务器之间的其中某个权威DNS服务器(这个前提是有多个权威DNS服务器). 在例子中我们可以假设该大学的DNS服务器下还有根据院系分开的DNS服务器, 那么假设目标主机以cs.umass.edu结尾, 也就是计算机系下的一个主机, 那么在这种情况下:<br><img src="/picture/2020-11-02-18-08-31.jpg"></p><ul><li><ol start="6"><li>本地DNS服务器向dns.umass.edu发查询报文(报文的主机名为cs.umass.edu结尾).</li></ol></li><li><ol start="7"><li>dns.umass.edu返回权威服务器cs.umass.edu的地址.</li></ol></li><li><ol start="8"><li>本地DNS服务器向cs.umass.edu发查询报文.</li></ol></li><li><ol start="9"><li>cs.umass.edu用gaia.cs.umass.edu的IP地址进行响应.</li></ol></li><li><ol start="10"><li>本地服务器再把详情转发回请求主机.</li></ol></li></ul><p>在这个例子中共发送了10份DNS报文! 在这些例子中利用到了<strong>递归查询</strong>(recursive query)和<strong>迭代查询</strong>(iterative query). 理论上任何DNS查询向上面的例子一样既可以是迭代的也能是递归的. 下图展示了两种查询的区别:<br><img src="/picture/2020-11-02-17-25-16.jpg"></p><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>(Resource Record, RR), RR提供了主机名到IP地址的映射. 每个DNS回答报文包含了一个或多条资源记录.<br>资源记录是一个包含了下列字段的4元组:<br>(Name, Value, Type, TTL)<br>而TTL是记录的生存时间, 也就是决定了资源记录应当从缓存中删除的时间, 下面就忽略TTL. 而Name和Value的值取决于Type: </p><ul><li>如果Type &#x3D; A, 则Name是主机名, Value是该主机名对应的IP地址. 这是一条提供了标准的主机名到IP地址的映射. 例如(relay1.bar.foo.com, 145.37.93.126, A)就是一条类型A记录. </li><li>如果Type &#x3D; NS, 则Name是一个域(如foo.com), 而Value是一个知道如何获得该域中主机IP地址的权威DNS服务器的主机名. 这个记录用于沿着查询链路来路由DNS查询. 例如(foo.com, dns.foo.com, NS)就是一条类型为NS的记录. </li><li>如果Type &#x3D; CNAME, 则Name是一个别名, Value是别名为Name的主机对应的规范主机名. 该记录能够向查询的主机提供一个主机名对应的规范主机名. 例如(foo.com, relay1.bar.foo.com, CNAME)就是一条类型为CNAME的记录. </li><li>如果Type &#x3D; MX, 则Name是一个别名, 而Value为该别名的邮件服务器的规范主机名. 举例来说(foo.com, mail.bar.foo.com, MX)就是一条MX记录. 通过MX记录, 公司的邮件服务器和其他服务器可以使用相同的别名, 为了获得邮件服务器的规范主机名, DNS客户应当请求一条MX记录, 而为了获得其他服务器的规范主机名, DNS客户应当请求CNAME记录.</li></ul><p>DNS的查询和回答报文有着相同的格式, 其字段语义什么的就不在这里说了. </p><p>文章配套有两个使用Python的套接字编程练习, 分别是UDP和TCP的, 两者的区别就是UDP每次向服务端发送消息都需要显示指明目标套接字的IP地址和端口, 而TCP建立了连接之后就不需要显示指明, 我自己对着改了的代码在<a href="https://github.com/thesomeexp/ComputerNetworkingPractice">这里</a>. </p><h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h1><h2 id="3-1-运输层概述"><a href="#3-1-运输层概述" class="headerlink" title="3.1 运输层概述"></a>3.1 运输层概述</h2><p>运输层协议是在端系统中而不是在路由器中实现的. 这一层的UDP和TCP最基本的职责是将两个<strong>端系统间</strong>IP的交付服务扩展为运行在端系统上的两个<strong>进程间</strong>的交付服务. 这种扩展被称为<strong>运输层的多路复用</strong>与<strong>多路分解</strong>. 而这两个协议有所不同: </p><ul><li>UDP: 和IP服务一样, 它提供<strong>尽力而为交付服务</strong>, 它不能保证数据到达的完整性, 所以也被称为<strong>不可靠服务</strong>. </li><li>TCP: 首先它通过使用流量控制, 序号, 确认和定时器, 将数据正确地, 按序地交付给接收进程. 它提供<strong>可靠数据传输</strong>, 且还格外提供<strong>拥塞控制</strong>.</li></ul><h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><p>运输层是怎么实现<strong>进程间</strong>的交付的呢? 其实是运输层将传递的数据传递给对应的套接字, 然后应用层的进程会有一个或多个套接字. 套接字是运输层和应用层之间的桥梁.  我们通过浏览器访问网页: 首先客户端浏览器进程在给服务器发送HTTP请求前, 会在系统随机开一个端口(下图的1080端口), 程序通过Socket来发送或接受请求. 如下图:<br>&#x2F;&#x2F; FIXME 这个图有点问题, 比如说那个ip不应该出现在这两层中间, 只是端口才出现<br><img src="/picture/2021-04-14_14-34-58.png"></p><ul><li>多路分解↑: 简单来说就是运输层接收来自网络层的报文段, 然后将它分解交付到正确的套接字上. </li><li>多路复用↓: 运输层从不同套接字中收集数据, 并为每个数据封装上首部信息(这些信息被目的主机用于分解), 然后将生成的报文段传递到网络层.</li></ul><p>需要注意的是, 一个UDP套接字是由一个二元组(目的IP:目的port)来全面标识的. 而一个TCP套接字是四元组(源IP:源port + 目的IP:目的port), 因此TCP能通过四元组确定唯一一条连接, 所以也可以说是面向连接的. </p><h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><p>UDP只是做了运输协议能够做的最少工作, 除了复用&#x2F;分解功能以及少量的差错检测外, 它几乎没有对网络层的IP添加别的东西.<br>它对比TCP有如下优点: </p><ul><li>因为容忍丢失, 所以实时性较好(也就是就算丢包了, 不发也无所谓, 而TCP要求直到收到为止). </li><li>无需连接建立(它没有TCP开始传输数据之前的三次握手). </li><li>无连接状态信息(TCP为了实现可靠传输与拥塞控制, 它需要维护一些连接的状态信息, 比如发送缓存, 拥塞控制参数以及序号与确认号参数等). </li><li>分组首部开销小(TCP报文段有20字节的首部开销, 而UDP只有8字节(32比特))</li></ul><p>UDP报文段的首部只有4个字段, 每个字段由两个字节组成:<br><img src="/picture/2020-11-11-17-49-42.jpg"></p><ul><li>源端口号</li><li>目的端口号</li><li>长度: 首部加数据的字节数</li><li>校验和: 发送方将前三个字段相加后进行反码作为校验和, 接收方对前三个字段和校验和相加, 如果出现0就是分组出现差错.</li></ul><p>但UDP的差错检测对差错没有恢复能力, 所以对于受损的报文段只能选择丢弃. 其他实现是将报文段交给应用程序并发出警告. </p><h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>这一节作者没讲TCP噢, 就是带你一步一步走, 如何构建一套可靠传输协议(reliable data transfer protocol), 但问题是该协议下一层也许是不可靠的, 作者讲的一些做法, 在TCP协议中也有体现. </p><h2 id="3-5-TCP"><a href="#3-5-TCP" class="headerlink" title="3.5 TCP"></a>3.5 TCP</h2><p>这一节依赖于上一节可靠数据传输原理, 比如它包括差错检测, 重传, 累积确认, 定时器以及用于序号和确认号的首部字段. </p><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="4-1-1-转发和路由选择"><a href="#4-1-1-转发和路由选择" class="headerlink" title="4.1.1 转发和路由选择"></a>4.1.1 转发和路由选择</h3><p>在网络中的每一台主机和路由器中都有一个网络层部分. </p><ul><li>转发(forwarding): 分组在<strong>单一</strong>的路由器中从一条入链路到一条出链路的传达. </li><li>路由选择(routing): 涉及一个网络的所有路由器, 经过路由选择协议的共同交互, 来决定分组从源到目的地结点所采用的路径.</li></ul><p>每台路由器具有一张 <strong>转发表</strong> (forwarding table). 路由器通过检查到达分组首部字段的值来转发分组, 然后使用该值在该路由器的转发表中索引查询.</p><p>我们将约定术语 <em>分组交换机</em> 是指一台通用分组交换设备, 它根据分组首部字段中的值, 从输入链路接口到输出链路接口转移分组. 某些分组交换机称为 <strong>链路层交换机</strong> (link-layer switches), 基于链路层字段中的值做转发决定. 其它分组交换机称为 <strong>路由器</strong> (router), 基于网络层字段中的值做转发决定.</p><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>网络层有两个重要的功能, 转发和路由选择, 实际上它还有第三种重要的网络功能, 就是 <strong>连接建立</strong> (connection setup). 学习 TCP 时, 当数据能从发送方流向接收方之前, 需要三次握手. 这允许发送方和接收方建立所需的状态信息 (例如, 序号和初始流控制窗口长度). 以类似的方式, 某些网络层体系结构如 ATM, 帧中继, MPLS, 要求从源到目的地沿着所选择的路径彼此握手, 以便在给定源到目的地连接中的网络层数据分组能够开始流动之前建立起状态. 在网络层, 该过程被称为 <em>连接建立</em>.</p><h3 id="4-1-2-网络服务模型"><a href="#4-1-2-网络服务模型" class="headerlink" title="4.1.2 网络服务模型"></a>4.1.2 网络服务模型</h3><p>当位于发送主机的运输层向网络传输分组时 (即在发送主机中将分组向下交给网络层):</p><ul><li>运输层能够指望网络层将该分组交付给目的地吗? </li><li>当发送多个分组时, 它们会按发送顺序按序交付给接收主机的运输层吗? </li><li>发送两个连续分组的时间间隔与接收到这两个分组的时间间隔相同吗? </li><li>网络层会提供关于网络中拥塞的反馈信息吗? </li><li>在发送主机与接收主机中连接运输层的通道的抽象视图 (特性) 是什么?</li></ul><p>对这些问题和其他问题的答案由网络层提供的服务模型所确定. <strong>网络服务模型</strong> (network service model) 定义了分组在发送与接收端系统之间的端到端运输特性.</p><p>因特网的网络层提供了单一的服务, 称为 <strong>尽力而为服务</strong> (best-effort service). 使用尽力而为服务:</p><ul><li>分组间的定时是不能确保被保证的</li><li>分组接收的顺序也不能保证与发送的顺序一致</li><li>传送的分组也不能保证最终交付</li></ul><p>其他的网络体系结构已定义和实现了许多超过因特网的尽力而为服务的服务模型. 例如, ATM 网络体系结构提供了多重服务模型, 意味着可以在相同的网络中为不同的连接提供不同类别的服务.</p><h2 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h2><p>运输层能够为应用程序提供无连接服务或面向连接服务. 以类似的方式, 网络层也能够在两台主机之间提供无连接服务或连接服务.<br>尽管网络层连接和无连接服务与运输层面向连接和无连接服务有类似之处, 但也存在重大差异:</p><ul><li>在网络层中, 这些服务是由网络层向运输层提供的主机到主机的服务. 在运输层中, 这些服务则是运输层向应用层提供的进程到进程的服务.</li><li>在至今为止的所有主要的计算机网络体系结构中 (因特网, ATM, 帧中继等), 网络层或者提供了主机到主机的无连接服务, 或者提供了主机到主机的连接服务, 而不同时提供这两种服务. 仅在网络层提供连接服务的计算机网络称为 <strong>虚电路网络</strong> (Virtual-Circuit, VC). 仅在网络层提供无连接服务的计算机网络称为 <strong>数据报网络</strong> (datagram network).</li><li>在运输层实现面向连接的服务与在网络层实现连接服务是根本不同的. 我们在前面一章看到, 运输层面向连接服务是在位于网络边缘的端系统中实现的, 我们很快看到, 网络层连接服务除了在端系统中, 也在位于网络核心的路由器中实现.</li></ul><h3 id="4-2-1-虚电路网络"><a href="#4-2-1-虚电路网络" class="headerlink" title="4.2.1 虚电路网络"></a>4.2.1 虚电路网络</h3><p>虽然因特网是一个数据报网络, 但许多其他网络体系结构 (包括 ATM,  帧中继的体系结构) 却是虚电路网络, 因此在网络层使用连接. 这些网络层连接被称为 <strong>虚电路</strong>. 我们现在考虑在计算机网络中是如何实现虚电路网络服务的.</p><p>&#x2F;&#x2F; TODO balabala… 介绍了虚电路</p><h3 id="4-2-2-数据报网络"><a href="#4-2-2-数据报网络" class="headerlink" title="4.2.2 数据报网络"></a>4.2.2 数据报网络</h3><p>&#x2F;&#x2F; 前缀 最长前缀匹配规则 </p><h3 id="4-2-3-虚电路和数据报网络的由来"><a href="#4-2-3-虚电路和数据报网络的由来" class="headerlink" title="4.2.3 虚电路和数据报网络的由来"></a>4.2.3 虚电路和数据报网络的由来</h3><p>&#x2F;&#x2F; 比较</p><h2 id="4-3-路由器工作原理"><a href="#4-3-路由器工作原理" class="headerlink" title="4.3 路由器工作原理"></a>4.3 路由器工作原理</h2><h3 id="4-3-1-输入端口"><a href="#4-3-1-输入端口" class="headerlink" title="4.3.1 输入端口"></a>4.3.1 输入端口</h3><h3 id="4-3-2-交换结构"><a href="#4-3-2-交换结构" class="headerlink" title="4.3.2 交换结构"></a>4.3.2 交换结构</h3><h3 id="4-3-3-输出端口"><a href="#4-3-3-输出端口" class="headerlink" title="4.3.3 输出端口"></a>4.3.3 输出端口</h3><h3 id="4-3-4-何处出现排队"><a href="#4-3-4-何处出现排队" class="headerlink" title="4.3.4 何处出现排队"></a>4.3.4 何处出现排队</h3><h3 id="4-3-5-路由选择控制平面"><a href="#4-3-5-路由选择控制平面" class="headerlink" title="4.3.5 路由选择控制平面"></a>4.3.5 路由选择控制平面</h3><h2 id="4-4-网际协议-因特网中的转发和编址"><a href="#4-4-网际协议-因特网中的转发和编址" class="headerlink" title="4.4 网际协议: 因特网中的转发和编址"></a>4.4 网际协议: 因特网中的转发和编址</h2><h3 id="4-4-1-数据报格式"><a href="#4-4-1-数据报格式" class="headerlink" title="4.4.1 数据报格式"></a>4.4.1 数据报格式</h3><h3 id="4-4-2-IPv4-编址"><a href="#4-4-2-IPv4-编址" class="headerlink" title="4.4.2 IPv4 编址"></a>4.4.2 IPv4 编址</h3><h4 id="1-获取一块地址"><a href="#1-获取一块地址" class="headerlink" title="1. 获取一块地址"></a>1. 获取一块地址</h4><h4 id="2-获取主机地址-动态主机配置协议-DHCP"><a href="#2-获取主机地址-动态主机配置协议-DHCP" class="headerlink" title="2. 获取主机地址: 动态主机配置协议 DHCP"></a>2. 获取主机地址: 动态主机配置协议 DHCP</h4><h4 id="3-网络地址转换"><a href="#3-网络地址转换" class="headerlink" title="3. 网络地址转换"></a>3. 网络地址转换</h4><h3 id="4-4-3-因特网控制报文协议"><a href="#4-4-3-因特网控制报文协议" class="headerlink" title="4.4.3 因特网控制报文协议"></a>4.4.3 因特网控制报文协议</h3><h3 id="4-4-4-IPv6"><a href="#4-4-4-IPv6" class="headerlink" title="4.4.4 IPv6"></a>4.4.4 IPv6</h3><h3 id="4-4-5-涉足-IP-安全性"><a href="#4-4-5-涉足-IP-安全性" class="headerlink" title="4.4.5 涉足 IP 安全性"></a>4.4.5 涉足 IP 安全性</h3><h2 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h2><h2 id="4-6-因特网中的路由选择"><a href="#4-6-因特网中的路由选择" class="headerlink" title="4.6 因特网中的路由选择"></a>4.6 因特网中的路由选择</h2><h2 id="4-7-广播和多播路由选择"><a href="#4-7-广播和多播路由选择" class="headerlink" title="4.7 广播和多播路由选择"></a>4.7 广播和多播路由选择</h2><h2 id="4-8-小结"><a href="#4-8-小结" class="headerlink" title="4.8 小结"></a>4.8 小结</h2><h1 id="5-链路层"><a href="#5-链路层" class="headerlink" title="5. 链路层"></a>5. 链路层</h1><h2 id="5-1-链路层概述"><a href="#5-1-链路层概述" class="headerlink" title="5.1 链路层概述"></a>5.1 链路层概述</h2><h3 id="5-1-1-链路层提供的服务"><a href="#5-1-1-链路层提供的服务" class="headerlink" title="5.1.1 链路层提供的服务"></a>5.1.1 链路层提供的服务</h3><h3 id="5-1-2-链路层在何处实现"><a href="#5-1-2-链路层在何处实现" class="headerlink" title="5.1.2 链路层在何处实现"></a>5.1.2 链路层在何处实现</h3><h2 id="5-2-差错检测和纠正技术"><a href="#5-2-差错检测和纠正技术" class="headerlink" title="5.2 差错检测和纠正技术"></a>5.2 差错检测和纠正技术</h2><h3 id="5-2-1-奇偶校验"><a href="#5-2-1-奇偶校验" class="headerlink" title="5.2.1 奇偶校验"></a>5.2.1 奇偶校验</h3><h3 id="5-2-2-检验和方法"><a href="#5-2-2-检验和方法" class="headerlink" title="5.2.2 检验和方法"></a>5.2.2 检验和方法</h3><h3 id="5-2-3-循环冗余检测"><a href="#5-2-3-循环冗余检测" class="headerlink" title="5.2.3 循环冗余检测"></a>5.2.3 循环冗余检测</h3><h2 id="5-3-多路访问链路和协议"><a href="#5-3-多路访问链路和协议" class="headerlink" title="5.3 多路访问链路和协议"></a>5.3 多路访问链路和协议</h2><p>概述中提到了两种类型的网络链路:</p><ul><li>点对点链路 (point-to-point link)<ul><li>点对点协议 (point-to-point protocol, PPP)</li><li>高级数据链路控制 (high-level data link control, HDLC)</li></ul></li><li>广播链路 (broadcast link)</li></ul><h3 id="5-3-1-信道划分协议"><a href="#5-3-1-信道划分协议" class="headerlink" title="5.3.1 信道划分协议"></a>5.3.1 信道划分协议</h3><ul><li>时分复用 TDM</li><li>频分复用 FDM</li><li>码分多址 CDMA</li></ul><h3 id="5-3-2-随机接入协议"><a href="#5-3-2-随机接入协议" class="headerlink" title="5.3.2 随机接入协议"></a>5.3.2 随机接入协议</h3><ul><li>时隙 ALOHA</li><li>ALOHA</li><li>载波侦听多路访问 (CSMA)</li><li>具有碰撞检测的 CSMA (CSMA&#x2F;CD)</li></ul><h3 id="5-3-3-轮流协议"><a href="#5-3-3-轮流协议" class="headerlink" title="5.3.3 轮流协议"></a>5.3.3 轮流协议</h3><h3 id="5-3-4-DOCSIS-用于电缆因特网接入的链路层协议"><a href="#5-3-4-DOCSIS-用于电缆因特网接入的链路层协议" class="headerlink" title="5.3.4 DOCSIS: 用于电缆因特网接入的链路层协议"></a>5.3.4 DOCSIS: 用于电缆因特网接入的链路层协议</h3><h2 id="5-4-交换局域网"><a href="#5-4-交换局域网" class="headerlink" title="5.4 交换局域网"></a>5.4 交换局域网</h2><h3 id="5-4-1-链路层寻址和-ARP"><a href="#5-4-1-链路层寻址和-ARP" class="headerlink" title="5.4.1 链路层寻址和 ARP"></a>5.4.1 链路层寻址和 ARP</h3><p>ARP 在很多方面和 DNS 类似, DNS 将主机名解析为 IP 地址.</p><ul><li>DNS 为在因特网中任何地方的主机解析主机名</li><li>ARP 只为在同一个子网上的主机和路由器接口解析 IP 地址</li></ul><h3 id="5-4-2-以太网"><a href="#5-4-2-以太网" class="headerlink" title="5.4.2 以太网"></a>5.4.2 以太网</h3><h3 id="5-4-3-链路层交换机"><a href="#5-4-3-链路层交换机" class="headerlink" title="5.4.3 链路层交换机"></a>5.4.3 链路层交换机</h3><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>这里说的IP协议是指Internet Protocol互联网协议, 而我们日常说得IP其实是指IP地址, 也就是一段数字. 在上面快递的例子中, IP地址相当于快递所在网点的地址, 那么在计算机网络中也是一样的, 接入互联网的设备每一台都会有一个IP地址. 在我们日常生活中, 家里办了宽带, 我们的设备能上网, 而那个宽带就包含运营商给我们提供的IP地址, 有了IP地址我们才能和互联网上其他设备进行通讯. </p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>接入到网络的计算机都会有一个IP, 有的计算机是专门给其他计算机提供服务的, 也叫服务器, 所以服务器肯定有自己的IP, 但是用户直接通过IP来访问对应服务器是不大方便的, 所以就有了域名, 而DNS协议的作用就是将域名解析成IP, 但是域名对应的IP经常在变化, 所以就需要专门将域名解析成IP的DNS服务器. 我们直接访问的DNS服务器叫本地DNS服务器, 它本身没有域名和IP对应关系, 在我们发出请求时它会从主DNS服务器获取然后保存到缓存中. </p><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>TCP协议和IP协议是两个不同的协议, TCP协议用来规范传输规则, 而IP协议只是负责找到地址. TCP协议在传输前会进行”三次握手”, 传输完数据断开时要进行”四次挥手”. </p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议是一套规则, 如果两台计算机都遵循这个规则, 那么它们之间就可以建立一种可靠的连接, 这种可靠的连接是连接双方都遵循这个TCP协议才能建立的, 而遵守这套协议能够保证我们双方发送和接收到的消息有序且完整.<br>协议的特点: </p><ul><li>面向连接, 可靠的字节流服务</li><li>一个TCP连接中只有两方进行通信, 广播和多播不能用于TCP</li><li>使用校验和, 确认和重传机制来保证可靠的传输</li><li>数据分节排序, 使用累积确认保证数据顺序不变和非重复</li><li>使用滑动窗口机制实现流量控制, 通过动态改变窗口大小进行拥塞控制 </li><li>TCP也不是100%可靠的协议, 如果有可能就把数据送到接收方, 否则就放弃重传中断连接通知用户.</li></ul><p>如何建立TCP连接? </p><p>现在计算机双方都知道我需要遵循TCP协议这个规则, 我就能跟其他也遵循这个规则的计算机通讯了, 但是我如何跟另外的TA建立连接呢? </p><h3 id="IP协议-1"><a href="#IP协议-1" class="headerlink" title="IP协议"></a>IP协议</h3><p>参考: </p><ul><li>书籍: 计算机网络-自顶向下方法</li><li>书籍: 看透Spring_MVC：源代码分析与实践</li><li><a href="https://juejin.im/post/6844904070000410631">一文彻底搞懂 TCP三次握手、四次挥手过程及原理 </a></li><li><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">TCP协议 笔试面试知识整理</a></li></ul>]]></content>
    
    
    <summary type="html">记录计算机网络学习的笔记.</summary>
    
    
    
    
    <category term="Note" scheme="https://someexp.com/tags/Note/"/>
    
    <category term="Network" scheme="https://someexp.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的学习</title>
    <link href="https://someexp.com/2020/spring-learning/"/>
    <id>https://someexp.com/2020/spring-learning/</id>
    <published>2020-10-26T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Spring 的学习笔记</p><span id="more"></span><h1 id="1-Spring整体设计理念和整体架构"><a href="#1-Spring整体设计理念和整体架构" class="headerlink" title="1. Spring整体设计理念和整体架构"></a>1. Spring整体设计理念和整体架构</h1><h1 id="2-Spring-Ioc"><a href="#2-Spring-Ioc" class="headerlink" title="2. Spring Ioc"></a>2. Spring Ioc</h1><h2 id="2-1-IOC是啥"><a href="#2-1-IOC是啥" class="headerlink" title="2.1 IOC是啥"></a>2.1 IOC是啥</h2><p>IOC是(Inversion Of Control)的简写, 翻译过来叫控制反转, 是一种思想. 简单来说本来一些东西是你自己控制的, 而IOC控制反转的意思是控制权交给别人了, 不需要自己控制. </p><h1 id="3-Spring-AOP"><a href="#3-Spring-AOP" class="headerlink" title="3. Spring AOP"></a>3. Spring AOP</h1><h2 id="3-1-为什么会有AOP"><a href="#3-1-为什么会有AOP" class="headerlink" title="3.1 为什么会有AOP?"></a>3.1 为什么会有AOP?</h2><p>如果你写过基于Spring或者Spring Boot相关的项目, 那你可能会遇到以下的问题.<br>比如说: </p><ul><li>对于某些方法需要记录日志</li><li>对某些方法的执行前需要对用户进行权限判定</li></ul><p>以上的这些功能, 如果直接写在业务代码中, 那么每个方法都会调用一次这些公用的方法. </p><p><img src="/picture/2020-10-29-11-39-46.png" alt="各method都会调用log()方法"></p><p>很明显这样显示调用的代码难以管理, 一旦我的log方法一变动, 或者说我有些方法不需要调用这个log()了, 删减method中的代码是一件麻烦事.<br>这时候就可以考虑使用AOP了, AOP和OOP一样是一种观念, 全称为Aspect-oriented programming, 翻译过来叫面向切面编程. 它可以实现对这些重复代码单独抽取出来进行管理维护, 在需要时统一调用, 以及对于如何灵活使用这些公共代码提供了支持. 为了更好的使用AOP技术, 技术专家们是专门成立了一个AOP联盟来探讨AOP标准化, 因此你可以在AOP联盟文档中找到相关介绍. </p><h2 id="3-2-Spring-AOP中的一些概念"><a href="#3-2-Spring-AOP中的一些概念" class="headerlink" title="3.2 Spring AOP中的一些概念"></a>3.2 Spring AOP中的一些概念</h2><p>这里直接拿<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop">Spring文档中对AOP的介绍</a>来讲一下. </p><ul><li><p>Aspect 切面: Aspect是一种模块化的观念, 这种观念将横切经过多个类, 所以翻译过来就是切面. 在企业Java应用中, 事务管理是横切观念很好的例子. 在Spring AOP中, 切面可以通过基于配置文件(配置xml的方式), 或者基于@Aspect注解的类. (这里讲的非常抽象, 把它想成管理切面相关的的配置就好了)</p></li><li><p>Join Point 连接点: 在程序执行过程中的一个点, 例如方法的执行或者异常的处理. 在Spring AOP中这个连接点总是代表方法执行. (可以理解成就是类中的方法就是连接点)</p></li><li><p>Advice 通知: 特定切面在特定的连接点执行的操作. 通知有不同的类型, 包括”前置通知”, “后置通知”, “环绕通知”等. (其实就是在什么时候执行, 前置就是在目标方法执行前执行, 后置就是目标方法后执行…) 许多AOP框架, 包括Spring, 将通知建模成为一个拦截器, 并且在连接点周围维护一条由拦截器组成的拦截链. (这就是Spring对Advice的实现方式了. ) </p></li><li><p>Pointcut 切入点: 切入点是表达连接点的谓词. (就是连接点的集合) 通知是和这个切入点表达式相关联的, 它会在任何匹配切入点的连接点上执行. (例如, 在特定方法上执行通知). 这种根据切点表达式匹配连接点的观念是AOP的核心, 而Spring默认使用AspectJ切入点表达式)</p></li><li><p>Introduction 引入: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) (TODO: 我不懂求大佬带带)</p></li><li><p>Target Object 目标对象: 一个即将被一个或者多个切面增强的对象. (增强也就是被通知影响) 也成为”通知对象”. 由于Spring AOP是根据运行时代理实现的, 所以这个对象总是一个代理对象. </p></li><li><p>AOP proxy AOP代理: 一个为了实现切面契约的AOP框架创建的对象. 在Spring框架中, 它可能是JDK动态代理或者是CGLIB代理. </p></li><li><p>Weaving 编织: 将切面和其他应用程序类型或者对象连接, 来创建一个增强了的对象. 这可能在编译时完成, (例如使用AspectJ编译器) 加载时, 或者运行时. 而Spring AOP和其他纯Java AOP框架一样, 是在运行时完成织入的.</p></li></ul><h2 id="3-3-Java中AOP的实现"><a href="#3-3-Java中AOP的实现" class="headerlink" title="3.3 Java中AOP的实现"></a>3.3 Java中AOP的实现</h2><h3 id="3-3-1-静态AOP"><a href="#3-3-1-静态AOP" class="headerlink" title="3.3.1 静态AOP"></a>3.3.1 静态AOP</h3><ul><li>在编译器, 切面直接以字节码形式编译到目标字节码文件中.</li></ul><h3 id="3-3-2-动态AOP"><a href="#3-3-2-动态AOP" class="headerlink" title="3.3.2 动态AOP"></a>3.3.2 动态AOP</h3><ul><li>在运行时, 目标类加载后, 动态生成代理类, 将切面植入到代理类中.</li></ul><h4 id="3-3-2-1-基于JDK动态代理"><a href="#3-3-2-1-基于JDK动态代理" class="headerlink" title="3.3.2.1 基于JDK动态代理"></a>3.3.2.1 基于JDK动态代理</h4><p>基于<strong>Java反射</strong>机制实现, 必须要<strong>实现了接口</strong>的业务类才能用这种办法生成代理对象. </p><h4 id="3-3-2-2-基于CGLIB代理"><a href="#3-3-2-2-基于CGLIB代理" class="headerlink" title="3.3.2.2 基于CGLIB代理"></a>3.3.2.2 基于CGLIB代理</h4><p>基于<strong>ASM</strong>机制实现，通过<strong>生成业务类的子类</strong>作为代理类。</p><h3 id="3-3-3-小结"><a href="#3-3-3-小结" class="headerlink" title="3.3.3 小结"></a>3.3.3 小结</h3><p><img src="/picture/2020-10-29-16-00-37.png"></p><p>不同的AOP实现只是在不同的时刻用不同的工具来实现的, 下面就只讲Spring的AOP. </p><h2 id="3-4-Spring-AOP的实现"><a href="#3-4-Spring-AOP的实现" class="headerlink" title="3.4 Spring AOP的实现"></a>3.4 Spring AOP的实现</h2><p>下面就拿Spring 5.2.9的源代码来看咯. </p><h3 id="3-4-1-Advice-通知"><a href="#3-4-1-Advice-通知" class="headerlink" title="3.4.1 Advice 通知"></a>3.4.1 Advice 通知</h3><p>Advice是AOP联盟定义的一个接口, 可以在org.aopalliance.aop.Advice中找到它.<br>而Spring提供了更具体的通知类型, BeforeAdvice, AfterAdvice, ThrowsAdvice等. </p><ul><li>BeforeAdvice接口: 前置通知的标记接口. </li><li>AfterAdvice接口: 后置通知的标记接口. </li><li>ThrowsAdvice接口: 一般抛出异常就由这个接口处理.</li></ul><p>Spring中比BeforeAdvice接口更具体一点的实现是MethodBeforeAdvice接口: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">BeforeAdvice</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它提供了一个before方法, 它会在方法被调用前被调用. 这个通知不能阻止方法调用的过程, 除非它抛出Throwable. 如果方法签名允许, 它抛出的任何异常都会返回给调用方. 否则异常会被包装为运行时异常. 而它的method参数是目标方法的反射对象; args对象数组中包含目标方法的输入参数; target为目标对象. </p><p>下面是AfterAdvice更具体的AfterReturningAdvice接口: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它提供了afterReturning方法, 顾名思义就是在目标对象方法成功返回值了之后执行. (前提当然目标方法也没抛异常) 它可以获得返回值但是无法改变返回值. 参数returnValue为返回值; </p><p>然后是ThrowsAdvice, 它是继承AfterAdvice: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个接口并没有规定的方法, 如果需要你需要实现这种形式的方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">([Method, args, target], ThrowableSubclass)</span>;</span><br></pre></td></tr></table></figure><p>其中方括号内的参数是可选的. 如果该异常通知抛出新的异常, 将会覆盖原来的异常. </p><h3 id="3-4-2-Pointcut-切点"><a href="#3-4-2-Pointcut-切点" class="headerlink" title="3.4.2 Pointcut 切点"></a>3.4.2 Pointcut 切点</h3><p>Spring AOP提供了具体的切点, 比如JdkRegexpMethodPointcut的matches方法是通过JDK来实现正则表达式的匹配的. NameMatchMethodPointcut的matches方法就是使用方法名相同或者方法名相匹配. </p><h3 id="3-4-3-Advisor-通知器"><a href="#3-4-3-Advisor-通知器" class="headerlink" title="3.4.3 Advisor 通知器"></a>3.4.3 Advisor 通知器</h3><p>通过Advisor可以将Advice和Pointcut结合起来. </p><h3 id="后面太难了-夭折了…"><a href="#后面太难了-夭折了…" class="headerlink" title="后面太难了, 夭折了…"></a>后面太难了, 夭折了…</h3><p>Spring通过jdk和cglib两个精彩的实现了AOP, 虽然我们用起来很简单, 但是Spring实现AOP的过程是非常艰苦的, (是我太菜了看不懂了. ) </p><h1 id="4-Spring-MVC"><a href="#4-Spring-MVC" class="headerlink" title="4. Spring MVC"></a>4. Spring MVC</h1><h2 id="4-1-网络基础知识"><a href="#4-1-网络基础知识" class="headerlink" title="4.1 网络基础知识"></a>4.1 网络基础知识</h2><p>在此之前先学习一下<a href="/2020/basic-computer-network">计算机网络基础知识</a>. </p><p>在BS结构中使用到了DNS协议, 而且在HTTP上层还有相关规范, 如Java Web开发中使用的是Servlet标准. 标准就是规范, 都是不能干活的, 能干活的就是实现了Servlet标准的Tomcat这种Servlet容器. </p><h3 id="4-1-1-Java中的Socket"><a href="#4-1-1-Java中的Socket" class="headerlink" title="4.1.1 Java中的Socket"></a>4.1.1 Java中的Socket</h3><p>Java中的Socket可以分为<strong>普通Socket</strong>和<strong>NioSocket</strong>两种. </p><h4 id="普通Socket"><a href="#普通Socket" class="headerlink" title="普通Socket"></a>普通Socket</h4><p>Java中的网络通信是通过Socket实现的, java.net包里的Socket主要分为<strong>Socket</strong>和<strong>ServerSocket</strong>两类. </p><ul><li>java.net.ServerSocket: 用于服务端, 可以通过accept方法监听请求, 监听到Socket请求后用该Socket完成数据传输. </li><li>java.net.Socket: 用于客户端发起请求并传输数据.</li></ul><h4 id="new-IO模式Socket"><a href="#new-IO模式Socket" class="headerlink" title="new IO模式Socket"></a>new IO模式Socket</h4><p>&#x2F;&#x2F; TODO 以后再说</p><p>这两个例子书中的代码我都放在<a href="https://github.com/thesomeexp/JavaExample/tree/master/KanTouSpringMVC">这里</a>啦. </p><h3 id="4-1-2-Servlet详解"><a href="#4-1-2-Servlet详解" class="headerlink" title="4.1.2 Servlet详解"></a>4.1.2 Servlet详解</h3><p>Servlet是Server+Applet的缩写, 表示一个服务器应用. 它是一套规范, 按照这套规范写的代码就可以直接在Java的服务器上运行. </p><p><img src="/picture/2020-11-05-11-18-18.png"></p><p>Servlet一些方法: </p><ul><li>init(): 在容器启动时被容器调用. (当load-on-startup设置为负数或者不设置时会在Servlet第一次用到时才被调用)</li><li>getServletConfig(): 用于获取ServletConfig. </li><li>getServletInfo(): 获取Servlet相关信息, 如作者, 版权等, 默认空. </li><li>service(): 具体处理请求的方法</li><li>destroy(): Servlet销毁(关闭服务器)时释放一些资源, 调用一次.</li></ul><p>ServletConfig一些方法: </p><ul><li>getServletName(): 获取Servlet名字, web.xml中定义的servlet-name. </li><li>getInitParameter(): 获取init-param配置参数. </li><li>getInitParameterNames(): 获取配置所有init-param的名字的集合. </li><li>getServletContext(): 这个非常重要, 它的返回值ServletContext就是这个应用本身. 所以这里面的参数就可以被当前应用的所有Servlet共享. 比如我们项目中参数可以保存在Session中, 也可以在Application中, 而这个Application多数就是保存在ServletContext.</li></ul><p>简单来说ServletConfig能获取一些web.xml配置好的servlet信息, 然后还能获得整个Servlet上下文. Servlet容器通过把这个ServletConfig作为参数传入Servlet的init()方法中, 便于Servlet的配置. </p><p>GenericServlet作为一个协议无关的Servlet的默认实现, 主要做了三件事: </p><ul><li><ol><li>实现ServletConfig接口, 使得可以直接调用里面的方法.</li></ol></li><li><ol start="2"><li>提供无参的init()模板方法. (带参的init方法做了config的配置, 所以子类只需要覆盖无参init()专注于完成逻辑就好了)</li></ol></li><li><ol start="3"><li>提供log()方法. 一般我们都有自己的日志处理, 这个用得不多.</li></ol></li></ul><p>HttpServlet做的比较重要的事情: </p><ul><li><ol><li>覆盖service()方法, 主要将ServletRequest和ServletResponse转换为HttpServletRequest和HttpServletResponse. 然后调用自己的service()方法.</li></ol></li><li><ol start="2"><li>自身的service()方法, 根据HttpServletRequest的请求方法, 用不同的doXXX结构的处理方法处理.</li></ol></li></ul><p>注意到doGet方法处理前它判断了if-modified-since, 如果缓存没过期就返回304使用缓存.<br>而doHead调用了doGet请求, 然后返回空body的Response.<br>而doOptions和doTrace正常不需要使用, 主要用来做调试, 它会对header原封不动的返回, 这种做法很容易被黑客利用, 存在安全漏洞, 如果不是必须使用最好禁用. </p><p>简单来说HttpServlet把不同请求方式路由到了不同的处理方法. </p><h2 id="4-2-Tomcat"><a href="#4-2-Tomcat" class="headerlink" title="4.2 Tomcat"></a>4.2 Tomcat</h2><h3 id="4-2-1-Tomcat的顶层结构"><a href="#4-2-1-Tomcat的顶层结构" class="headerlink" title="4.2.1 Tomcat的顶层结构"></a>4.2.1 Tomcat的顶层结构</h3><p>Tomcat中最顶层的容器叫Server. </p><ul><li>Server: 这是Tomcat中最顶层的容器, 它代表整个服务器. 它包含至少一个Service, 用于提供服务. </li><li>Service: 它包含一个Container和一个或多个Connector(一个服务可以有多个连接, 如同时提供http与https, 也可以提供同协议不同端口的连接). </li><li>Connector: 它用于处理连接相关的事情, 并提供Socket与request, response的转换. </li><li>Container: 用于封装和管理Servlet, 具体处理request请求.</li></ul><p><img src="/picture/2020-11-05-14-54-04.png"></p><p>而Tomcat的Server是由org.apache.catalina.startup.Catalina来管理的, Catalina是整个Tomcat的管理类. 它的方法: </p><ul><li><ol><li>load(): 用于根据conf&#x2F;server.xml文件创建Server并调用Server的init()方法进行初始化.</li></ol></li><li><ol start="2"><li>start(): 用于启动服务器. 在内部调用Server的start()方法.</li></ol></li><li><ol start="3"><li>stop(): 用于停止服务器. 在内部调用Server的stop()方法.</li></ol></li><li>await(): 该方法调用Server的await()方法, 作用是进入一个循环让主线程不会退出.</li></ul><p>上面的三个方法会按照容器的结构逐层调用相应的方法. 比如Server的start()会调用Service的start(), 而Service的start()会调用包含的Connector和Container的start(). </p><p>而Tomcat的入口方法并不在Catalina类里面, 而是在org.apache.catalina.startup.Bootstrap里面. 这个Bootstrap类似一个CatalinaAdaptor, 具体过程还是Catalina来完成的, 这样的好处是把启动入口和具体的管理类分开, 可以方便的创造出不同的启动方式, 每种启动方式只需要写相应的CatalinaAdaptor就好了. </p><h3 id="4-2-2-Bootstrap的启动过程"><a href="#4-2-2-Bootstrap的启动过程" class="headerlink" title="4.2.2 Bootstrap的启动过程"></a>4.2.2 Bootstrap的启动过程</h3><ul><li><ol><li>main(): 新建一个Bootstrap对象, 执行init()方法, 然后处理main方法传入的args参数命令, 如果为空默认执行setAwait() —&gt; load(args) —&gt; start().</li></ol></li><li><ol start="2"><li>init(): 初始化ClassLoader创建Catalina实例赋值给catalinaDaemon变量, 后面对命令操作都是用catalinaDaemon.</li></ol></li><li><ol start="3"><li>setAwait(): 通过反射调用对应Catalina的setAwait().</li></ol></li><li><ol start="4"><li>load(args): 通过反射调用对应Catalina的load(args).</li></ol></li><li><ol start="5"><li>start(): 通过反射调用对应的Catalina的start().</li></ol></li></ul><h3 id="4-2-3-Catalina的启动过程"><a href="#4-2-3-Catalina的启动过程" class="headerlink" title="4.2.3 Catalina的启动过程"></a>4.2.3 Catalina的启动过程</h3><ul><li><ol><li>setAwait(): 用于设置Server启动后是否进入等待的await标志. 可以看到start()后会用await标志判断是否执行await().</li></ol></li><li><ol start="2"><li>load(args): 根据conf&#x2F;server.xml加载配置文件创建并初始化Server对象, 然后赋值给server属性(具体操作是通过开源项目Digester完成的), 然后调用server的init().</li></ol></li><li><ol start="3"><li>start(): 调用server的start(), 然后根据await属性判断是否让程序进入等待状态. (server的await()方法内部会执行一个while循环, 当await()方法退出时会执行stop()从而关闭服务器)</li></ol></li></ul><h3 id="4-2-4-Server的启动过程"><a href="#4-2-4-Server的启动过程" class="headerlink" title="4.2.4 Server的启动过程"></a>4.2.4 Server的启动过程</h3><p>Server接口提供addService(), removeService来添加和删除Service. 而Server的init()和start()方法分别循环调用每个Service的init()和start()方法来启动所有Service. </p><p>Server的默认实现是org.apache.catalina.core.StandardServer, 而StandardServer继承自LifecycleMBeanBase, LifecycleMBeanBase又继承自LifecycleBase: </p><p><img src="/picture/2020-11-05-16-04-08.png"></p><p>init()和start()方法就定义在LifecycleBase中, LifecycleBase里的init()和start()方法又调用initInternal()和startInternal()这两个模板方法, 所以调用StandardServer的init()和start()方法时会执行StandardServer自己的initInternal()和startInternal()这两个方法, 这就是Tomcat生命周期的管理方式. initInternal()和startInternal()这两个方法分别循环调用了每一个Service的start()和init()方法. </p><p>StandardServer还实现了**await()**方法, Catalina就是调用它让服务器进入等待状态的. 但是啥时候退出呢? 这就是await()方法要干的活了. 它根据Server设置的端口号来关闭(这个端口号不是服务的端口号, 是专门用来监听停止容器命令的端口, 默认是8005). 根据这个端口号的值, 它有三种处理方法: </p><ul><li>port为-2, 则直接退出, 不进入循环. </li><li>port为-1, 进入一个循环, 只有调用了stopAwait方法才会退出循环. (方法关闭)</li><li>port为其他值, 会在port所在端口启动一个ServerSocket来监听关闭命令(默认为”SHUTDOWN”), 默认为8005, 如果接收到了则跳出循环. (网络命令关闭)</li></ul><h3 id="4-2-5-Service的启动过程"><a href="#4-2-5-Service的启动过程" class="headerlink" title="4.2.5 Service的启动过程"></a>4.2.5 Service的启动过程</h3><p>Service接口的默认实现是org.apache.catalina.core.StandardService, StandardService也继承LifecycleMBeanBase类, 所以init()和start()方法最终也会调用initInternal()和startInternal()方法. </p><p><img src="/picture/2020-11-05-16-21-49.png"></p><p>我们看StandardService中的initInternal()和startInternal()方法, 它其实是调用了container, executors, mapperListener, connectors的init()和start()方法. container和connectors前已经介绍过, mapperListener是Mapper的监听器, 它可以监听container容器的变化, executors是用在connectors中管理线程的线程池, 在server.xml配置文件中有参考用法, 不过默认是注释起来的: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;</span></span><br><span class="line"><span class="comment">    maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>把上面的注释放开, Connector就会配置一个叫tomcatThreadPool的线程池, 最多可以同时启动150个线程, 最少要有4个可用线程. </p><p>整个Tomcat服务器启动流程就是: </p><p><img src="/picture/2020-11-05-17-23-55.jpg"></p><h3 id="4-2-6-Tomcat的生命周期管理"><a href="#4-2-6-Tomcat的生命周期管理" class="headerlink" title="4.2.6 Tomcat的生命周期管理"></a>4.2.6 Tomcat的生命周期管理</h3><p>下面的内容需要学习<strong>观察者模式</strong>才能看懂哦.<br>Tomcat通过org.apache.catalina.Lifecycle接口统一管理生命周期, 所有有生命周期的组件都要实现Lifecycle接口.<br>而这个生命周期管理的Lifecycle接口是拿来干嘛的呢? 由Lifecycle接口上面的注释我们可以了解到, 实现了这个接口的组件, 他们就会有以下的这些合法的状态值, 以及状态之间的转换, 在状态转换之间触发事件, 然后监听器们通过判断事件的类型来做相应处理. 下面这个是组件的状态机图(这个图看着难受, 过一眼就行了): </p><p><img src="/picture/2020-11-06-10-10-10.png"></p><p>这个接口主要有这些内容: </p><ul><li><ol><li>定义了13个String类型常量, 这是LifecycleEvent事件中的<strong>事件类型</strong>. 用于LifecycleEvent事件中的type属性, 作用是区分组件发出的LifecycleEvent事件时的状态(如初始化前, 启动前, 启动中等). 这种设计方式可以让多种状态都发送同一种类型的事件, 然后用其中的一个属性来区分状态而不用定义多种事件. 书本作者大佬说我们要学习借鉴这种方式.</li></ol></li><li><ol start="2"><li>定义了三个管理监听器的方法: addLifecycleListener(), findLifecycleListeners(), removeLifecycleListener(), 分别用来添加, 查找, 删除LifecycleListener类型的监听器.</li></ol></li><li><ol start="3"><li>定义了4个生命周期的方法: init(), start(), stop(), destroy(), 用于执行生命周期的各个阶段的操作.</li></ol></li><li><ol start="4"><li>定义了获取当前状态的两个方法, getState()和getStateName()分别用来获取当前的状态. getState()返回值LifecycleState是枚举类型, 里面列举了<strong>生命周期的各个节点</strong>, getStateName()方法返回String类型的状态名字, 主要用于JMX中.</li></ol></li></ul><h3 id="4-2-7-Container分析"><a href="#4-2-7-Container分析" class="headerlink" title="4.2.7 Container分析"></a>4.2.7 Container分析</h3><p>Container是Tomcat中容器的接口, 因为作为Tomcat的容器组件所有有生命周期继承Lifecycle接口.<br>它有4个子接口(子容器)和一个默认实现ContainerBase, 而且子容器都继承默认实现ContainerBase: </p><p><img src="/picture/2020-11-06-14-54-35.png" alt="Container结构图"></p><p>Container的子容器Engine, Host, Context, Wrapper是逐层包含的关系, 其中Engine是最顶层, 每个Service最多只能有一个Engine, 每个Engine里面可以有多个Host, 每个Host下可以有多个Context, 每个Context下可以有多个Wrapper. </p><p><img src="/picture/2020-11-06-14-59-25.jpg"></p><ul><li>Engine: 引擎, 用来管理多个站点, 一个Service最多只能有一个Engine. (也就是很久之前结构图的Container)</li><li>Host: 代表一个站点, 也可以叫虚拟主机, 通过配置Host就可以添加站点. </li><li>Context: 代表一个应用程序, 对应着平时开发的一套程序, 或者一个WEB-INF目录以及下面的web.xml文件. </li><li>Wrapper: 每个Wrapper封装着一个Servlet.</li></ul><p>上面写得我觉得比较抽象, 还是直接看Tomcat目录吧:<br><strong>Host</strong>: Tomcat的默认Host(主机名)为localhost, 在conf&#x2F;server.xml也能看到相关配置(这里简单的抽取一些配置): </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tomcat启动时默认监听所有IP地址, 如果仅仅本地测试可以在Service下的Connector中配置address&#x3D;”127.0.0.1”来设置仅监听本地. </p><p><img src="/picture/2020-11-06-15-04-52.png"></p><p><strong>Context</strong>: 代表应用, 而ROOT目录里的应用就是主应用, 直接使用主机名&#x2F;应用名就能访问对应的应用, 比如我们启动Tomcat后访问127.0.0.1&#x2F;docs就能访问docs这个应用了. </p><p><img src="/picture/2020-11-06-15-07-58.png"><br><img src="/picture/2020-11-06-15-48-24.jpg"></p><p>4种容器的配置方法:<br>作者简化了默认配置来供我们学习哦: </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&#x27;8005&#x27;</span> <span class="attr">shutdown</span>=<span class="string">&#x27;SHUTDOWN&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&#x27;Catalina&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&#x27;8080&#x27;</span> <span class="attr">protocol</span>=<span class="string">&#x27;HTTP/1.1&#x27;</span> <span class="attr">connectionTimeout</span>=<span class="string">&#x27;20000&#x27;</span> <span class="attr">redirectPort</span>=<span class="string">&#x27;8443&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&#x27;8009&#x27;</span> <span class="attr">protocol</span>=<span class="string">&#x27;AJP/1.3&#x27;</span> <span class="attr">redirectPort</span>=<span class="string">&#x27;8443&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&#x27;Catalina&#x27;</span> <span class="attr">defaultHost</span>=<span class="string">&#x27;localhost&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&#x27;localhost&#x27;</span>  <span class="attr">appBase</span>=<span class="string">&#x27;webapps&#x27;</span> <span class="attr">unpackWARs</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">autoDeploy</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Server: Server代表整个服务器, 在8005端口监听关闭命令”SHUTDOWN”. Server下有一个叫Catalina的默认Service. </li><li>Service: Service里定义了两个Connector, 一个是HTTP协议一个是AJP协议; 还定义了一个叫Catalina的Engine. </li><li>Engine: Engine里定义了一个名为localhost的Host. <ul><li>defaultHost属性代表接收到的请求域名如果在所有Host的name和Alias都找不到时使用默认的Host. 如果使用IP直接访问也会用到defaultHost, 如果删掉该属性, 启动后通过IP就没有办法访问咯.</li></ul></li><li>Host: 一个Host就代表一个主机咯. <ul><li>name属性代表主机名, 上面定义的主机名为localhost, 所以可以通过localhost可以访问. </li><li>appBase属性指定站点的位置, 比如上面定义的站点就是默认的webapps目录. </li><li>unpackWARs属性代表是否自动解压war文件</li><li>autoDeploy属性为true代表Tomcat在运行过程中在webapps目录中加入新的应用将会自动部署并启动.</li></ul></li><li>Alias: 这个是Host下的一个标签, 这个标签定义主机别名. 比如你可以把Engine的defaultHost属性删掉, 然后再加上Alias标签, 标签内的值为<a href="http://www.localhost/">www.localhost</a>, 那么就能通过 <a href="http://www.localhost/">www.localhost</a> 主机别名也能访问了.</li></ul><p>Context的三种配置方法: </p><ul><li><ol><li>通过文件配置(有5个位置)</li></ol><ul><li>1.1 conf&#x2F;server.xml文件中的Context标签. (配置单独的应用)</li><li>1.2 conf&#x2F;[enginename]&#x2F;[hostname]&#x2F;目录下以应用命名的xml文件. (配置单独的应用)</li><li>1.3 应用自己的&#x2F;META-INF&#x2F;context.xml文件. (配置单独的应用)</li><li>1.4 conf&#x2F;context.xml文件. (整个Tomcat中共享, Tomcat重启时才重新加载)</li><li>1.5 conf&#x2F;[enginename]&#x2F;[hostname]&#x2F;context.xml.default文件. (整个Host中共享)</li></ul></li><li><ol start="2"><li>将WAR应用直接放到Host目录下, Tomcat会自动查找并添加到Host中.</li></ol></li><li><ol start="3"><li>将应用文件夹放到Host目录下, Tomcat也会自动查找并添加到Host中.</li></ol></li></ul><p>Wrapper的配置就是再web.xml中配置的Servlet, 一个Servlet对应一个Wrapper. 也可以在conf&#x2F;web.xml文件中配置全局的Wrapper, 处理Jsp的JspServlet就配置在这里, 所有不需要自己配置Jsp就可以处理Jsp请求了. </p><p>注: conf&#x2F;web.xml配置了两个全局Servlet, 一个是DefaultServlet, 另一个是JspServlet, 分别负责处理一些媒体文件和jsp文件. 如果应用中配置了对应的url-pattern标签将会覆盖这两个默认的Servlet. 所有在使用SpringMVC配置DispatcherServlet的mapping为&#x2F;的时候, 会覆盖DefaultServlet, 这时类似.jpg, .png这种静态资源就得不到处理, 所以就会报404错误, 所以对于这些静态资源在SpringMVC里需要做格外的处理. </p><p>由于Service下的所有站点都是共享Connector, 所以监听的端口都一样. 如果想要添加监听不同端口的站点可以通过不同的Service配置, Service也是在conf&#x2F;server.xml文件中配置的. </p><p>&#x2F;&#x2F; TODO 然后巴拉巴拉就是Container启动的内容了, 这我懒了不写了, 启动完就会启动下面的管道了</p><h3 id="4-2-8-Pipeline-Value管道"><a href="#4-2-8-Pipeline-Value管道" class="headerlink" title="4.2.8 Pipeline-Value管道"></a>4.2.8 Pipeline-Value管道</h3><p>Container处理请求是使用Pipeline-Value管道来处理的. 这种处理方式能确保每一层都能有序的执行到, 从顶层Engine到Host到Context再到Wrapper…<br>这个模式类似于设计模式中的<strong>责任链模式</strong>. 但又有几点不同: </p><ul><li><ol><li>每个Pipeline都有特定的Valve(对, 是Valve不是Value), 且是最后一个执行, 这个Valve叫BaseValve, 是不可删除滴.</li></ol></li><li><ol start="2"><li>上层容器的管道的BaseValve会调用下层容器的管道. 四个容器的BaseValve分别是StandardEngineValve, StandardHostValve, StandardContextValve, StandardWrapperValve.</li></ol></li></ul><p>它们的执行流程如下图: </p><p><img src="/picture/2020-11-09-10-45-31.png"></p><p>在Engine的管道中依次执行Engine的各个Valve, 最后执行StandardEngineValve用于调用Host的管道, 然后执行Host的Valve, 这样依此类推执行Wrapper管道中的StandardWrapperValve. </p><p>在Filter中用到的FilterChain其实就是这种模式, FilterChain相当于Pipeline, 每个Filter都相当于一个Valve, Servlet相当于最后的BaseValve. </p><p>管道呢既是一个组件(所以有生命周期), 又是拿来处理请求的, 所以就分两部分咯. </p><ul><li>首先就是org.apache.catalina.core.ContainerBase的startInternal()和stopInternal()对管道进行启动和关闭. </li><li>然后处理请求是调用Valve的invoke()方法, 比如org.apache.catalina.core.StandardEngineValve中处理完会调用host的首个Valve, 一层一层下来直到最后的StandardWrapperValve.</li></ul><p>所以总的流程就是, Connector在接收到请求之后会调用最顶层容器的Pipeline来处理, 最顶层处理完会在BaseValve里调用下一层容器的Pipeline处理, 这样可以逐层调用所有容器的Pipeline来处理. 处理到最后, Wrapper的Pipeline最后会在其BaseValue(StandardWrapperValve)中创建FilterChain并调用其doFilter方法来处理请求, FilterChain包含着我们配置的与请求相匹配的Filter和Servlet, 其doFilter方法会依次调用所有Filter的doFilter方法和Servlet的service方法, 这样请求就得到处理了. </p><h3 id="4-2-9-Connector分析"><a href="#4-2-9-Connector分析" class="headerlink" title="4.2.9 Connector分析"></a>4.2.9 Connector分析</h3><p>简单来说Connector用来接收请求然后封装成Request和Response来具体处理, 它的底层就是使用Socket来进行连接的, Request和Response是按照HTTP协议来封装的, 所以Connector同时实现了TCP&#x2F;IP协议和HTTP协议, 封装完之后就交给Container进行处理, Container就是Servlet的容器, 处理完后再返回给Connector最后Connector使用Socket将处理结果返回给客户端, 整个请求就处理完了. 作者提供的结构关系图: </p><p><img src="/picture/2020-11-09-11-54-34.jpg"></p><p>&#x2F;&#x2F; TODO: 砍刀部动手, 这部分细节就砍了</p><h2 id="4-3-Spring-MVC"><a href="#4-3-Spring-MVC" class="headerlink" title="4.3 Spring MVC"></a>4.3 Spring MVC</h2><h3 id="4-3-1-整体结构"><a href="#4-3-1-整体结构" class="headerlink" title="4.3.1 整体结构"></a>4.3.1 整体结构</h3><p>上一波Spring MVC中核心的继承结构图: </p><p><img src="/picture/2020-11-09-14-24-42.png"></p><p>图中Java方面的三个类之前已经讲过了, 下面都是讲SpringMVC中的HttpServletBean, FrameworkServlet和DispatcherServlet这三个类.<br>这三个类直接实现三个接口, EnvironmentAware, EnvironmentCapable, ApplicationContextAware. 这种XXXAware在Spring里表示对XXX可感知, 也就是说某个类想使用Spring的一些东西, 可以实现这个接口然后实现对应的set方法, Spring就会给你带过来. </p><h3 id="4-3-2-HttpServletBean介绍"><a href="#4-3-2-HttpServletBean介绍" class="headerlink" title="4.3.2 HttpServletBean介绍"></a>4.3.2 HttpServletBean介绍</h3><p>在之前对Servlet的分析时, 我们知道创建Servlet时, 它的init()方法会被容器调用, 而org.springframework.web.servlet.HttpServletBean的init()方法将Servlet中配置的参数使用BeanWrapper设置到DispatcherServlet的相关属性中, 然后调用模板方法initServletBean(), 子类就通过这个方法初始化. </p><p>对于这个HttpServletBean, 它的上一级GenericServlet有一个使用transient修饰的ServletConfig, 这个修饰符表示修饰的内容不会被序列化, 在这里可能是config不是很重要所以不用序列化吧. </p><p>注: BeanWrapper怎么用? 它是Spring提供的操作JavaBean属性的工具, 用它可以直接修改一个对象的属性. 作者举了个例子: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanWrapperTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        bw.setPropertyValue(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">        <span class="type">PropertyValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        bw.setPropertyValue(value);</span><br><span class="line">        System.out.println(user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-FrameworkServlet介绍"><a href="#4-3-3-FrameworkServlet介绍" class="headerlink" title="4.3.3 FrameworkServlet介绍"></a>4.3.3 FrameworkServlet介绍</h3><p>根据上面HttpServletBean可知, 这个FrameworkServlet的初始化入口方法是initServletBean(), 然后它的核心代码主要是初始化WebApplicationContext还有初始化FrameworkServlet. &#x2F;&#x2F; TODO: 下面巴拉巴拉就懒得写了</p><h3 id="4-3-4-DispatcherServlet介绍"><a href="#4-3-4-DispatcherServlet介绍" class="headerlink" title="4.3.4 DispatcherServlet介绍"></a>4.3.4 DispatcherServlet介绍</h3><p>onRefresh()方法是DispatcherServlet入口方法, DispatcherServlet的创建过程主要是对9大组件进行初始化. </p><h3 id="4-3-5-HttpServletBean使用"><a href="#4-3-5-HttpServletBean使用" class="headerlink" title="4.3.5 HttpServletBean使用"></a>4.3.5 HttpServletBean使用</h3><p>作者说这个东西主要参与了创建工作, 没有涉及请求的处理. </p><h3 id="4-3-6-FrameworkServlet使用"><a href="#4-3-6-FrameworkServlet使用" class="headerlink" title="4.3.6 FrameworkServlet使用"></a>4.3.6 FrameworkServlet使用</h3><ul><li>对service()方法添加了对PATCH的处理, 将需要自己处理的请求都集中到了processRequest()进行统一处理, 这和HttpServlet中根据request的类型分开到不同方法处理相反. </li><li>processRequest里面主要的处理逻辑交给了doService, 这是一个模板方法等子类实现. 然后就是对request获取到的LocaleContext和RequestAttributes进行了保存, 处理完之后恢复, 最后发布了ServletRequestHandleEvent事件.</li></ul><h3 id="4-3-7-DispatcherServlet使用"><a href="#4-3-7-DispatcherServlet使用" class="headerlink" title="4.3.7 DispatcherServlet使用"></a>4.3.7 DispatcherServlet使用</h3><p>通过前面分析, 它的入口方法是doService()…&#x2F;&#x2F; TODO: 具体的就不再写了, 这个类主要解释三个概念: HandlerMapping, Handler和HandlerAdapter. </p><ul><li>Handler: 也就是处理器, 它直接对应MVC中的C也就是Controller层, 它的具体表现形式有很多, 可以是类也可以是方法, 作者说如果你想到别的表现形式也可以使用, 它的类型是Object嘛. 在平常我们写Controller时标注的@RequestMapping的方法都可以看成一个Handler, 只要可以实际处理请求就可以是Handler. </li><li>HandlerMapping: SpringMVC中会处理很多请求, 每个请求都需要一个Handler来处理, 而它就是拿来查找Handler的. </li><li>HandlerAdapter: 从名字能看出它是一个适配器, 因为Handler可以是任意形式的, 但是Servlet处理的方法结构是固定的, 都是以request和response为参数的方法(如doService方法), 而这个HandlerAdapter就是让固定的Servlet处理方法调用灵活的Handler来处理.</li></ul><p>另外View和ViewResolver的原理也和这个类似. View是用来展示数据的, 而ViewResolver用来查找View. View就像是模板, Model就是数据, ViewResolver就是使用哪个模板. </p><p>这一节doDispatch()内容有点多, &#x2F;&#x2F;TODO: 以后再补了直接上图: </p><p><img src="/picture/2020-11-09-17-07-08.jpg"></p><p>三个Servlet的处理过程大致如下: </p><ul><li><p>HttpServletBean: 没有参与实际请求的处理. </p></li><li><p>FrameworkServlet: 将不同类型的请求合并到了processRequest方法统一处理, processRequest主要做了: </p><ul><li>调用doService模板方法具体处理请求. </li><li>将LocaleContext和ServletRequestAttributes在请求前设置到了LocaleContextHolder和RequestContextHolder, 并在请求处理完成后恢复. </li><li>请求处理完后发布了ServletRequestHandledEvent事件.</li></ul></li><li><p>DispatcherServlet: doService方法给request设置了一些属性并将请求交给doDispatch方法具体处理.</p></li></ul><p>DispatcherServlet中的doDispatch方法完成了SpringMVC中请求处理过程的顶层设计, 它使用了DispatcherServlet中的九大组件完成了具体的请求处理. </p><h2 id="4-4-Spring-MVC组件"><a href="#4-4-Spring-MVC组件" class="headerlink" title="4.4 Spring MVC组件"></a>4.4 Spring MVC组件</h2><p>作者要跟我们讲讲DispatcherServlet中直接初始化的那9个组件啦. </p><h3 id="4-4-1-组件整体概览"><a href="#4-4-1-组件整体概览" class="headerlink" title="4.4.1 组件整体概览"></a>4.4.1 组件整体概览</h3><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>它只有一个getHandler()方法返回HandlerExecutionChain.<br>它的作用是根据request找到相应的处理器Handler和Interceptor.<br>查找Handler是按照顺序遍历所有的HandlerMapping, 当找到一个HandlerMapping后立即停止查找并返回.<br>在org.springframework.web.servlet.DispatcherServlet中, getHandler()会遍历所有的HandlerMapping, 当其中一个HandlerMapping返回了HandlerExecutionChain之后就直接返回. </p><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>它有三个方法: </p><ul><li>supports() 判断是否可以使用某个Handler</li><li>handle() 是用来具体使用Handler干活. </li><li>getLastModified() 是获取资源的LastModified, 资源最后一次修改时间</li></ul><p>在org.springframework.web.servlet.DispatcherServlet中, getHandlerAdapter()将遍历所有的HandlerAdapter, 找到一个support对应handler的Adapter就直接返回. </p><h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>其他工作的组件工作中可能出现问题, 那出现问题后咋办咧? 很明显我们需要一个专门的角色对异常情况进行处理. 在SpringMVC中这个角色就是HandlerExceptionResolver.<br>简单来说这个组件就是根据异常解析出ModelAndView, 然后再交给render方法进行渲染. 因为它在render之前工作的, 解析出ModelAndView之后render才去渲染, 所以它就不能处理render过程中的异常了. </p><p>&#x2F;&#x2F; TODO 懒了</p><h3 id="SpringMVC总结"><a href="#SpringMVC总结" class="headerlink" title="SpringMVC总结"></a>SpringMVC总结</h3><p>Spring MVC是Spring的Web MVC模式框架,它主要是围绕处理请求分发的DispatcherServlet来设计的.它的具体流程如图4所示.</p><p><img src="/picture/2021-03-01-23-18-17.jpg"><br>DispatcherServlet的处理工作流</p><p>Spring MVC的处理又和J2EE默认的分请求处理不一样,在这里它又用DispatcherServlet统一进行处理了,而请求如何进行处理又交给了doDispatch()方法来处理,其实就是调用各种相关的组件来各自处理.要解释各组件的处理流程,首先要分清楚三个概念.<br>1.Handler<br>Handler是处理器,它可以直接对应到MVC中的Controller层,它有很多种表现形式,可以是类也可以是方法,只要可以处理实际请求的就是Handler.比如项目中使用注解@RequestMapping标注的方法就是一个Handler.<br>2.HandlerMapping<br>HandlerMapping是处理器映射器的意思,它主要用来将请求映射到相应的Handler来处理.<br>3.HandlerAdapter<br>HandlerAdapter是处理器适配器,因为Handler可以是多种形式的因此十分灵活,但是Servlet处理请求的方法是固定的,因此需要有这个适配器来将灵活的Handler转换成能供Servlet调用的方式来处理.</p><p>同样View和ViewResolver的原理也和上面三个概念的抽象类似,View是用来展示数据的模板,Model是数据,ViewResolver是用来查找使用哪个View模板来渲染的.</p><p>因此DispatcherServlet的处理工作流程如下:<br>1.客户端向服务器发送请求(Incoming request).<br>2.请求被前端控制器(Front controller主要是DispatcherServlet)捕获,组件HandlerMapping根据URI(请求资源标识符)获得相关的Handler.<br>3.DispatcherServlet将使用适合的HandlerAdapter来处理获得的Handler.(如果成功获得HandlerAdapter那就会执行相应Interceptor的preHandle()方法)<br>4.HandlerAdapter使用Handler处理请求.(在此之前根据配置Spring会帮你做一些格外的工作,比如提取request作为Handler的入参,数据转换,数据格式化,数据验证等.处理完后执行相应Interceptor的postHandle()方法)<br>5.Controller(也就是Handler被)执行完之后返回一个model对象.<br>6.前端控制器根据返回的model对象和view来选择合适的视图解析器(ViewResolver).<br>7.视图解析器通过model来对响应(response)进行渲染.<br>8.前端控制器根据返回的渲染结果返回给客户端</p><h3 id="4-5-总结与补充"><a href="#4-5-总结与补充" class="headerlink" title="4.5 总结与补充"></a>4.5 总结与补充</h3><p>&#x2F;&#x2F; TODO 后面Servlet3.0提供了使用异步处理请求的内容. </p><p>参考: </p><ul><li>书籍: Spring技术内幕：深入解析Spring架</li><li>书籍: 看透Spring_MVC：源代码分析与实践</li><li><a href="https://blog.csdn.net/csujiangyu/article/details/53455094">AOP的实现的几种方式</a></li></ul>]]></content>
    
    
    <summary type="html">记录 Spring 的学习笔记</summary>
    
    
    
    
    <category term="Note" scheme="https://someexp.com/tags/Note/"/>
    
    <category term="Java" scheme="https://someexp.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://someexp.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 搭建图片服务器</title>
    <link href="https://someexp.com/2020/serve-image-with-nginx/"/>
    <id>https://someexp.com/2020/serve-image-with-nginx/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2022-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Docker 和 Nginx 搭建图片服务器的示例.</p><span id="more"></span><p>&#x2F;&#x2F; docker挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/nginx/www /home/nginx/logs /home/nginx/conf /home/nginx/www/image /home/nginx/www/image/ /home/nginx/www/image/info_detail</span><br><span class="line">touch /home/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>修改配置文件nginx.conf: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">user  root root;</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"> </span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location /images/ &#123;</span><br><span class="line">            root   /usr/share/nginx/html/;</span><br><span class="line">            autoindex on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>创建并运行Nginx容器, 443为https端口. 但这里没有用到https </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx-image-server \</span><br><span class="line">-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /home/nginx/www:/usr/share/nginx/html \</span><br><span class="line">-v /home/nginx/logs:/var/log/nginx \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>这时候nginx服务器就已经搭建好了, 可以在&#x2F;home&#x2F;nginx&#x2F;www下创建index.html, 然后通过ip可以直接访问这时候就成功了. </p><p>安装vsftpd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><p>添加用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd infoimage // 创建用户</span><br><span class="line">passwd infoimage // 设置用户密码为下面这段</span><br><span class="line">45g2rVaZ8R9GGka8</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><h1 id="配置文件默认为YES，即支持匿名访问，设置为不支持"><a href="#配置文件默认为YES，即支持匿名访问，设置为不支持" class="headerlink" title="配置文件默认为YES，即支持匿名访问，设置为不支持"></a>配置文件默认为YES，即支持匿名访问，设置为不支持</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=NO</span><br></pre></td></tr></table></figure><h1 id="在最后添加这3行"><a href="#在最后添加这3行" class="headerlink" title="在最后添加这3行"></a>在最后添加这3行</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=30000</span><br><span class="line">pasv_max_port=30009</span><br></pre></td></tr></table></figure><p>保存退出后设置用户访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown infoimage /home/nginx/www/image</span><br><span class="line">chmod 777 -R /home/nginx/www/image</span><br></pre></td></tr></table></figure><p>启动vsftp服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd.service</span><br></pre></td></tr></table></figure><p>然后关闭防火墙或者开启一些端口(开启的话要开挺多的…测试就关闭防火墙来测试了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status vsftpd.service</span><br><span class="line">systemctl stop vsftpd.service</span><br></pre></td></tr></table></figure><p>关闭用户鉴权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pam.d/vsftpd</span><br></pre></td></tr></table></figure><p>注释掉&#x2F;etc&#x2F;pam.d&#x2F;vsftpd文件里这一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#auth required pam_shells.so</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure><p>头像路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown infoimage /home/nginx/www/head</span><br><span class="line">chmod 777 -R /home/nginx/www/head</span><br></pre></td></tr></table></figure><p>ftp连接(账户密码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.76.56:21</span><br><span class="line">infoimage</span><br><span class="line">45g2rVaZ8R9GGka8</span><br></pre></td></tr></table></figure><p>如果连接上后不显示文件夹<br>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、vi /etc/selinux/config</span><br><span class="line">2、 将SELINUX=enforcing 改为 SELINUX=disable</span><br><span class="line">3、使改变的内容生效  sudo setenforce 0</span><br><span class="line">4、重启vsftpd</span><br></pre></td></tr></table></figure><p>上传图片到image后, 图片示例地址(虚拟机ip):<br>http:&#x2F;&#x2F;虚拟机ip&#x2F;image&#x2F;20200505_14-36-29.jpg</p><h1 id="服务出问题的终极解决办法"><a href="#服务出问题的终极解决办法" class="headerlink" title="服务出问题的终极解决办法"></a>服务出问题的终极解决办法</h1><p>1.查看防火墙状态并关闭: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看防火墙状态</span><br><span class="line">systemctl status firewalld.service</span><br><span class="line">// 查看已开放的端口(默认不开放任何端口)</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line">// 关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p>2.查看docker里的nginx容器运行状态, 重启nginx容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看运行中的容器</span><br><span class="line">docker ps</span><br><span class="line">// 停止运行中的容器</span><br><span class="line">docker stop containner_id</span><br><span class="line">// 启动停止的容器</span><br><span class="line">docker start containner_id</span><br><span class="line">// 或者一条命令重新启动容器</span><br><span class="line">docker restart containner_id</span><br></pre></td></tr></table></figure><p>3.重启整个docker进程, 再继续运行相应容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 重启docker进程</span><br><span class="line">systemctl restart docker</span><br><span class="line">// 查看所有容器(包括未运行)</span><br><span class="line">docker ps -a</span><br><span class="line">// 启动相应容器</span><br><span class="line">docker start containner_id</span><br></pre></td></tr></table></figure><p>4.删除创建的容器, 重新从镜像生成一个容器并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 删除之前停止的容器</span><br><span class="line">docker rm containner_id</span><br><span class="line">// 重新从镜像生成一个容器并运行</span><br><span class="line">docker run -d -p 80:80 --name nginx-image-server \</span><br><span class="line">-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /home/nginx/www:/usr/share/nginx/html \</span><br><span class="line">-v /home/nginx/logs:/var/log/nginx \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>有时候上面的配置都没问题, 就是ping不通, 可以禁用对应的网卡再启用试试. </p><p>参考:<br><a href="https://www.cnblogs.com/lyuzt/p/12575390.html">https://www.cnblogs.com/lyuzt/p/12575390.html</a></p>]]></content>
    
    
    <summary type="html">使用 Docker 和 Nginx 搭建图片服务器的示例.</summary>
    
    
    
    
    <category term="Note" scheme="https://someexp.com/tags/Note/"/>
    
    <category term="Nginx" scheme="https://someexp.com/tags/Nginx/"/>
    
    <category term="Docker" scheme="https://someexp.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>快速操作笔记</title>
    <link href="https://someexp.com/2020/quick-operation-note/"/>
    <id>https://someexp.com/2020/quick-operation-note/</id>
    <published>2020-05-28T16:00:00.000Z</published>
    <updated>2020-05-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>那些搜索过两次以上的解决办法. </p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="CentOS7配置静态ip"><a href="#CentOS7配置静态ip" class="headerlink" title="CentOS7配置静态ip"></a>CentOS7配置静态ip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=</span><br><span class="line">NETMASK=</span><br><span class="line">GATEWAY=</span><br><span class="line">DNS1=</span><br><span class="line">DNS2=</span><br></pre></td></tr></table></figure><h2 id="CentOS7-ifconfig-command-not-found"><a href="#CentOS7-ifconfig-command-not-found" class="headerlink" title="CentOS7 ifconfig command not found"></a>CentOS7 ifconfig command not found</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装net-tools</span><br><span class="line">sudo yum install net-tools</span><br></pre></td></tr></table></figure><h2 id="CentOS7修改软件源"><a href="#CentOS7修改软件源" class="headerlink" title="CentOS7修改软件源:"></a>CentOS7修改软件源:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 下面的操作结果还有点问题, 懒得搞了</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">// 安装weget</span><br><span class="line">yum install -y wget</span><br><span class="line">// 下载CentOS 7的repo文件</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repop://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">// 或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">// 清除缓存</span><br><span class="line">yum clean all</span><br><span class="line">// 生成缓存</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="CentOS7安装Docker"><a href="#CentOS7安装Docker" class="headerlink" title="CentOS7安装Docker"></a>CentOS7安装Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 切换root用户</span><br><span class="line">// 照着官网教程跑, 修改为阿里云的镜像</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">// 启动并加入开机启动</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="CentOS7防火墙"><a href="#CentOS7防火墙" class="headerlink" title="CentOS7防火墙"></a>CentOS7防火墙</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 开启防火墙</span><br><span class="line">systemctl start firewalld</span><br><span class="line">// 关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">// 查看已开放的端口(默认不开放任何端口)</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line">// 开启80端口</span><br><span class="line">// --zone(作用域), --add-port(端口和访问类型) , --permanent(永久生效) 记得重启</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">// 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">// 禁止防火墙开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">// 删除</span><br><span class="line">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 列出所有用户的</span><br><span class="line">ps -aux</span><br><span class="line">// 杀掉进程</span><br><span class="line">kill -9 &#123;pid&#125;</span><br><span class="line">// 后台运行</span><br><span class="line">nohup ./frps -c frps.ini &gt;/home/lighthouse/frp/frp_0.39.0_linux_amd64/log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="CentOS7使用Docker"><a href="#CentOS7使用Docker" class="headerlink" title="CentOS7使用Docker"></a>CentOS7使用Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 列出所有镜像</span><br><span class="line">docker images</span><br><span class="line">// 删除镜像(需要先停止容器)</span><br><span class="line">docker rmi image_id</span><br><span class="line">// 运行 --name(容器名) -i(交互模式) -t(tty打开终端) -d(后台运行)(可以合成-itd) -p 容器外:容器内(端口映射) image-name:tag(版本) </span><br><span class="line">docker run --name container-name -d image-name:tag</span><br><span class="line">如:docker run --name myredis –d redis</span><br><span class="line">// 查看运行中容器命令 -a(全部)</span><br><span class="line">docker ps</span><br><span class="line">// 停止容器</span><br><span class="line">docker stop container_id</span><br><span class="line">// 启动容器</span><br><span class="line">docker start container_id</span><br><span class="line">// 删除容器</span><br><span class="line">docker rm container_id</span><br><span class="line">// 进入容器</span><br><span class="line">docker exec -it container_id /bin/bash</span><br><span class="line">// 使用当前目录的 Dockerfile 创建镜像，镜像名字:版本号</span><br><span class="line">docker build -t 名字:版本号 .</span><br><span class="line">示例: docker build -t runoob/ubuntu:v1 .</span><br><span class="line">// 启动时配置文件挂载 </span><br><span class="line">示例: docker run -p 82:80 --name nginx1 -v /src/nginx/nginx.conf:/etc/nginx/nginx.conf -d nginx</span><br><span class="line">// 拷贝文件进容器(覆盖)</span><br><span class="line">示例: docker cp nginx.conf nginx1:/etc/nginx/nginx.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误:<br>WARNING: IPv4 forwarding is disabled. Networking will not work.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 有些容器好像默认是ipv6, 需要指定ipv4, 或者修改系统配置:</span><br><span class="line"> /usr/lib/sysctl.d/00-system.conf</span><br><span class="line">// 中添加</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">// 再重启</span><br><span class="line"> systemctl restart network</span><br><span class="line"></span><br><span class="line"> // mysql时区问题 </span><br><span class="line"> # docker exec -it 5c02cf9db889 bash</span><br><span class="line"># date</span><br><span class="line"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">退出重启docker</span><br><span class="line"># exit</span><br><span class="line"># docker restart 5c02cf9db889</span><br></pre></td></tr></table></figure><h2 id="CentOS7网卡地址-路径"><a href="#CentOS7网卡地址-路径" class="headerlink" title="CentOS7网卡地址, 路径"></a>CentOS7网卡地址, 路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 服务器运行jar定义输出</span><br><span class="line">nohup java -jar getCimiss-surf.jar &gt;consoleMsg.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">tail -fn 50 nohup.out</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos // 从镜像仓库下载镜像</span><br><span class="line">docker images // 列出所有本地镜像</span><br><span class="line">docker run -it &#123;id&#125;  // 运行某个容器 --name给它名字</span><br><span class="line">docker run -it -p &#123;外部暴露端口&#125;:&#123;容器内部端口&#125; &#123;name&#125; // 小p是指定端口, 大P是随机端口</span><br><span class="line"></span><br><span class="line">exit  // 关闭退出容器</span><br><span class="line">Ctrl P Q  // 不关闭退出容器</span><br><span class="line">docker attach &#123;id&#125; // 重新回到容器</span><br><span class="line"></span><br><span class="line">docker start &#123;id&#125; // 启动容器</span><br><span class="line"></span><br><span class="line">stop // 停止容器</span><br><span class="line">kill // 强制停止</span><br><span class="line"></span><br><span class="line">docker ps -l   // 上一次运行的容器</span><br><span class="line">docker ps -n &#123;n&#125; // 上n次运行的</span><br><span class="line"></span><br><span class="line">docker rmi &#123;id&#125; // 删除镜像</span><br><span class="line">docker rm &#123;id&#125; // 删除已停止容器</span><br><span class="line"></span><br><span class="line">docker run -d &#123;name&#125; // 运行在后台了, 如果它没有什么任务会自动关闭</span><br><span class="line"></span><br><span class="line">docker logs -t时间 -f实时刷新 &#123;id&#125; // 查看容器日志</span><br><span class="line"></span><br><span class="line">docker top &#123;id&#125; // 查看容器内进程</span><br><span class="line"></span><br><span class="line">docker inspect &#123;id&#125; // 查看容器内部细节(盒子)</span><br><span class="line"></span><br><span class="line">docker exec -t &#123;id&#125; &#123;command&#125; // 直接执行命令, 不需要进入容器</span><br><span class="line"></span><br><span class="line">docker cp &#123;id&#125;:&#123;容器文件路径&#125; &#123;宿主机路径&#125; // 将文件拷贝到宿主机持久化</span><br><span class="line"></span><br><span class="line">docker commit -a=&quot;作者名&quot; -m=&quot;描述&quot; &#123;id&#125; &#123;命名空间/镜像名&#125;:&#123;version&#125; // 就是保存为自己的镜像</span><br><span class="line"></span><br><span class="line">// 容器数据卷(相当于外部硬盘, 用来持久化容器数据, 可以修改读写权限)</span><br><span class="line">docker run -it -v &#123;宿主机目录&#125;:&#123;容器内目录&#125; &#123;name&#125;</span><br><span class="line"></span><br><span class="line">docker inspect &#123;id&#125; // 查看容器详情</span><br><span class="line"></span><br><span class="line">// DockerFile相当于描述Docker镜像的文件(添加卷或者命令等), 可以通过image+DockerFile生成新的image: </span><br><span class="line">docker build -f &#123;DockerFile路径&#125; -t &#123;命名空间/镜像名&#125;</span><br><span class="line"></span><br><span class="line">// 容器继承, 继承的容器卷内容能实现共享. 容器之间配置信息的传递, 数据卷的生命周期一直持续到没有容器使用它为止. </span><br><span class="line"></span><br><span class="line">// 保留字指令: </span><br><span class="line">FROM 基础镜像, 当前镜像基于哪个镜像, 顶层是scratch</span><br><span class="line">MAINTAINER 维护者的名字邮箱</span><br><span class="line">RUN 容器构建时需要运行的命令</span><br><span class="line">EXPOSE 当前容器对外暴露出的端口号</span><br><span class="line">WORKDIR 登录容器后的默认路径</span><br><span class="line">ENV 构建时设置环境变量</span><br><span class="line">ADD 将宿主机目录下的文件拷贝+解压缩进镜像, ADD会自动解压tar</span><br><span class="line">COPY 类似ADD但直接拷贝没有解压</span><br><span class="line">VOLUME 容器数据卷, 用于数据保存和持久化工作</span><br><span class="line">CMD 指定容器启动时要运行的命令, 可以有多个CMD命令, 但是只有最后一个命令会生效, CMD会被docker run之后的参数覆盖</span><br><span class="line">ENTRYPOINT 和CMD一样, 都是在指定容器启动程序及参数(不会覆盖, 会被追加组合使用)</span><br><span class="line">ONBUILD 父镜像在被子镜像继承后这个命令构建时会被触发</span><br><span class="line"></span><br><span class="line">dockerfile示例: </span><br><span class="line">FROM centos // 父镜像</span><br><span class="line">MAINTAINER xxxyyy&lt;xxyyy@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim // 安装vim</span><br><span class="line">RUN yum -y install net-tools // 安装网络工具</span><br><span class="line"></span><br><span class="line">EXPOSE 80 // 暴露端口</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success ===== ok&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line">构建示例: </span><br><span class="line">docker build -f /mydocker/Dockerfile -t mycentos:1.3 .</span><br><span class="line"></span><br><span class="line">docker history &#123;镜像id&#125; // 列出镜像变更历史</span><br><span class="line"></span><br><span class="line">docker配置代理示例: </span><br><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br><span class="line">vi /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://192.168.52.1:7890/&quot; &quot;HTTPS_PROXY=http://192.168.52.1:7890/&quot;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker使用Redis"><a href="#Docker使用Redis" class="headerlink" title="Docker使用Redis"></a>Docker使用Redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 进入容器</span><br><span class="line">docker exec -it container_id /bin/bash</span><br><span class="line"></span><br><span class="line">// 使用redis-cli, h-host, p-port, a-password</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a 123456</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Docker使用Mysql"><a href="#Docker使用Mysql" class="headerlink" title="Docker使用Mysql"></a>Docker使用Mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 忽略大小写敏感</span><br><span class="line">docker run --name WinMysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.30 --lower_case_table_names=1</span><br></pre></td></tr></table></figure><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h2 id="添加错文件"><a href="#添加错文件" class="headerlink" title="添加错文件"></a>添加错文件</h2><p>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了<br>然后再checkout就好了</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>清空表数据, id从1开始: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table TABLE_NAME</span><br></pre></td></tr></table></figure><p>mysqldump 数据参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- --column-statistics=0 修复高版本 mysqldump 导出低版本数据</span><br><span class="line">-- -d 表示不导出数据只导出表结构</span><br><span class="line">&quot;DATABASE_NAME&quot; -d --column-statistics=0 --result-file=&quot;C:\\Users\\i\\Desktop\\&#123;data_source&#125;-&#123;timestamp&#125;-dump.sql&quot;</span><br></pre></td></tr></table></figure><h1 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h1><h2 id="导出数据字典"><a href="#导出数据字典" class="headerlink" title="导出数据字典"></a>导出数据字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">TABLE_NAME &#x27;表名&#x27;,</span><br><span class="line">COLUMN_NAME &#x27;字段名&#x27;,</span><br><span class="line">COLUMN_TYPE &#x27;数据类型&#x27;,</span><br><span class="line">COLUMN_COMMENT &#x27;备注&#x27;</span><br><span class="line">FROM</span><br><span class="line">information_schema.COLUMNS</span><br><span class="line">WHERE</span><br><span class="line">TABLE_SCHEMA = &#x27;admin&#x27; and table_name = &#x27;sys_menu&#x27;;</span><br></pre></td></tr></table></figure><h1 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h1><p>对你没看错还有ps的. </p><h2 id="抠出照片的文字"><a href="#抠出照片的文字" class="headerlink" title="抠出照片的文字"></a>抠出照片的文字</h2><p>选择 -&gt; 色彩范围 -&gt; 然后选择选’阴影’, 下面选’灰度’, 容易看些. </p><h1 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h1><h2 id="使用其他用户运行"><a href="#使用其他用户运行" class="headerlink" title="使用其他用户运行"></a>使用其他用户运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /user:&#123;USERNAME&#125; /savecred &#123;Full path of file&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;那些搜索过两次以上的解决办法. &lt;/p&gt;</summary>
    
    
    
    
    <category term="Note" scheme="https://someexp.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>看过的书</title>
    <link href="https://someexp.com/2020/the-book-i-read/"/>
    <id>https://someexp.com/2020/the-book-i-read/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2024-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>非计算机相关的书单. 计算机类的书单请请看<a href="/2021/books-about-computer-science">这里这里</a>. </p><span id="more"></span><p><strong>2025:</strong></p><p><strong>一想到还有95%的问题留给人类，我就放心了</strong><br>关于暗物质暗能量, 惯性质量引力质量, 空间时间的科普书.<br>迷茫而找不到解释的体验是非常珍贵的, 也正因如此, 魔术表演才显得十分有趣.</p><p><strong>2024:</strong></p><p><strong>太阳能光伏发电系统设计及安装</strong><br>瑞安·梅菲尔德 9787115278517 </p><p><strong>住宅设计解剖书</strong></p><p><strong>统计数据会说谎</strong></p><p><a href="/book/color-basic-design">色彩设计的原理 笔记</a></p><p><a href="/book/9787508693156">你的第一本保险指南(槽叔) 笔记</a></p><p><strong>2023:</strong></p><p><strong>皮肤的秘密</strong></p><p>感觉这本书是 人体的故事 皮肤向很好的补充.</p><p><strong>how to如何不切实际地解决实际问题</strong></p><p>书如其名, 用科学的视角从不同角度来解决问题.</p><p><strong>丁香医生人体调查组</strong></p><p>内容就是公众号的文章合订本. </p><p><strong>What if？那些古怪又让人忧心的问题</strong></p><p>如果要用一个词来定义这本书，我会认为是“好奇心”。</p><p><strong>工作, 消费主义和新穷人</strong></p><p>一开始，工作伦理是一种非常有效的手段，它可以帮助急需劳动力的工厂迅速扩充人员。随着劳动力迅速变成提高生产力的障碍，工作伦理仍然可以发挥作用，但这次是作为另一种有效手段：洗涤社会中正常人的双手和良知，帮他们从抛弃同胞致使同胞永久失业的罪责中摆脱出来。在对穷人的道德进行谴责的同时，对非穷人的道德实施赦免，通过这种双管齐下的方法，达到双手和良心的洁净。</p><p><a href="/book/the-sociology-book">社会学百科 笔记</a></p><p><a href="/book/the-economics-book">经济学百科 笔记</a></p><p><a href="/book/the-philosophy-book">哲学百科 笔记</a></p><p><a href="/book/the-psychology-of-attraction">爱情心理学百科 笔记</a></p><p><strong>家庭收纳1000例</strong></p><p>图文能看出历史的痕迹. 收纳基本规则: 要在使用的地方旁边, 以频度和重量决定收纳位置. 折叠衣服可以参考. 其余内容刷刷刷就过去了.</p><p><strong>心理学百科</strong></p><p>心理学科普书. 简单了解了200多年的心理学发展以及一些概念.</p><p><strong>自我管理之书</strong><br>嗯, 适合调整心态.</p><p><strong>人类食物百科</strong><br>DK 出的一本非常全面系统的关于人类食物的科普书, 感觉比公众号上的科普文章质量要好些.</p><p><strong>枪炮、病菌与钢铁</strong><br>如果说 人体的故事 是从单个人体出发讲述的, 那么这本就是对人群与人群之间, 人与环境之间很好的科普补充.</p><p><strong>农民进城防骗手册</strong><br>看一下一些骗局的基本套路, 没想到2006年的书, 有些骗局在2022年还有.</p><p><strong>人体的故事</strong><br>非常推荐的一本书, 从进化生物学的角度讲解人类身体的故事, 人类在现代环境中产生的一些”失配”疾病.</p><p><strong>2022:</strong></p><p><a href="/book/the-merck-manual-home-health-handbook">默克家庭医学手册 笔记</a></p><p><a href="/book/9787508660196">小家, 越住越大 笔记</a></p><p><strong>蔡康永的说话之道</strong></p><p><a href="/book/make-time">创造时间 笔记</a></p><p><a href="/book/new-york-institute-of-photography">美国纽约摄影学院摄影教材 笔记</a></p><p><a href="/book/english-grammar-in-use">English Grammar In Use 笔记</a></p><p><strong>简读中国史</strong><br>同样是老大推荐的书, 但是老大只是看书评视频并没看过原书. 作者将中国历史放在世界历史中对比和解说, 感觉是很好的历史入门大纲脉络书, 如果毕业后没读过历史书, 基本上对历史的了解也就只停留在教科书层面. 书中谈中外不同文化的形成的原因, 产生的结果, 并联系到今天我们的一些文化观念. 书中有些章节与内容我认为放在当下讨论是比较危险的, 甚至怀疑这本书为什么没被 ban. 总之还是非常推荐的一本.</p><p><strong>2021:</strong></p><p><strong>随机漫步的傻瓜([美]纳西姆·尼古拉斯·塔勒布)</strong><br>老大推荐的书, 也正如老大所说, 作者大部分都在吹吹牛吐吐槽, 但其中有 10% 的个人洞见, 这些洞见就是不错的收获.</p><p><strong>语言学的邀请(Samuel Hayakawa, Alan Hayakawa)</strong><br>当时是问大佬如果只让他推荐一本书, 他会推荐什么? 然后他就推荐了这本. 这是 2021 年我读的第一本, 也是目前来说最推荐的一本, 列入我的人生必读清单的一本. 主要是围绕我们熟悉而又陌生的语言. 文后附了 11 页的参考文献.</p><p><strong>2020:</strong> </p><p><strong>谁动了我的奶酪 Who Moved My Cheese? ([美] 斯宾塞·约翰逊)</strong><br>讲述了四个角色一个寻找奶酪的小故事, 来映射生活中我们遭遇的变化, 以及启发我们如何应对这些变化. </p><p><strong>程序是怎样跑起来的([日] 矢泽久雄)</strong><br>作为计算机系的我自愧不如, 读完感觉打通了任督二脉一样, 连通了学校学的一些概念. 非常推荐. </p><p><strong>无器械健身 : 用自身体重锻练(马克·劳伦)</strong><br>Funny. 好好锻炼. </p><p><strong>幸福断舍离（Gretchen Rubin）</strong><br>作者列出很多很有意思的幸福生活计划. </p><p><strong>人生的智慧：如何幸福度过一生(叔本华)</strong><br>叔本华大部分观点都不错, 但他也不是圣人, 比方说一些对于男女有别的内容放到现在就很容易被群殴噢. </p><p><strong>这样装修不超支、不被宰、不返工</strong><br>很有趣, 学到很多房子水电, 装修相关的内容, 对判断一个房子好不好很有帮助!!! </p><p><strong>活着(余华)</strong><br>同学推荐的书, 也是一直挺想看的. 疫情期间宅在家里消遣看得非常舒服. 余华用风趣的表达方法来写下了一个人一连串的悲剧, 看网评说是很沉重压抑的书, 但我觉得这个文风读得很有趣. 在我看来时代最大的悲剧就是, 就算目前站在上帝视角看过去, 也不知道该如何能过得舒服. 而本书和书名一样, 活着就是活着. </p><p><strong>永久记录(爱德华·斯诺登(Edward Snowden))</strong><br>一直很想看的书, 为什么突然在2020寒假这段时间看了它呢? 因为某些原因, 作者直接免费分享了中文译本, 哈哈哈. 讲了作者自己从小到大的故事, 还有到最后流亡的故事. </p><p><strong>2019 及以前:</strong></p><p><a href="/book/just-listen-discover-the-secret-to-getting-through-to-absolutely-anyone">只需倾听(马克•郭士顿(Mark Goulston)) 笔记</a></p><p><strong>1984(乔治·奥威尔)</strong><br>关于老大哥的书肯定不能错过. </p><p><strong>爱的艺术(艾·弗洛姆)</strong><br>虽然这书评分好高, 但感觉内容十分抽象, 然后草草过了一遍自己评价感觉只能5分, 有机会再读吧. 作者认为 给 比 得 带来更多的愉快，这不是因为“给”是一种牺牲，而是因为通过“给”表现了我的生命力。爱情的积极性除了有给的要素外，还有一些其他的基本要素。这些要素是所有爱的形式共有的，那就是：关心、责任心、尊重和了解。尊重就是要努力地使对方能成长和发展自己，因此尊重决无剥削之意。我希望一个被我爱的人应该以他自己的方式和为了自己去成长、发展，而不是服务于我。如果我爱他人，我应该感到和他一致，而且接受他本来的面目，而不是要求他成为我希望的样子，以便使我能把他当作使用的对象。只有当我自己达到独立，在没有外援的情况下独立地走自己的路，即不想去控制和利用别人，只有在这种情况下，尊重对方才成为可能。父爱应该受一定的原则支配并提出一定的要求，应该是宽容的、耐心的，不应该是咄咄逼人和专横的。</p><p><strong>不生病凭什么(原是流民)</strong><br>自己喜欢看医学健康科普类读物这篇肯定不能错过了. 还讲了医院的历史, 医院的相关事宜等. </p><p><strong>非暴力沟通(马歇尔·卢森堡)</strong><br>我以前一直觉得不同语言给人带来的感觉是不一样的, 即使他想表达同一个意思, 但通过不同的语言它表达出来的效果不一样. 比方说日本自杀率高听说和他们的语言没有骂别人家人之类的内容来很好的发泄自己的情绪.(后来查了一下日本自杀率好像并不算高…) 或者说有两种语言表达的是同一个意思我都能听懂, 但是有时候会倾向于不喜欢其中一种语言. 但本书写的内容和我前面说的没啥干系. 非暴力沟通主要想表达我们应该如何运用组织语言来有效表达自己的感受, 区分描述和评价. 它主要包含以下几个要素: 1. 观察 2. 感受 3. 需要 4. 请求. 通过以上四要素基本能使用”无情绪化”的语言来表达自己的感受, 其实如果大家愿意学习这类表达能力, 世界上应该就会避免很多冲突. </p><p><strong>人类简史(尤瓦尔·赫拉利)</strong><br>作者从一些奇奇怪怪的角度来重新审视人类历史, 大开脑洞. </p><p><strong>逝者证言(秦明)</strong><br>通过小说了解法医群体. </p><p><strong>如何阅读一本书(莫提默·J. 艾德勒 &#x2F; 查尔斯·范多伦)</strong><br>学习很重要, 但学习如何学习更重要. 看书也是, 有各种各样的看书方法, 有的技巧教你节省看书时间并提高get到作者表达的点. </p><p><strong>自私的基因(理查德·道金斯)</strong><br>都已经忘了原来看过这本, 只是记得和朋友分享过一些内容. 看的快忘得快. </p><p><strong>丑陋的中国人(柏杨)</strong><br>本书指出了很多人存在的缺点, 就像一面镜子, 通过书本的反射我们应该考虑如何整顿自己. </p><p><strong>乌合之众(勒庞)</strong><br>大众心理学著作, 里面有些例子看起来很有意思. 后来听说现代的大众心理学都不用这些方法来研究了, 可能和真正的心理学著作还有差距. </p><p><strong>骆驼祥子(老舍)</strong><br>小说, 描写旧社会, 一个积极向上的祥子如何沦落到”城市垃圾”的地步, 当时看完觉得结局好灰暗. 良好的社会制度才能使人民走向良好哎. </p><p><strong>人性的弱点(戴尔卡耐基)</strong><br>记不大清高几看的了, 成功学大师卡耐基写的书, 来源是家里人那里翻到的, 主要写一些人与人之间的相处技巧, 然后拿名人的事迹举例, 现在看来这类书还是存在幸存者偏差. </p><p><strong>鲁滨逊漂流记(丹尼尔·笛福)</strong><br>是我初中的时候读的一本书, 当时我花了一个星期很快就读完了它, 因为是小说所以内容很有趣. 其实是因为当时自己的手机坏了没东西玩闲的才找同学借来看的. </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非计算机相关的书单. 计算机类的书单请请看&lt;a href=&quot;/2021/books-about-computer-science&quot;&gt;这里这里&lt;/a&gt;. &lt;/p&gt;</summary>
    
    
    
    
    <category term="Essay" scheme="https://someexp.com/tags/Essay/"/>
    
    <category term="Book" scheme="https://someexp.com/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>Scoop 笔记</title>
    <link href="https://someexp.com/2020/scoop-notes/"/>
    <id>https://someexp.com/2020/scoop-notes/</id>
    <published>2020-05-06T16:00:00.000Z</published>
    <updated>2022-11-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下 Scoop 使用指南.</p><span id="more"></span><p>可以使用 Scoop 来安装一些不需要 UAC 的软件. 当然你也可以使用微软官方的 WinGet.<br>首先Powershell这里要修改成允许远程脚本执行: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br></pre></td></tr></table></figure><p>然后执行远程的脚本进行安装: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br></pre></td></tr></table></figure><p>安装完测试一次下: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop help</span><br></pre></td></tr></table></figure><p>添加一个软件比较多的bucket: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add extras</span><br></pre></td></tr></table></figure><p>查看所有bucket: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket known</span><br></pre></td></tr></table></figure><p>添加一个大佬维护的bucket: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add dorado https://github.com/h404bi/dorado</span><br></pre></td></tr></table></figure><p>搜索微信: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop search wechat</span><br></pre></td></tr></table></figure><p>安装: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install dorado/wechat</span><br></pre></td></tr></table></figure><p><strong>数据隔离</strong></p><p>可以使用 run as different user 方式运行, 利用 windows 的多用户机制来实现数据隔离.</p><p>参考:<br><a href="https://sspai.com/post/52496">少数派: 「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件(https://sspai.com/post/52710</a><br><a href="https://sspai.com/post/52710">少数派: 给 Scoop 加上这些软件仓库，让它变成强大的 Windows 软件管理器</a><br><a href="https://github.com/lukesampson/scoop">Scoop官方rep</a><br><a href="https://github.com/h404bi/dorado">dorado</a></p>]]></content>
    
    
    <summary type="html">简单记录下 Scoop 使用指南.</summary>
    
    
    
    
    <category term="Win10" scheme="https://someexp.com/tags/Win10/"/>
    
  </entry>
  
</feed>
